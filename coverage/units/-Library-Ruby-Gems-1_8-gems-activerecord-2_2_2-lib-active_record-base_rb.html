<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>/Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Wed Feb 11 19:51:31 -0800 2009 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='-Library-Ruby-Gems-1_8-gems-activerecord-2_2_2-lib-active_record-base_rb.html'>/Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/base.rb</a>
        </td>
      <td class='lines_total'><tt>2967</tt>
        </td>
      <td class='lines_code'><tt>1407</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>73.9%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='74'/>
                  <td class='uncovered' width='26'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>48.7%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='49'/>
                  <td class='uncovered' width='51'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="marked1"><a name="line1"></a>   1 require 'yaml'
</span><span class="marked0"><a name="line2"></a>   2 require 'set'
</span><span class="inferred1"><a name="line3"></a>   3 
</span><span class="marked0"><a name="line4"></a>   4 module ActiveRecord #:nodoc:
</span><span class="inferred1"><a name="line5"></a>   5   # Generic Active Record exception class.
</span><span class="marked0"><a name="line6"></a>   6   class ActiveRecordError &lt; StandardError
</span><span class="inferred1"><a name="line7"></a>   7   end
</span><span class="inferred0"><a name="line8"></a>   8 
</span><span class="inferred1"><a name="line9"></a>   9   # Raised when the single-table inheritance mechanism fails to locate the subclass
</span><span class="inferred0"><a name="line10"></a>  10   # (for example due to improper usage of column that +inheritance_column+ points to).
</span><span class="marked1"><a name="line11"></a>  11   class SubclassNotFound &lt; ActiveRecordError #:nodoc:
</span><span class="inferred0"><a name="line12"></a>  12   end
</span><span class="inferred1"><a name="line13"></a>  13 
</span><span class="inferred0"><a name="line14"></a>  14   # Raised when an object assigned to an association has an incorrect type.
</span><span class="inferred1"><a name="line15"></a>  15   #
</span><span class="inferred0"><a name="line16"></a>  16   #   class Ticket &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line17"></a>  17   #     has_many :patches
</span><span class="inferred0"><a name="line18"></a>  18   #   end
</span><span class="inferred1"><a name="line19"></a>  19   #
</span><span class="inferred0"><a name="line20"></a>  20   #   class Patch &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line21"></a>  21   #     belongs_to :ticket
</span><span class="inferred0"><a name="line22"></a>  22   #   end
</span><span class="inferred1"><a name="line23"></a>  23   #
</span><span class="inferred0"><a name="line24"></a>  24   #   # Comments are not patches, this assignment raises AssociationTypeMismatch.
</span><span class="inferred1"><a name="line25"></a>  25   #   @ticket.patches &lt;&lt; Comment.new(:content =&gt; &quot;Please attach tests to your patch.&quot;)
</span><span class="marked0"><a name="line26"></a>  26   class AssociationTypeMismatch &lt; ActiveRecordError
</span><span class="inferred1"><a name="line27"></a>  27   end
</span><span class="inferred0"><a name="line28"></a>  28 
</span><span class="inferred1"><a name="line29"></a>  29   # Raised when unserialized object's type mismatches one specified for serializable field.
</span><span class="marked0"><a name="line30"></a>  30   class SerializationTypeMismatch &lt; ActiveRecordError
</span><span class="inferred1"><a name="line31"></a>  31   end
</span><span class="inferred0"><a name="line32"></a>  32 
</span><span class="inferred1"><a name="line33"></a>  33   # Raised when adapter not specified on connection (or configuration file &lt;tt&gt;config/database.yml&lt;/tt&gt; misses adapter field).
</span><span class="marked0"><a name="line34"></a>  34   class AdapterNotSpecified &lt; ActiveRecordError
</span><span class="inferred1"><a name="line35"></a>  35   end
</span><span class="inferred0"><a name="line36"></a>  36 
</span><span class="inferred1"><a name="line37"></a>  37   # Raised when Active Record cannot find database adapter specified in &lt;tt&gt;config/database.yml&lt;/tt&gt; or programmatically.
</span><span class="marked0"><a name="line38"></a>  38   class AdapterNotFound &lt; ActiveRecordError
</span><span class="inferred1"><a name="line39"></a>  39   end
</span><span class="inferred0"><a name="line40"></a>  40 
</span><span class="inferred1"><a name="line41"></a>  41   # Raised when connection to the database could not been established (for example when &lt;tt&gt;connection=&lt;/tt&gt; is given a nil object).
</span><span class="marked0"><a name="line42"></a>  42   class ConnectionNotEstablished &lt; ActiveRecordError
</span><span class="inferred1"><a name="line43"></a>  43   end
</span><span class="inferred0"><a name="line44"></a>  44 
</span><span class="inferred1"><a name="line45"></a>  45   # Raised when Active Record cannot find record by given id or set of ids.
</span><span class="marked0"><a name="line46"></a>  46   class RecordNotFound &lt; ActiveRecordError
</span><span class="inferred1"><a name="line47"></a>  47   end
</span><span class="inferred0"><a name="line48"></a>  48 
</span><span class="inferred1"><a name="line49"></a>  49   # Raised by ActiveRecord::Base.save! and ActiveRecord::Base.create! methods when record cannot be
</span><span class="inferred0"><a name="line50"></a>  50   # saved because record is invalid.
</span><span class="marked1"><a name="line51"></a>  51   class RecordNotSaved &lt; ActiveRecordError
</span><span class="inferred0"><a name="line52"></a>  52   end
</span><span class="inferred1"><a name="line53"></a>  53 
</span><span class="inferred0"><a name="line54"></a>  54   # Raised when SQL statement cannot be executed by the database (for example, it's often the case for MySQL when Ruby driver used is too old).
</span><span class="marked1"><a name="line55"></a>  55   class StatementInvalid &lt; ActiveRecordError
</span><span class="inferred0"><a name="line56"></a>  56   end
</span><span class="inferred1"><a name="line57"></a>  57 
</span><span class="inferred0"><a name="line58"></a>  58   # Raised when number of bind variables in statement given to &lt;tt&gt;:condition&lt;/tt&gt; key (for example, when using +find+ method)
</span><span class="inferred1"><a name="line59"></a>  59   # does not match number of expected variables.
</span><span class="inferred0"><a name="line60"></a>  60   #
</span><span class="inferred1"><a name="line61"></a>  61   # For example, in
</span><span class="inferred0"><a name="line62"></a>  62   #
</span><span class="inferred1"><a name="line63"></a>  63   #   Location.find :all, :conditions =&gt; [&quot;lat = ? AND lng = ?&quot;, 53.7362]
</span><span class="inferred0"><a name="line64"></a>  64   #
</span><span class="inferred1"><a name="line65"></a>  65   # two placeholders are given but only one variable to fill them.
</span><span class="marked0"><a name="line66"></a>  66   class PreparedStatementInvalid &lt; ActiveRecordError
</span><span class="inferred1"><a name="line67"></a>  67   end
</span><span class="inferred0"><a name="line68"></a>  68 
</span><span class="inferred1"><a name="line69"></a>  69   # Raised on attempt to save stale record. Record is stale when it's being saved in another query after
</span><span class="inferred0"><a name="line70"></a>  70   # instantiation, for example, when two users edit the same wiki page and one starts editing and saves
</span><span class="inferred1"><a name="line71"></a>  71   # the page before the other.
</span><span class="inferred0"><a name="line72"></a>  72   #
</span><span class="inferred1"><a name="line73"></a>  73   # Read more about optimistic locking in ActiveRecord::Locking module RDoc.
</span><span class="marked0"><a name="line74"></a>  74   class StaleObjectError &lt; ActiveRecordError
</span><span class="inferred1"><a name="line75"></a>  75   end
</span><span class="inferred0"><a name="line76"></a>  76 
</span><span class="inferred1"><a name="line77"></a>  77   # Raised when association is being configured improperly or
</span><span class="inferred0"><a name="line78"></a>  78   # user tries to use offset and limit together with has_many or has_and_belongs_to_many associations.
</span><span class="marked1"><a name="line79"></a>  79   class ConfigurationError &lt; ActiveRecordError
</span><span class="inferred0"><a name="line80"></a>  80   end
</span><span class="inferred1"><a name="line81"></a>  81 
</span><span class="inferred0"><a name="line82"></a>  82   # Raised on attempt to update record that is instantiated as read only.
</span><span class="marked1"><a name="line83"></a>  83   class ReadOnlyRecord &lt; ActiveRecordError
</span><span class="inferred0"><a name="line84"></a>  84   end
</span><span class="inferred1"><a name="line85"></a>  85 
</span><span class="inferred0"><a name="line86"></a>  86   # ActiveRecord::Transactions::ClassMethods.transaction uses this exception
</span><span class="inferred1"><a name="line87"></a>  87   # to distinguish a deliberate rollback from other exceptional situations.
</span><span class="inferred0"><a name="line88"></a>  88   # Normally, raising an exception will cause the +transaction+ method to rollback
</span><span class="inferred1"><a name="line89"></a>  89   # the database transaction *and* pass on the exception. But if you raise an
</span><span class="inferred0"><a name="line90"></a>  90   # ActiveRecord::Rollback exception, then the database transaction will be rolled back,
</span><span class="inferred1"><a name="line91"></a>  91   # without passing on the exception.
</span><span class="inferred0"><a name="line92"></a>  92   #
</span><span class="inferred1"><a name="line93"></a>  93   # For example, you could do this in your controller to rollback a transaction:
</span><span class="inferred0"><a name="line94"></a>  94   #
</span><span class="inferred1"><a name="line95"></a>  95   #   class BooksController &lt; ActionController::Base
</span><span class="inferred0"><a name="line96"></a>  96   #     def create
</span><span class="inferred1"><a name="line97"></a>  97   #       Book.transaction do
</span><span class="inferred0"><a name="line98"></a>  98   #         book = Book.new(params[:book])
</span><span class="inferred1"><a name="line99"></a>  99   #         book.save!
</span><span class="inferred0"><a name="line100"></a> 100   #         if today_is_friday?
</span><span class="inferred1"><a name="line101"></a> 101   #           # The system must fail on Friday so that our support department
</span><span class="inferred0"><a name="line102"></a> 102   #           # won't be out of job. We silently rollback this transaction
</span><span class="inferred1"><a name="line103"></a> 103   #           # without telling the user.
</span><span class="inferred0"><a name="line104"></a> 104   #           raise ActiveRecord::Rollback, &quot;Call tech support!&quot;
</span><span class="inferred1"><a name="line105"></a> 105   #         end
</span><span class="inferred0"><a name="line106"></a> 106   #       end
</span><span class="inferred1"><a name="line107"></a> 107   #       # ActiveRecord::Rollback is the only exception that won't be passed on
</span><span class="inferred0"><a name="line108"></a> 108   #       # by ActiveRecord::Base.transaction, so this line will still be reached
</span><span class="inferred1"><a name="line109"></a> 109   #       # even on Friday.
</span><span class="inferred0"><a name="line110"></a> 110   #       redirect_to root_url
</span><span class="inferred1"><a name="line111"></a> 111   #     end
</span><span class="inferred0"><a name="line112"></a> 112   #   end
</span><span class="marked1"><a name="line113"></a> 113   class Rollback &lt; ActiveRecordError
</span><span class="inferred0"><a name="line114"></a> 114   end
</span><span class="inferred1"><a name="line115"></a> 115 
</span><span class="inferred0"><a name="line116"></a> 116   # Raised when attribute has a name reserved by Active Record (when attribute has name of one of Active Record instance methods).
</span><span class="marked1"><a name="line117"></a> 117   class DangerousAttributeError &lt; ActiveRecordError
</span><span class="inferred0"><a name="line118"></a> 118   end
</span><span class="inferred1"><a name="line119"></a> 119 
</span><span class="inferred0"><a name="line120"></a> 120   # Raised when you've tried to access a column which wasn't loaded by your finder.
</span><span class="inferred1"><a name="line121"></a> 121   # Typically this is because &lt;tt&gt;:select&lt;/tt&gt; has been specified.
</span><span class="marked0"><a name="line122"></a> 122   class MissingAttributeError &lt; NoMethodError
</span><span class="inferred1"><a name="line123"></a> 123   end
</span><span class="inferred0"><a name="line124"></a> 124 
</span><span class="inferred1"><a name="line125"></a> 125   # Raised when unknown attributes are supplied via mass assignment.
</span><span class="marked0"><a name="line126"></a> 126   class UnknownAttributeError &lt; NoMethodError
</span><span class="inferred1"><a name="line127"></a> 127   end
</span><span class="inferred0"><a name="line128"></a> 128 
</span><span class="inferred1"><a name="line129"></a> 129   # Raised when an error occurred while doing a mass assignment to an attribute through the
</span><span class="inferred0"><a name="line130"></a> 130   # &lt;tt&gt;attributes=&lt;/tt&gt; method. The exception has an +attribute+ property that is the name of the
</span><span class="inferred1"><a name="line131"></a> 131   # offending attribute.
</span><span class="marked0"><a name="line132"></a> 132   class AttributeAssignmentError &lt; ActiveRecordError
</span><span class="marked1"><a name="line133"></a> 133     attr_reader :exception, :attribute
</span><span class="marked0"><a name="line134"></a> 134     def initialize(message, exception, attribute)
</span><span class="uncovered1"><a name="line135"></a> 135       @exception = exception
</span><span class="uncovered0"><a name="line136"></a> 136       @attribute = attribute
</span><span class="uncovered1"><a name="line137"></a> 137       @message = message
</span><span class="uncovered0"><a name="line138"></a> 138     end
</span><span class="uncovered1"><a name="line139"></a> 139   end
</span><span class="inferred0"><a name="line140"></a> 140 
</span><span class="inferred1"><a name="line141"></a> 141   # Raised when there are multiple errors while doing a mass assignment through the +attributes+
</span><span class="inferred0"><a name="line142"></a> 142   # method. The exception has an +errors+ property that contains an array of AttributeAssignmentError
</span><span class="inferred1"><a name="line143"></a> 143   # objects, each corresponding to the error while assigning to an attribute.
</span><span class="marked0"><a name="line144"></a> 144   class MultiparameterAssignmentErrors &lt; ActiveRecordError
</span><span class="marked1"><a name="line145"></a> 145     attr_reader :errors
</span><span class="marked0"><a name="line146"></a> 146     def initialize(errors)
</span><span class="uncovered1"><a name="line147"></a> 147       @errors = errors
</span><span class="uncovered0"><a name="line148"></a> 148     end
</span><span class="uncovered1"><a name="line149"></a> 149   end
</span><span class="inferred0"><a name="line150"></a> 150 
</span><span class="inferred1"><a name="line151"></a> 151   # Active Record objects don't specify their attributes directly, but rather infer them from the table definition with
</span><span class="inferred0"><a name="line152"></a> 152   # which they're linked. Adding, removing, and changing attributes and their type is done directly in the database. Any change
</span><span class="inferred1"><a name="line153"></a> 153   # is instantly reflected in the Active Record objects. The mapping that binds a given Active Record class to a certain
</span><span class="inferred0"><a name="line154"></a> 154   # database table will happen automatically in most common cases, but can be overwritten for the uncommon ones.
</span><span class="inferred1"><a name="line155"></a> 155   #
</span><span class="inferred0"><a name="line156"></a> 156   # See the mapping rules in table_name and the full example in link:files/README.html for more insight.
</span><span class="inferred1"><a name="line157"></a> 157   #
</span><span class="inferred0"><a name="line158"></a> 158   # == Creation
</span><span class="inferred1"><a name="line159"></a> 159   #
</span><span class="inferred0"><a name="line160"></a> 160   # Active Records accept constructor parameters either in a hash or as a block. The hash method is especially useful when
</span><span class="inferred1"><a name="line161"></a> 161   # you're receiving the data from somewhere else, like an HTTP request. It works like this:
</span><span class="inferred0"><a name="line162"></a> 162   #
</span><span class="inferred1"><a name="line163"></a> 163   #   user = User.new(:name =&gt; &quot;David&quot;, :occupation =&gt; &quot;Code Artist&quot;)
</span><span class="inferred0"><a name="line164"></a> 164   #   user.name # =&gt; &quot;David&quot;
</span><span class="inferred1"><a name="line165"></a> 165   #
</span><span class="inferred0"><a name="line166"></a> 166   # You can also use block initialization:
</span><span class="inferred1"><a name="line167"></a> 167   #
</span><span class="inferred0"><a name="line168"></a> 168   #   user = User.new do |u|
</span><span class="inferred1"><a name="line169"></a> 169   #     u.name = &quot;David&quot;
</span><span class="inferred0"><a name="line170"></a> 170   #     u.occupation = &quot;Code Artist&quot;
</span><span class="inferred1"><a name="line171"></a> 171   #   end
</span><span class="inferred0"><a name="line172"></a> 172   #
</span><span class="inferred1"><a name="line173"></a> 173   # And of course you can just create a bare object and specify the attributes after the fact:
</span><span class="inferred0"><a name="line174"></a> 174   #
</span><span class="inferred1"><a name="line175"></a> 175   #   user = User.new
</span><span class="inferred0"><a name="line176"></a> 176   #   user.name = &quot;David&quot;
</span><span class="inferred1"><a name="line177"></a> 177   #   user.occupation = &quot;Code Artist&quot;
</span><span class="inferred0"><a name="line178"></a> 178   #
</span><span class="inferred1"><a name="line179"></a> 179   # == Conditions
</span><span class="inferred0"><a name="line180"></a> 180   #
</span><span class="inferred1"><a name="line181"></a> 181   # Conditions can either be specified as a string, array, or hash representing the WHERE-part of an SQL statement.
</span><span class="inferred0"><a name="line182"></a> 182   # The array form is to be used when the condition input is tainted and requires sanitization. The string form can
</span><span class="inferred1"><a name="line183"></a> 183   # be used for statements that don't involve tainted data. The hash form works much like the array form, except
</span><span class="inferred0"><a name="line184"></a> 184   # only equality and range is possible. Examples:
</span><span class="inferred1"><a name="line185"></a> 185   #
</span><span class="inferred0"><a name="line186"></a> 186   #   class User &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line187"></a> 187   #     def self.authenticate_unsafely(user_name, password)
</span><span class="inferred0"><a name="line188"></a> 188   #       find(:first, :conditions =&gt; &quot;user_name = '#{user_name}' AND password = '#{password}'&quot;)
</span><span class="inferred1"><a name="line189"></a> 189   #     end
</span><span class="inferred0"><a name="line190"></a> 190   #
</span><span class="inferred1"><a name="line191"></a> 191   #     def self.authenticate_safely(user_name, password)
</span><span class="inferred0"><a name="line192"></a> 192   #       find(:first, :conditions =&gt; [ &quot;user_name = ? AND password = ?&quot;, user_name, password ])
</span><span class="inferred1"><a name="line193"></a> 193   #     end
</span><span class="inferred0"><a name="line194"></a> 194   #
</span><span class="inferred1"><a name="line195"></a> 195   #     def self.authenticate_safely_simply(user_name, password)
</span><span class="inferred0"><a name="line196"></a> 196   #       find(:first, :conditions =&gt; { :user_name =&gt; user_name, :password =&gt; password })
</span><span class="inferred1"><a name="line197"></a> 197   #     end
</span><span class="inferred0"><a name="line198"></a> 198   #   end
</span><span class="inferred1"><a name="line199"></a> 199   #
</span><span class="inferred0"><a name="line200"></a> 200   # The &lt;tt&gt;authenticate_unsafely&lt;/tt&gt; method inserts the parameters directly into the query and is thus susceptible to SQL-injection
</span><span class="inferred1"><a name="line201"></a> 201   # attacks if the &lt;tt&gt;user_name&lt;/tt&gt; and +password+ parameters come directly from an HTTP request. The &lt;tt&gt;authenticate_safely&lt;/tt&gt;  and
</span><span class="inferred0"><a name="line202"></a> 202   # &lt;tt&gt;authenticate_safely_simply&lt;/tt&gt; both will sanitize the &lt;tt&gt;user_name&lt;/tt&gt; and +password+ before inserting them in the query,
</span><span class="inferred1"><a name="line203"></a> 203   # which will ensure that an attacker can't escape the query and fake the login (or worse).
</span><span class="inferred0"><a name="line204"></a> 204   #
</span><span class="inferred1"><a name="line205"></a> 205   # When using multiple parameters in the conditions, it can easily become hard to read exactly what the fourth or fifth
</span><span class="inferred0"><a name="line206"></a> 206   # question mark is supposed to represent. In those cases, you can resort to named bind variables instead. That's done by replacing
</span><span class="inferred1"><a name="line207"></a> 207   # the question marks with symbols and supplying a hash with values for the matching symbol keys:
</span><span class="inferred0"><a name="line208"></a> 208   #
</span><span class="inferred1"><a name="line209"></a> 209   #   Company.find(:first, :conditions =&gt; [
</span><span class="inferred0"><a name="line210"></a> 210   #     &quot;id = :id AND name = :name AND division = :division AND created_at &gt; :accounting_date&quot;,
</span><span class="inferred1"><a name="line211"></a> 211   #     { :id =&gt; 3, :name =&gt; &quot;37signals&quot;, :division =&gt; &quot;First&quot;, :accounting_date =&gt; '2005-01-01' }
</span><span class="inferred0"><a name="line212"></a> 212   #   ])
</span><span class="inferred1"><a name="line213"></a> 213   #
</span><span class="inferred0"><a name="line214"></a> 214   # Similarly, a simple hash without a statement will generate conditions based on equality with the SQL AND
</span><span class="inferred1"><a name="line215"></a> 215   # operator. For instance:
</span><span class="inferred0"><a name="line216"></a> 216   #
</span><span class="inferred1"><a name="line217"></a> 217   #   Student.find(:all, :conditions =&gt; { :first_name =&gt; &quot;Harvey&quot;, :status =&gt; 1 })
</span><span class="inferred0"><a name="line218"></a> 218   #   Student.find(:all, :conditions =&gt; params[:student])
</span><span class="inferred1"><a name="line219"></a> 219   #
</span><span class="inferred0"><a name="line220"></a> 220   # A range may be used in the hash to use the SQL BETWEEN operator:
</span><span class="inferred1"><a name="line221"></a> 221   #
</span><span class="inferred0"><a name="line222"></a> 222   #   Student.find(:all, :conditions =&gt; { :grade =&gt; 9..12 })
</span><span class="inferred1"><a name="line223"></a> 223   #
</span><span class="inferred0"><a name="line224"></a> 224   # An array may be used in the hash to use the SQL IN operator:
</span><span class="inferred1"><a name="line225"></a> 225   #
</span><span class="inferred0"><a name="line226"></a> 226   #   Student.find(:all, :conditions =&gt; { :grade =&gt; [9,11,12] })
</span><span class="inferred1"><a name="line227"></a> 227   #
</span><span class="inferred0"><a name="line228"></a> 228   # == Overwriting default accessors
</span><span class="inferred1"><a name="line229"></a> 229   #
</span><span class="inferred0"><a name="line230"></a> 230   # All column values are automatically available through basic accessors on the Active Record object, but sometimes you
</span><span class="inferred1"><a name="line231"></a> 231   # want to specialize this behavior. This can be done by overwriting the default accessors (using the same
</span><span class="inferred0"><a name="line232"></a> 232   # name as the attribute) and calling &lt;tt&gt;read_attribute(attr_name)&lt;/tt&gt; and &lt;tt&gt;write_attribute(attr_name, value)&lt;/tt&gt; to actually change things.
</span><span class="inferred1"><a name="line233"></a> 233   # Example:
</span><span class="inferred0"><a name="line234"></a> 234   #
</span><span class="inferred1"><a name="line235"></a> 235   #   class Song &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line236"></a> 236   #     # Uses an integer of seconds to hold the length of the song
</span><span class="inferred1"><a name="line237"></a> 237   #
</span><span class="inferred0"><a name="line238"></a> 238   #     def length=(minutes)
</span><span class="inferred1"><a name="line239"></a> 239   #       write_attribute(:length, minutes.to_i * 60)
</span><span class="inferred0"><a name="line240"></a> 240   #     end
</span><span class="inferred1"><a name="line241"></a> 241   #
</span><span class="inferred0"><a name="line242"></a> 242   #     def length
</span><span class="inferred1"><a name="line243"></a> 243   #       read_attribute(:length) / 60
</span><span class="inferred0"><a name="line244"></a> 244   #     end
</span><span class="inferred1"><a name="line245"></a> 245   #   end
</span><span class="inferred0"><a name="line246"></a> 246   #
</span><span class="inferred1"><a name="line247"></a> 247   # You can alternatively use &lt;tt&gt;self[:attribute]=(value)&lt;/tt&gt; and &lt;tt&gt;self[:attribute]&lt;/tt&gt; instead of &lt;tt&gt;write_attribute(:attribute, value)&lt;/tt&gt; and
</span><span class="inferred0"><a name="line248"></a> 248   # &lt;tt&gt;read_attribute(:attribute)&lt;/tt&gt; as a shorter form.
</span><span class="inferred1"><a name="line249"></a> 249   #
</span><span class="inferred0"><a name="line250"></a> 250   # == Attribute query methods
</span><span class="inferred1"><a name="line251"></a> 251   #
</span><span class="inferred0"><a name="line252"></a> 252   # In addition to the basic accessors, query methods are also automatically available on the Active Record object.
</span><span class="inferred1"><a name="line253"></a> 253   # Query methods allow you to test whether an attribute value is present.
</span><span class="inferred0"><a name="line254"></a> 254   #
</span><span class="inferred1"><a name="line255"></a> 255   # For example, an Active Record User with the &lt;tt&gt;name&lt;/tt&gt; attribute has a &lt;tt&gt;name?&lt;/tt&gt; method that you can call
</span><span class="inferred0"><a name="line256"></a> 256   # to determine whether the user has a name:
</span><span class="inferred1"><a name="line257"></a> 257   #
</span><span class="inferred0"><a name="line258"></a> 258   #   user = User.new(:name =&gt; &quot;David&quot;)
</span><span class="inferred1"><a name="line259"></a> 259   #   user.name? # =&gt; true
</span><span class="inferred0"><a name="line260"></a> 260   #
</span><span class="inferred1"><a name="line261"></a> 261   #   anonymous = User.new(:name =&gt; &quot;&quot;)
</span><span class="inferred0"><a name="line262"></a> 262   #   anonymous.name? # =&gt; false
</span><span class="inferred1"><a name="line263"></a> 263   #
</span><span class="inferred0"><a name="line264"></a> 264   # == Accessing attributes before they have been typecasted
</span><span class="inferred1"><a name="line265"></a> 265   #
</span><span class="inferred0"><a name="line266"></a> 266   # Sometimes you want to be able to read the raw attribute data without having the column-determined typecast run its course first.
</span><span class="inferred1"><a name="line267"></a> 267   # That can be done by using the &lt;tt&gt;&lt;attribute&gt;_before_type_cast&lt;/tt&gt; accessors that all attributes have. For example, if your Account model
</span><span class="inferred0"><a name="line268"></a> 268   # has a &lt;tt&gt;balance&lt;/tt&gt; attribute, you can call &lt;tt&gt;account.balance_before_type_cast&lt;/tt&gt; or &lt;tt&gt;account.id_before_type_cast&lt;/tt&gt;.
</span><span class="inferred1"><a name="line269"></a> 269   #
</span><span class="inferred0"><a name="line270"></a> 270   # This is especially useful in validation situations where the user might supply a string for an integer field and you want to display
</span><span class="inferred1"><a name="line271"></a> 271   # the original string back in an error message. Accessing the attribute normally would typecast the string to 0, which isn't what you
</span><span class="inferred0"><a name="line272"></a> 272   # want.
</span><span class="inferred1"><a name="line273"></a> 273   #
</span><span class="inferred0"><a name="line274"></a> 274   # == Dynamic attribute-based finders
</span><span class="inferred1"><a name="line275"></a> 275   #
</span><span class="inferred0"><a name="line276"></a> 276   # Dynamic attribute-based finders are a cleaner way of getting (and/or creating) objects by simple queries without turning to SQL. They work by
</span><span class="inferred1"><a name="line277"></a> 277   # appending the name of an attribute to &lt;tt&gt;find_by_&lt;/tt&gt;, &lt;tt&gt;find_last_by_&lt;/tt&gt;, or &lt;tt&gt;find_all_by_&lt;/tt&gt;, so you get finders like &lt;tt&gt;Person.find_by_user_name&lt;/tt&gt;,
</span><span class="inferred0"><a name="line278"></a> 278   # &lt;tt&gt;Person.find_all_by_last_name&lt;/tt&gt;, and &lt;tt&gt;Payment.find_by_transaction_id&lt;/tt&gt;. So instead of writing
</span><span class="inferred1"><a name="line279"></a> 279   # &lt;tt&gt;Person.find(:first, :conditions =&gt; [&quot;user_name = ?&quot;, user_name])&lt;/tt&gt;, you just do &lt;tt&gt;Person.find_by_user_name(user_name)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line280"></a> 280   # And instead of writing &lt;tt&gt;Person.find(:all, :conditions =&gt; [&quot;last_name = ?&quot;, last_name])&lt;/tt&gt;, you just do &lt;tt&gt;Person.find_all_by_last_name(last_name)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line281"></a> 281   #
</span><span class="inferred0"><a name="line282"></a> 282   # It's also possible to use multiple attributes in the same find by separating them with &quot;_and_&quot;, so you get finders like
</span><span class="inferred1"><a name="line283"></a> 283   # &lt;tt&gt;Person.find_by_user_name_and_password&lt;/tt&gt; or even &lt;tt&gt;Payment.find_by_purchaser_and_state_and_country&lt;/tt&gt;. So instead of writing
</span><span class="inferred0"><a name="line284"></a> 284   # &lt;tt&gt;Person.find(:first, :conditions =&gt; [&quot;user_name = ? AND password = ?&quot;, user_name, password])&lt;/tt&gt;, you just do
</span><span class="inferred1"><a name="line285"></a> 285   # &lt;tt&gt;Person.find_by_user_name_and_password(user_name, password)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line286"></a> 286   #
</span><span class="inferred1"><a name="line287"></a> 287   # It's even possible to use all the additional parameters to find. For example, the full interface for &lt;tt&gt;Payment.find_all_by_amount&lt;/tt&gt;
</span><span class="inferred0"><a name="line288"></a> 288   # is actually &lt;tt&gt;Payment.find_all_by_amount(amount, options)&lt;/tt&gt;. And the full interface to &lt;tt&gt;Person.find_by_user_name&lt;/tt&gt; is
</span><span class="inferred1"><a name="line289"></a> 289   # actually &lt;tt&gt;Person.find_by_user_name(user_name, options)&lt;/tt&gt;. So you could call &lt;tt&gt;Payment.find_all_by_amount(50, :order =&gt; &quot;created_on&quot;)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line290"></a> 290   # Also you may call &lt;tt&gt;Payment.find_last_by_amount(amount, options)&lt;/tt&gt; returning the last record matching that amount and options.
</span><span class="inferred1"><a name="line291"></a> 291   #
</span><span class="inferred0"><a name="line292"></a> 292   # The same dynamic finder style can be used to create the object if it doesn't already exist. This dynamic finder is called with
</span><span class="inferred1"><a name="line293"></a> 293   # &lt;tt&gt;find_or_create_by_&lt;/tt&gt; and will return the object if it already exists and otherwise creates it, then returns it. Protected attributes won't be set unless they are given in a block. For example:
</span><span class="inferred0"><a name="line294"></a> 294   #
</span><span class="inferred1"><a name="line295"></a> 295   #   # No 'Summer' tag exists
</span><span class="inferred0"><a name="line296"></a> 296   #   Tag.find_or_create_by_name(&quot;Summer&quot;) # equal to Tag.create(:name =&gt; &quot;Summer&quot;)
</span><span class="inferred1"><a name="line297"></a> 297   #
</span><span class="inferred0"><a name="line298"></a> 298   #   # Now the 'Summer' tag does exist
</span><span class="inferred1"><a name="line299"></a> 299   #   Tag.find_or_create_by_name(&quot;Summer&quot;) # equal to Tag.find_by_name(&quot;Summer&quot;)
</span><span class="inferred0"><a name="line300"></a> 300   #
</span><span class="inferred1"><a name="line301"></a> 301   #   # Now 'Bob' exist and is an 'admin'
</span><span class="inferred0"><a name="line302"></a> 302   #   User.find_or_create_by_name('Bob', :age =&gt; 40) { |u| u.admin = true }
</span><span class="inferred1"><a name="line303"></a> 303   #
</span><span class="inferred0"><a name="line304"></a> 304   # Use the &lt;tt&gt;find_or_initialize_by_&lt;/tt&gt; finder if you want to return a new record without saving it first. Protected attributes won't be set unless they are given in a block. For example:
</span><span class="inferred1"><a name="line305"></a> 305   #
</span><span class="inferred0"><a name="line306"></a> 306   #   # No 'Winter' tag exists
</span><span class="inferred1"><a name="line307"></a> 307   #   winter = Tag.find_or_initialize_by_name(&quot;Winter&quot;)
</span><span class="inferred0"><a name="line308"></a> 308   #   winter.new_record? # true
</span><span class="inferred1"><a name="line309"></a> 309   #
</span><span class="inferred0"><a name="line310"></a> 310   # To find by a subset of the attributes to be used for instantiating a new object, pass a hash instead of
</span><span class="inferred1"><a name="line311"></a> 311   # a list of parameters. For example:
</span><span class="inferred0"><a name="line312"></a> 312   #
</span><span class="inferred1"><a name="line313"></a> 313   #   Tag.find_or_create_by_name(:name =&gt; &quot;rails&quot;, :creator =&gt; current_user)
</span><span class="inferred0"><a name="line314"></a> 314   #
</span><span class="inferred1"><a name="line315"></a> 315   # That will either find an existing tag named &quot;rails&quot;, or create a new one while setting the user that created it.
</span><span class="inferred0"><a name="line316"></a> 316   #
</span><span class="inferred1"><a name="line317"></a> 317   # == Saving arrays, hashes, and other non-mappable objects in text columns
</span><span class="inferred0"><a name="line318"></a> 318   #
</span><span class="inferred1"><a name="line319"></a> 319   # Active Record can serialize any object in text columns using YAML. To do so, you must specify this with a call to the class method +serialize+.
</span><span class="inferred0"><a name="line320"></a> 320   # This makes it possible to store arrays, hashes, and other non-mappable objects without doing any additional work. Example:
</span><span class="inferred1"><a name="line321"></a> 321   #
</span><span class="inferred0"><a name="line322"></a> 322   #   class User &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line323"></a> 323   #     serialize :preferences
</span><span class="inferred0"><a name="line324"></a> 324   #   end
</span><span class="inferred1"><a name="line325"></a> 325   #
</span><span class="inferred0"><a name="line326"></a> 326   #   user = User.create(:preferences =&gt; { &quot;background&quot; =&gt; &quot;black&quot;, &quot;display&quot; =&gt; large })
</span><span class="inferred1"><a name="line327"></a> 327   #   User.find(user.id).preferences # =&gt; { &quot;background&quot; =&gt; &quot;black&quot;, &quot;display&quot; =&gt; large }
</span><span class="inferred0"><a name="line328"></a> 328   #
</span><span class="inferred1"><a name="line329"></a> 329   # You can also specify a class option as the second parameter that'll raise an exception if a serialized object is retrieved as a
</span><span class="inferred0"><a name="line330"></a> 330   # descendent of a class not in the hierarchy. Example:
</span><span class="inferred1"><a name="line331"></a> 331   #
</span><span class="inferred0"><a name="line332"></a> 332   #   class User &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line333"></a> 333   #     serialize :preferences, Hash
</span><span class="inferred0"><a name="line334"></a> 334   #   end
</span><span class="inferred1"><a name="line335"></a> 335   #
</span><span class="inferred0"><a name="line336"></a> 336   #   user = User.create(:preferences =&gt; %w( one two three ))
</span><span class="inferred1"><a name="line337"></a> 337   #   User.find(user.id).preferences    # raises SerializationTypeMismatch
</span><span class="inferred0"><a name="line338"></a> 338   #
</span><span class="inferred1"><a name="line339"></a> 339   # == Single table inheritance
</span><span class="inferred0"><a name="line340"></a> 340   #
</span><span class="inferred1"><a name="line341"></a> 341   # Active Record allows inheritance by storing the name of the class in a column that by default is named &quot;type&quot; (can be changed
</span><span class="inferred0"><a name="line342"></a> 342   # by overwriting &lt;tt&gt;Base.inheritance_column&lt;/tt&gt;). This means that an inheritance looking like this:
</span><span class="inferred1"><a name="line343"></a> 343   #
</span><span class="inferred0"><a name="line344"></a> 344   #   class Company &lt; ActiveRecord::Base; end
</span><span class="inferred1"><a name="line345"></a> 345   #   class Firm &lt; Company; end
</span><span class="inferred0"><a name="line346"></a> 346   #   class Client &lt; Company; end
</span><span class="inferred1"><a name="line347"></a> 347   #   class PriorityClient &lt; Client; end
</span><span class="inferred0"><a name="line348"></a> 348   #
</span><span class="inferred1"><a name="line349"></a> 349   # When you do &lt;tt&gt;Firm.create(:name =&gt; &quot;37signals&quot;)&lt;/tt&gt;, this record will be saved in the companies table with type = &quot;Firm&quot;. You can then
</span><span class="inferred0"><a name="line350"></a> 350   # fetch this row again using &lt;tt&gt;Company.find(:first, &quot;name = '37signals'&quot;)&lt;/tt&gt; and it will return a Firm object.
</span><span class="inferred1"><a name="line351"></a> 351   #
</span><span class="inferred0"><a name="line352"></a> 352   # If you don't have a type column defined in your table, single-table inheritance won't be triggered. In that case, it'll work just
</span><span class="inferred1"><a name="line353"></a> 353   # like normal subclasses with no special magic for differentiating between them or reloading the right type with find.
</span><span class="inferred0"><a name="line354"></a> 354   #
</span><span class="inferred1"><a name="line355"></a> 355   # Note, all the attributes for all the cases are kept in the same table. Read more:
</span><span class="inferred0"><a name="line356"></a> 356   # http://www.martinfowler.com/eaaCatalog/singleTableInheritance.html
</span><span class="inferred1"><a name="line357"></a> 357   #
</span><span class="inferred0"><a name="line358"></a> 358   # == Connection to multiple databases in different models
</span><span class="inferred1"><a name="line359"></a> 359   #
</span><span class="inferred0"><a name="line360"></a> 360   # Connections are usually created through ActiveRecord::Base.establish_connection and retrieved by ActiveRecord::Base.connection.
</span><span class="inferred1"><a name="line361"></a> 361   # All classes inheriting from ActiveRecord::Base will use this connection. But you can also set a class-specific connection.
</span><span class="inferred0"><a name="line362"></a> 362   # For example, if Course is an ActiveRecord::Base, but resides in a different database, you can just say &lt;tt&gt;Course.establish_connection&lt;/tt&gt;
</span><span class="inferred1"><a name="line363"></a> 363   # and Course and all of its subclasses will use this connection instead.
</span><span class="inferred0"><a name="line364"></a> 364   #
</span><span class="inferred1"><a name="line365"></a> 365   # This feature is implemented by keeping a connection pool in ActiveRecord::Base that is a Hash indexed by the class. If a connection is
</span><span class="inferred0"><a name="line366"></a> 366   # requested, the retrieve_connection method will go up the class-hierarchy until a connection is found in the connection pool.
</span><span class="inferred1"><a name="line367"></a> 367   #
</span><span class="inferred0"><a name="line368"></a> 368   # == Exceptions
</span><span class="inferred1"><a name="line369"></a> 369   #
</span><span class="inferred0"><a name="line370"></a> 370   # * ActiveRecordError - Generic error class and superclass of all other errors raised by Active Record.
</span><span class="inferred1"><a name="line371"></a> 371   # * AdapterNotSpecified - The configuration hash used in &lt;tt&gt;establish_connection&lt;/tt&gt; didn't include an
</span><span class="inferred0"><a name="line372"></a> 372   #   &lt;tt&gt;:adapter&lt;/tt&gt; key.
</span><span class="inferred1"><a name="line373"></a> 373   # * AdapterNotFound - The &lt;tt&gt;:adapter&lt;/tt&gt; key used in &lt;tt&gt;establish_connection&lt;/tt&gt; specified a non-existent adapter
</span><span class="inferred0"><a name="line374"></a> 374   #   (or a bad spelling of an existing one).
</span><span class="inferred1"><a name="line375"></a> 375   # * AssociationTypeMismatch - The object assigned to the association wasn't of the type specified in the association definition.
</span><span class="inferred0"><a name="line376"></a> 376   # * SerializationTypeMismatch - The serialized object wasn't of the class specified as the second parameter.
</span><span class="inferred1"><a name="line377"></a> 377   # * ConnectionNotEstablished+ - No connection has been established. Use &lt;tt&gt;establish_connection&lt;/tt&gt; before querying.
</span><span class="inferred0"><a name="line378"></a> 378   # * RecordNotFound - No record responded to the +find+ method. Either the row with the given ID doesn't exist
</span><span class="inferred1"><a name="line379"></a> 379   #   or the row didn't meet the additional restrictions. Some +find+ calls do not raise this exception to signal
</span><span class="inferred0"><a name="line380"></a> 380   #   nothing was found, please check its documentation for further details.
</span><span class="inferred1"><a name="line381"></a> 381   # * StatementInvalid - The database server rejected the SQL statement. The precise error is added in the message.
</span><span class="inferred0"><a name="line382"></a> 382   # * MultiparameterAssignmentErrors - Collection of errors that occurred during a mass assignment using the
</span><span class="inferred1"><a name="line383"></a> 383   #   &lt;tt&gt;attributes=&lt;/tt&gt; method. The +errors+ property of this exception contains an array of AttributeAssignmentError
</span><span class="inferred0"><a name="line384"></a> 384   #   objects that should be inspected to determine which attributes triggered the errors.
</span><span class="inferred1"><a name="line385"></a> 385   # * AttributeAssignmentError - An error occurred while doing a mass assignment through the &lt;tt&gt;attributes=&lt;/tt&gt; method.
</span><span class="inferred0"><a name="line386"></a> 386   #   You can inspect the +attribute+ property of the exception object to determine which attribute triggered the error.
</span><span class="inferred1"><a name="line387"></a> 387   #
</span><span class="inferred0"><a name="line388"></a> 388   # *Note*: The attributes listed are class-level attributes (accessible from both the class and instance level).
</span><span class="inferred1"><a name="line389"></a> 389   # So it's possible to assign a logger to the class through &lt;tt&gt;Base.logger=&lt;/tt&gt; which will then be used by all
</span><span class="inferred0"><a name="line390"></a> 390   # instances in the current object space.
</span><span class="marked1"><a name="line391"></a> 391   class Base
</span><span class="inferred0"><a name="line392"></a> 392     # Accepts a logger conforming to the interface of Log4r or the default Ruby 1.8+ Logger class, which is then passed
</span><span class="inferred1"><a name="line393"></a> 393     # on to any new database connections made and which can be retrieved on both a class and instance level by calling +logger+.
</span><span class="marked0"><a name="line394"></a> 394     cattr_accessor :logger, :instance_writer =&gt; false
</span><span class="inferred1"><a name="line395"></a> 395 
</span><span class="marked0"><a name="line396"></a> 396     def self.inherited(child) #:nodoc:
</span><span class="marked1"><a name="line397"></a> 397       @@subclasses[self] ||= []
</span><span class="marked0"><a name="line398"></a> 398       @@subclasses[self] &lt;&lt; child
</span><span class="marked1"><a name="line399"></a> 399       super
</span><span class="inferred0"><a name="line400"></a> 400     end
</span><span class="inferred1"><a name="line401"></a> 401 
</span><span class="marked0"><a name="line402"></a> 402     def self.reset_subclasses #:nodoc:
</span><span class="uncovered1"><a name="line403"></a> 403       nonreloadables = []
</span><span class="uncovered0"><a name="line404"></a> 404       subclasses.each do |klass|
</span><span class="uncovered1"><a name="line405"></a> 405         unless ActiveSupport::Dependencies.autoloaded? klass
</span><span class="uncovered0"><a name="line406"></a> 406           nonreloadables &lt;&lt; klass
</span><span class="uncovered1"><a name="line407"></a> 407           next
</span><span class="uncovered0"><a name="line408"></a> 408         end
</span><span class="uncovered1"><a name="line409"></a> 409         klass.instance_variables.each { |var| klass.send(:remove_instance_variable, var) }
</span><span class="uncovered0"><a name="line410"></a> 410         klass.instance_methods(false).each { |m| klass.send :undef_method, m }
</span><span class="uncovered1"><a name="line411"></a> 411       end
</span><span class="uncovered0"><a name="line412"></a> 412       @@subclasses = {}
</span><span class="uncovered1"><a name="line413"></a> 413       nonreloadables.each { |klass| (@@subclasses[klass.superclass] ||= []) &lt;&lt; klass }
</span><span class="uncovered0"><a name="line414"></a> 414     end
</span><span class="inferred1"><a name="line415"></a> 415 
</span><span class="marked0"><a name="line416"></a> 416     @@subclasses = {}
</span><span class="inferred1"><a name="line417"></a> 417 
</span><span class="inferred0"><a name="line418"></a> 418     # Contains the database configuration - as is typically stored in config/database.yml -
</span><span class="inferred1"><a name="line419"></a> 419     # as a Hash.
</span><span class="inferred0"><a name="line420"></a> 420     #
</span><span class="inferred1"><a name="line421"></a> 421     # For example, the following database.yml...
</span><span class="inferred0"><a name="line422"></a> 422     # 
</span><span class="inferred1"><a name="line423"></a> 423     #   development:
</span><span class="inferred0"><a name="line424"></a> 424     #     adapter: sqlite3
</span><span class="inferred1"><a name="line425"></a> 425     #     database: db/development.sqlite3
</span><span class="inferred0"><a name="line426"></a> 426     #   
</span><span class="inferred1"><a name="line427"></a> 427     #   production:
</span><span class="inferred0"><a name="line428"></a> 428     #     adapter: sqlite3
</span><span class="inferred1"><a name="line429"></a> 429     #     database: db/production.sqlite3
</span><span class="inferred0"><a name="line430"></a> 430     #
</span><span class="inferred1"><a name="line431"></a> 431     # ...would result in ActiveRecord::Base.configurations to look like this:
</span><span class="inferred0"><a name="line432"></a> 432     #
</span><span class="inferred1"><a name="line433"></a> 433     #   {
</span><span class="inferred0"><a name="line434"></a> 434     #      'development' =&gt; {
</span><span class="inferred1"><a name="line435"></a> 435     #         'adapter'  =&gt; 'sqlite3',
</span><span class="inferred0"><a name="line436"></a> 436     #         'database' =&gt; 'db/development.sqlite3'
</span><span class="inferred1"><a name="line437"></a> 437     #      },
</span><span class="inferred0"><a name="line438"></a> 438     #      'production' =&gt; {
</span><span class="inferred1"><a name="line439"></a> 439     #         'adapter'  =&gt; 'sqlite3',
</span><span class="inferred0"><a name="line440"></a> 440     #         'database' =&gt; 'db/production.sqlite3'
</span><span class="inferred1"><a name="line441"></a> 441     #      }
</span><span class="inferred0"><a name="line442"></a> 442     #   }
</span><span class="marked1"><a name="line443"></a> 443     cattr_accessor :configurations, :instance_writer =&gt; false
</span><span class="marked0"><a name="line444"></a> 444     @@configurations = {}
</span><span class="inferred1"><a name="line445"></a> 445 
</span><span class="inferred0"><a name="line446"></a> 446     # Accessor for the prefix type that will be prepended to every primary key column name. The options are :table_name and
</span><span class="inferred1"><a name="line447"></a> 447     # :table_name_with_underscore. If the first is specified, the Product class will look for &quot;productid&quot; instead of &quot;id&quot; as
</span><span class="inferred0"><a name="line448"></a> 448     # the primary column. If the latter is specified, the Product class will look for &quot;product_id&quot; instead of &quot;id&quot;. Remember
</span><span class="inferred1"><a name="line449"></a> 449     # that this is a global setting for all Active Records.
</span><span class="marked0"><a name="line450"></a> 450     cattr_accessor :primary_key_prefix_type, :instance_writer =&gt; false
</span><span class="marked1"><a name="line451"></a> 451     @@primary_key_prefix_type = nil
</span><span class="inferred0"><a name="line452"></a> 452 
</span><span class="inferred1"><a name="line453"></a> 453     # Accessor for the name of the prefix string to prepend to every table name. So if set to &quot;basecamp_&quot;, all
</span><span class="inferred0"><a name="line454"></a> 454     # table names will be named like &quot;basecamp_projects&quot;, &quot;basecamp_people&quot;, etc. This is a convenient way of creating a namespace
</span><span class="inferred1"><a name="line455"></a> 455     # for tables in a shared database. By default, the prefix is the empty string.
</span><span class="marked0"><a name="line456"></a> 456     cattr_accessor :table_name_prefix, :instance_writer =&gt; false
</span><span class="marked1"><a name="line457"></a> 457     @@table_name_prefix = &quot;&quot;
</span><span class="inferred0"><a name="line458"></a> 458 
</span><span class="inferred1"><a name="line459"></a> 459     # Works like +table_name_prefix+, but appends instead of prepends (set to &quot;_basecamp&quot; gives &quot;projects_basecamp&quot;,
</span><span class="inferred0"><a name="line460"></a> 460     # &quot;people_basecamp&quot;). By default, the suffix is the empty string.
</span><span class="marked1"><a name="line461"></a> 461     cattr_accessor :table_name_suffix, :instance_writer =&gt; false
</span><span class="marked0"><a name="line462"></a> 462     @@table_name_suffix = &quot;&quot;
</span><span class="inferred1"><a name="line463"></a> 463 
</span><span class="inferred0"><a name="line464"></a> 464     # Indicates whether table names should be the pluralized versions of the corresponding class names.
</span><span class="inferred1"><a name="line465"></a> 465     # If true, the default table name for a Product class will be +products+. If false, it would just be +product+.
</span><span class="inferred0"><a name="line466"></a> 466     # See table_name for the full rules on table/class naming. This is true, by default.
</span><span class="marked1"><a name="line467"></a> 467     cattr_accessor :pluralize_table_names, :instance_writer =&gt; false
</span><span class="marked0"><a name="line468"></a> 468     @@pluralize_table_names = true
</span><span class="inferred1"><a name="line469"></a> 469 
</span><span class="inferred0"><a name="line470"></a> 470     # Determines whether to use ANSI codes to colorize the logging statements committed by the connection adapter. These colors
</span><span class="inferred1"><a name="line471"></a> 471     # make it much easier to overview things during debugging (when used through a reader like +tail+ and on a black background), but
</span><span class="inferred0"><a name="line472"></a> 472     # may complicate matters if you use software like syslog. This is true, by default.
</span><span class="marked1"><a name="line473"></a> 473     cattr_accessor :colorize_logging, :instance_writer =&gt; false
</span><span class="marked0"><a name="line474"></a> 474     @@colorize_logging = true
</span><span class="inferred1"><a name="line475"></a> 475 
</span><span class="inferred0"><a name="line476"></a> 476     # Determines whether to use Time.local (using :local) or Time.utc (using :utc) when pulling dates and times from the database.
</span><span class="inferred1"><a name="line477"></a> 477     # This is set to :local by default.
</span><span class="marked0"><a name="line478"></a> 478     cattr_accessor :default_timezone, :instance_writer =&gt; false
</span><span class="marked1"><a name="line479"></a> 479     @@default_timezone = :local
</span><span class="inferred0"><a name="line480"></a> 480 
</span><span class="inferred1"><a name="line481"></a> 481     # Specifies the format to use when dumping the database schema with Rails'
</span><span class="inferred0"><a name="line482"></a> 482     # Rakefile.  If :sql, the schema is dumped as (potentially database-
</span><span class="inferred1"><a name="line483"></a> 483     # specific) SQL statements.  If :ruby, the schema is dumped as an
</span><span class="inferred0"><a name="line484"></a> 484     # ActiveRecord::Schema file which can be loaded into any database that
</span><span class="inferred1"><a name="line485"></a> 485     # supports migrations.  Use :ruby if you want to have different database
</span><span class="inferred0"><a name="line486"></a> 486     # adapters for, e.g., your development and test environments.
</span><span class="marked1"><a name="line487"></a> 487     cattr_accessor :schema_format , :instance_writer =&gt; false
</span><span class="marked0"><a name="line488"></a> 488     @@schema_format = :ruby
</span><span class="inferred1"><a name="line489"></a> 489 
</span><span class="inferred0"><a name="line490"></a> 490     # Specify whether or not to use timestamps for migration numbers
</span><span class="marked1"><a name="line491"></a> 491     cattr_accessor :timestamped_migrations , :instance_writer =&gt; false
</span><span class="marked0"><a name="line492"></a> 492     @@timestamped_migrations = true
</span><span class="inferred1"><a name="line493"></a> 493 
</span><span class="inferred0"><a name="line494"></a> 494     # Determine whether to store the full constant name including namespace when using STI
</span><span class="marked1"><a name="line495"></a> 495     superclass_delegating_accessor :store_full_sti_class
</span><span class="marked0"><a name="line496"></a> 496     self.store_full_sti_class = false
</span><span class="inferred1"><a name="line497"></a> 497 
</span><span class="marked0"><a name="line498"></a> 498     class &lt;&lt; self # Class methods
</span><span class="inferred1"><a name="line499"></a> 499       # Find operates with four different retrieval approaches:
</span><span class="inferred0"><a name="line500"></a> 500       #
</span><span class="inferred1"><a name="line501"></a> 501       # * Find by id - This can either be a specific id (1), a list of ids (1, 5, 6), or an array of ids ([5, 6, 10]).
</span><span class="inferred0"><a name="line502"></a> 502       #   If no record can be found for all of the listed ids, then RecordNotFound will be raised.
</span><span class="inferred1"><a name="line503"></a> 503       # * Find first - This will return the first record matched by the options used. These options can either be specific
</span><span class="inferred0"><a name="line504"></a> 504       #   conditions or merely an order. If no record can be matched, +nil+ is returned. Use
</span><span class="inferred1"><a name="line505"></a> 505       #   &lt;tt&gt;Model.find(:first, *args)&lt;/tt&gt; or its shortcut &lt;tt&gt;Model.first(*args)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line506"></a> 506       # * Find last - This will return the last record matched by the options used. These options can either be specific
</span><span class="inferred1"><a name="line507"></a> 507       #   conditions or merely an order. If no record can be matched, +nil+ is returned. Use
</span><span class="inferred0"><a name="line508"></a> 508       #   &lt;tt&gt;Model.find(:last, *args)&lt;/tt&gt; or its shortcut &lt;tt&gt;Model.last(*args)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line509"></a> 509       # * Find all - This will return all the records matched by the options used.
</span><span class="inferred0"><a name="line510"></a> 510       #   If no records are found, an empty array is returned. Use
</span><span class="inferred1"><a name="line511"></a> 511       #   &lt;tt&gt;Model.find(:all, *args)&lt;/tt&gt; or its shortcut &lt;tt&gt;Model.all(*args)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line512"></a> 512       #
</span><span class="inferred1"><a name="line513"></a> 513       # All approaches accept an options hash as their last parameter.
</span><span class="inferred0"><a name="line514"></a> 514       #
</span><span class="inferred1"><a name="line515"></a> 515       # ==== Parameters
</span><span class="inferred0"><a name="line516"></a> 516       #
</span><span class="inferred1"><a name="line517"></a> 517       # * &lt;tt&gt;:conditions&lt;/tt&gt; - An SQL fragment like &quot;administrator = 1&quot;, &lt;tt&gt;[ &quot;user_name = ?&quot;, username ]&lt;/tt&gt;, or &lt;tt&gt;[&quot;user_name = :user_name&quot;, { :user_name =&gt; user_name }]&lt;/tt&gt;. See conditions in the intro.
</span><span class="inferred0"><a name="line518"></a> 518       # * &lt;tt&gt;:order&lt;/tt&gt; - An SQL fragment like &quot;created_at DESC, name&quot;.
</span><span class="inferred1"><a name="line519"></a> 519       # * &lt;tt&gt;:group&lt;/tt&gt; - An attribute name by which the result should be grouped. Uses the &lt;tt&gt;GROUP BY&lt;/tt&gt; SQL-clause.
</span><span class="inferred0"><a name="line520"></a> 520       # * &lt;tt&gt;:limit&lt;/tt&gt; - An integer determining the limit on the number of rows that should be returned.
</span><span class="inferred1"><a name="line521"></a> 521       # * &lt;tt&gt;:offset&lt;/tt&gt; - An integer determining the offset from where the rows should be fetched. So at 5, it would skip rows 0 through 4.
</span><span class="inferred0"><a name="line522"></a> 522       # * &lt;tt&gt;:joins&lt;/tt&gt; - Either an SQL fragment for additional joins like &quot;LEFT JOIN comments ON comments.post_id = id&quot; (rarely needed)
</span><span class="inferred1"><a name="line523"></a> 523       #   or named associations in the same form used for the &lt;tt&gt;:include&lt;/tt&gt; option, which will perform an &lt;tt&gt;INNER JOIN&lt;/tt&gt; on the associated table(s).
</span><span class="inferred0"><a name="line524"></a> 524       #   If the value is a string, then the records will be returned read-only since they will have attributes that do not correspond to the table's columns.
</span><span class="inferred1"><a name="line525"></a> 525       #   Pass &lt;tt&gt;:readonly =&gt; false&lt;/tt&gt; to override.
</span><span class="inferred0"><a name="line526"></a> 526       # * &lt;tt&gt;:include&lt;/tt&gt; - Names associations that should be loaded alongside. The symbols named refer
</span><span class="inferred1"><a name="line527"></a> 527       #   to already defined associations. See eager loading under Associations.
</span><span class="inferred0"><a name="line528"></a> 528       # * &lt;tt&gt;:select&lt;/tt&gt; - By default, this is &quot;*&quot; as in &quot;SELECT * FROM&quot;, but can be changed if you, for example, want to do a join but not
</span><span class="inferred1"><a name="line529"></a> 529       #   include the joined columns. Takes a string with the SELECT SQL fragment (e.g. &quot;id, name&quot;).
</span><span class="inferred0"><a name="line530"></a> 530       # * &lt;tt&gt;:from&lt;/tt&gt; - By default, this is the table name of the class, but can be changed to an alternate table name (or even the name
</span><span class="inferred1"><a name="line531"></a> 531       #   of a database view).
</span><span class="inferred0"><a name="line532"></a> 532       # * &lt;tt&gt;:readonly&lt;/tt&gt; - Mark the returned records read-only so they cannot be saved or updated.
</span><span class="inferred1"><a name="line533"></a> 533       # * &lt;tt&gt;:lock&lt;/tt&gt; - An SQL fragment like &quot;FOR UPDATE&quot; or &quot;LOCK IN SHARE MODE&quot;.
</span><span class="inferred0"><a name="line534"></a> 534       #   &lt;tt&gt;:lock =&gt; true&lt;/tt&gt; gives connection's default exclusive lock, usually &quot;FOR UPDATE&quot;.
</span><span class="inferred1"><a name="line535"></a> 535       #
</span><span class="inferred0"><a name="line536"></a> 536       # ==== Examples
</span><span class="inferred1"><a name="line537"></a> 537       #
</span><span class="inferred0"><a name="line538"></a> 538       #   # find by id
</span><span class="inferred1"><a name="line539"></a> 539       #   Person.find(1)       # returns the object for ID = 1
</span><span class="inferred0"><a name="line540"></a> 540       #   Person.find(1, 2, 6) # returns an array for objects with IDs in (1, 2, 6)
</span><span class="inferred1"><a name="line541"></a> 541       #   Person.find([7, 17]) # returns an array for objects with IDs in (7, 17)
</span><span class="inferred0"><a name="line542"></a> 542       #   Person.find([1])     # returns an array for the object with ID = 1
</span><span class="inferred1"><a name="line543"></a> 543       #   Person.find(1, :conditions =&gt; &quot;administrator = 1&quot;, :order =&gt; &quot;created_on DESC&quot;)
</span><span class="inferred0"><a name="line544"></a> 544       #
</span><span class="inferred1"><a name="line545"></a> 545       # Note that returned records may not be in the same order as the ids you
</span><span class="inferred0"><a name="line546"></a> 546       # provide since database rows are unordered. Give an explicit &lt;tt&gt;:order&lt;/tt&gt;
</span><span class="inferred1"><a name="line547"></a> 547       # to ensure the results are sorted.
</span><span class="inferred0"><a name="line548"></a> 548       #
</span><span class="inferred1"><a name="line549"></a> 549       # ==== Examples
</span><span class="inferred0"><a name="line550"></a> 550       #
</span><span class="inferred1"><a name="line551"></a> 551       #   # find first
</span><span class="inferred0"><a name="line552"></a> 552       #   Person.find(:first) # returns the first object fetched by SELECT * FROM people
</span><span class="inferred1"><a name="line553"></a> 553       #   Person.find(:first, :conditions =&gt; [ &quot;user_name = ?&quot;, user_name])
</span><span class="inferred0"><a name="line554"></a> 554       #   Person.find(:first, :conditions =&gt; [ &quot;user_name = :u&quot;, { :u =&gt; user_name }])
</span><span class="inferred1"><a name="line555"></a> 555       #   Person.find(:first, :order =&gt; &quot;created_on DESC&quot;, :offset =&gt; 5)
</span><span class="inferred0"><a name="line556"></a> 556       #
</span><span class="inferred1"><a name="line557"></a> 557       #   # find last
</span><span class="inferred0"><a name="line558"></a> 558       #   Person.find(:last) # returns the last object fetched by SELECT * FROM people
</span><span class="inferred1"><a name="line559"></a> 559       #   Person.find(:last, :conditions =&gt; [ &quot;user_name = ?&quot;, user_name])
</span><span class="inferred0"><a name="line560"></a> 560       #   Person.find(:last, :order =&gt; &quot;created_on DESC&quot;, :offset =&gt; 5)
</span><span class="inferred1"><a name="line561"></a> 561       #
</span><span class="inferred0"><a name="line562"></a> 562       #   # find all
</span><span class="inferred1"><a name="line563"></a> 563       #   Person.find(:all) # returns an array of objects for all the rows fetched by SELECT * FROM people
</span><span class="inferred0"><a name="line564"></a> 564       #   Person.find(:all, :conditions =&gt; [ &quot;category IN (?)&quot;, categories], :limit =&gt; 50)
</span><span class="inferred1"><a name="line565"></a> 565       #   Person.find(:all, :conditions =&gt; { :friends =&gt; [&quot;Bob&quot;, &quot;Steve&quot;, &quot;Fred&quot;] }
</span><span class="inferred0"><a name="line566"></a> 566       #   Person.find(:all, :offset =&gt; 10, :limit =&gt; 10)
</span><span class="inferred1"><a name="line567"></a> 567       #   Person.find(:all, :include =&gt; [ :account, :friends ])
</span><span class="inferred0"><a name="line568"></a> 568       #   Person.find(:all, :group =&gt; &quot;category&quot;)
</span><span class="inferred1"><a name="line569"></a> 569       #
</span><span class="inferred0"><a name="line570"></a> 570       # Example for find with a lock: Imagine two concurrent transactions:
</span><span class="inferred1"><a name="line571"></a> 571       # each will read &lt;tt&gt;person.visits == 2&lt;/tt&gt;, add 1 to it, and save, resulting
</span><span class="inferred0"><a name="line572"></a> 572       # in two saves of &lt;tt&gt;person.visits = 3&lt;/tt&gt;.  By locking the row, the second
</span><span class="inferred1"><a name="line573"></a> 573       # transaction has to wait until the first is finished; we get the
</span><span class="inferred0"><a name="line574"></a> 574       # expected &lt;tt&gt;person.visits == 4&lt;/tt&gt;.
</span><span class="inferred1"><a name="line575"></a> 575       #
</span><span class="inferred0"><a name="line576"></a> 576       #   Person.transaction do
</span><span class="inferred1"><a name="line577"></a> 577       #     person = Person.find(1, :lock =&gt; true)
</span><span class="inferred0"><a name="line578"></a> 578       #     person.visits += 1
</span><span class="inferred1"><a name="line579"></a> 579       #     person.save!
</span><span class="inferred0"><a name="line580"></a> 580       #   end
</span><span class="marked1"><a name="line581"></a> 581       def find(*args)
</span><span class="marked0"><a name="line582"></a> 582         options = args.extract_options!
</span><span class="marked1"><a name="line583"></a> 583         validate_find_options(options)
</span><span class="marked0"><a name="line584"></a> 584         set_readonly_option!(options)
</span><span class="inferred1"><a name="line585"></a> 585 
</span><span class="marked0"><a name="line586"></a> 586         case args.first
</span><span class="marked1"><a name="line587"></a> 587           when :first then find_initial(options)
</span><span class="marked0"><a name="line588"></a> 588           when :last  then find_last(options)
</span><span class="marked1"><a name="line589"></a> 589           when :all   then find_every(options)
</span><span class="marked0"><a name="line590"></a> 590           else             find_from_ids(args, options)
</span><span class="inferred1"><a name="line591"></a> 591         end
</span><span class="inferred0"><a name="line592"></a> 592       end
</span><span class="inferred1"><a name="line593"></a> 593 
</span><span class="inferred0"><a name="line594"></a> 594       # A convenience wrapper for &lt;tt&gt;find(:first, *args)&lt;/tt&gt;. You can pass in all the
</span><span class="inferred1"><a name="line595"></a> 595       # same arguments to this method as you can to &lt;tt&gt;find(:first)&lt;/tt&gt;.
</span><span class="marked0"><a name="line596"></a> 596       def first(*args)
</span><span class="uncovered1"><a name="line597"></a> 597         find(:first, *args)
</span><span class="uncovered0"><a name="line598"></a> 598       end
</span><span class="inferred1"><a name="line599"></a> 599 
</span><span class="inferred0"><a name="line600"></a> 600       # A convenience wrapper for &lt;tt&gt;find(:last, *args)&lt;/tt&gt;. You can pass in all the
</span><span class="inferred1"><a name="line601"></a> 601       # same arguments to this method as you can to &lt;tt&gt;find(:last)&lt;/tt&gt;.
</span><span class="marked0"><a name="line602"></a> 602       def last(*args)
</span><span class="uncovered1"><a name="line603"></a> 603         find(:last, *args)
</span><span class="uncovered0"><a name="line604"></a> 604       end
</span><span class="inferred1"><a name="line605"></a> 605 
</span><span class="inferred0"><a name="line606"></a> 606       # This is an alias for find(:all).  You can pass in all the same arguments to this method as you can
</span><span class="inferred1"><a name="line607"></a> 607       # to find(:all)
</span><span class="marked0"><a name="line608"></a> 608       def all(*args)
</span><span class="uncovered1"><a name="line609"></a> 609         find(:all, *args)
</span><span class="uncovered0"><a name="line610"></a> 610       end
</span><span class="inferred1"><a name="line611"></a> 611 
</span><span class="inferred0"><a name="line612"></a> 612       # Executes a custom SQL query against your database and returns all the results.  The results will
</span><span class="inferred1"><a name="line613"></a> 613       # be returned as an array with columns requested encapsulated as attributes of the model you call
</span><span class="inferred0"><a name="line614"></a> 614       # this method from.  If you call &lt;tt&gt;Product.find_by_sql&lt;/tt&gt; then the results will be returned in
</span><span class="inferred1"><a name="line615"></a> 615       # a Product object with the attributes you specified in the SQL query.
</span><span class="inferred0"><a name="line616"></a> 616       #
</span><span class="inferred1"><a name="line617"></a> 617       # If you call a complicated SQL query which spans multiple tables the columns specified by the
</span><span class="inferred0"><a name="line618"></a> 618       # SELECT will be attributes of the model, whether or not they are columns of the corresponding
</span><span class="inferred1"><a name="line619"></a> 619       # table.
</span><span class="inferred0"><a name="line620"></a> 620       #
</span><span class="inferred1"><a name="line621"></a> 621       # The +sql+ parameter is a full SQL query as a string.  It will be called as is, there will be
</span><span class="inferred0"><a name="line622"></a> 622       # no database agnostic conversions performed.  This should be a last resort because using, for example,
</span><span class="inferred1"><a name="line623"></a> 623       # MySQL specific terms will lock you to using that particular database engine or require you to
</span><span class="inferred0"><a name="line624"></a> 624       # change your call if you switch engines.
</span><span class="inferred1"><a name="line625"></a> 625       #
</span><span class="inferred0"><a name="line626"></a> 626       # ==== Examples
</span><span class="inferred1"><a name="line627"></a> 627       #   # A simple SQL query spanning multiple tables
</span><span class="inferred0"><a name="line628"></a> 628       #   Post.find_by_sql &quot;SELECT p.title, c.author FROM posts p, comments c WHERE p.id = c.post_id&quot;
</span><span class="inferred1"><a name="line629"></a> 629       #   &gt; [#&lt;Post:0x36bff9c @attributes={&quot;title&quot;=&gt;&quot;Ruby Meetup&quot;, &quot;first_name&quot;=&gt;&quot;Quentin&quot;}&gt;, ...]
</span><span class="inferred0"><a name="line630"></a> 630       #
</span><span class="inferred1"><a name="line631"></a> 631       #   # You can use the same string replacement techniques as you can with ActiveRecord#find
</span><span class="inferred0"><a name="line632"></a> 632       #   Post.find_by_sql [&quot;SELECT title FROM posts WHERE author = ? AND created &gt; ?&quot;, author_id, start_date]
</span><span class="inferred1"><a name="line633"></a> 633       #   &gt; [#&lt;Post:0x36bff9c @attributes={&quot;first_name&quot;=&gt;&quot;The Cheap Man Buys Twice&quot;}&gt;, ...]
</span><span class="marked0"><a name="line634"></a> 634       def find_by_sql(sql)
</span><span class="marked1"><a name="line635"></a> 635         connection.select_all(sanitize_sql(sql), &quot;#{name} Load&quot;).collect! { |record| instantiate(record) }
</span><span class="marked0"><a name="line636"></a> 636       end
</span><span class="inferred1"><a name="line637"></a> 637 
</span><span class="inferred0"><a name="line638"></a> 638       # Checks whether a record exists in the database that matches conditions given.  These conditions
</span><span class="inferred1"><a name="line639"></a> 639       # can either be a single integer representing a primary key id to be found, or a condition to be
</span><span class="inferred0"><a name="line640"></a> 640       # matched like using ActiveRecord#find.
</span><span class="inferred1"><a name="line641"></a> 641       #
</span><span class="inferred0"><a name="line642"></a> 642       # The +id_or_conditions+ parameter can be an Integer or a String if you want to search the primary key
</span><span class="inferred1"><a name="line643"></a> 643       # column of the table for a matching id, or if you're looking to match against a condition you can use
</span><span class="inferred0"><a name="line644"></a> 644       # an Array or a Hash.
</span><span class="inferred1"><a name="line645"></a> 645       #
</span><span class="inferred0"><a name="line646"></a> 646       # Possible gotcha: You can't pass in a condition as a string e.g. &quot;name = 'Jamie'&quot;, this would be
</span><span class="inferred1"><a name="line647"></a> 647       # sanitized and then queried against the primary key column as &quot;id = 'name = \'Jamie&quot;
</span><span class="inferred0"><a name="line648"></a> 648       #
</span><span class="inferred1"><a name="line649"></a> 649       # ==== Examples
</span><span class="inferred0"><a name="line650"></a> 650       #   Person.exists?(5)
</span><span class="inferred1"><a name="line651"></a> 651       #   Person.exists?('5')
</span><span class="inferred0"><a name="line652"></a> 652       #   Person.exists?(:name =&gt; &quot;David&quot;)
</span><span class="inferred1"><a name="line653"></a> 653       #   Person.exists?(['name LIKE ?', &quot;%#{query}%&quot;])
</span><span class="marked0"><a name="line654"></a> 654       def exists?(id_or_conditions)
</span><span class="marked1"><a name="line655"></a> 655         connection.select_all(
</span><span class="inferred0"><a name="line656"></a> 656           construct_finder_sql(
</span><span class="marked1"><a name="line657"></a> 657             :select     =&gt; &quot;#{quoted_table_name}.#{primary_key}&quot;,
</span><span class="marked0"><a name="line658"></a> 658             :conditions =&gt; expand_id_conditions(id_or_conditions),
</span><span class="marked1"><a name="line659"></a> 659             :limit      =&gt; 1
</span><span class="uncovered0"><a name="line660"></a> 660           ),
</span><span class="uncovered1"><a name="line661"></a> 661           &quot;#{name} Exists&quot;
</span><span class="marked0"><a name="line662"></a> 662         ).size &gt; 0
</span><span class="marked1"><a name="line663"></a> 663       end
</span><span class="inferred0"><a name="line664"></a> 664 
</span><span class="inferred1"><a name="line665"></a> 665       # Creates an object (or multiple objects) and saves it to the database, if validations pass.
</span><span class="inferred0"><a name="line666"></a> 666       # The resulting object is returned whether the object was saved successfully to the database or not.
</span><span class="inferred1"><a name="line667"></a> 667       #
</span><span class="inferred0"><a name="line668"></a> 668       # The +attributes+ parameter can be either be a Hash or an Array of Hashes.  These Hashes describe the
</span><span class="inferred1"><a name="line669"></a> 669       # attributes on the objects that are to be created.
</span><span class="inferred0"><a name="line670"></a> 670       #
</span><span class="inferred1"><a name="line671"></a> 671       # ==== Examples
</span><span class="inferred0"><a name="line672"></a> 672       #   # Create a single new object
</span><span class="inferred1"><a name="line673"></a> 673       #   User.create(:first_name =&gt; 'Jamie')
</span><span class="inferred0"><a name="line674"></a> 674       #
</span><span class="inferred1"><a name="line675"></a> 675       #   # Create an Array of new objects
</span><span class="inferred0"><a name="line676"></a> 676       #   User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }])
</span><span class="inferred1"><a name="line677"></a> 677       #
</span><span class="inferred0"><a name="line678"></a> 678       #   # Create a single object and pass it into a block to set other attributes.
</span><span class="inferred1"><a name="line679"></a> 679       #   User.create(:first_name =&gt; 'Jamie') do |u|
</span><span class="inferred0"><a name="line680"></a> 680       #     u.is_admin = false
</span><span class="inferred1"><a name="line681"></a> 681       #   end
</span><span class="inferred0"><a name="line682"></a> 682       #
</span><span class="inferred1"><a name="line683"></a> 683       #   # Creating an Array of new objects using a block, where the block is executed for each object:
</span><span class="inferred0"><a name="line684"></a> 684       #   User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }]) do |u|
</span><span class="inferred1"><a name="line685"></a> 685       #     u.is_admin = false
</span><span class="inferred0"><a name="line686"></a> 686       #   end
</span><span class="marked1"><a name="line687"></a> 687       def create(attributes = nil, &amp;block)
</span><span class="uncovered0"><a name="line688"></a> 688         if attributes.is_a?(Array)
</span><span class="uncovered1"><a name="line689"></a> 689           attributes.collect { |attr| create(attr, &amp;block) }
</span><span class="uncovered0"><a name="line690"></a> 690         else
</span><span class="uncovered1"><a name="line691"></a> 691           object = new(attributes)
</span><span class="uncovered0"><a name="line692"></a> 692           yield(object) if block_given?
</span><span class="uncovered1"><a name="line693"></a> 693           object.save
</span><span class="uncovered0"><a name="line694"></a> 694           object
</span><span class="uncovered1"><a name="line695"></a> 695         end
</span><span class="uncovered0"><a name="line696"></a> 696       end
</span><span class="inferred1"><a name="line697"></a> 697 
</span><span class="inferred0"><a name="line698"></a> 698       # Updates an object (or multiple objects) and saves it to the database, if validations pass.
</span><span class="inferred1"><a name="line699"></a> 699       # The resulting object is returned whether the object was saved successfully to the database or not.
</span><span class="inferred0"><a name="line700"></a> 700       #
</span><span class="inferred1"><a name="line701"></a> 701       # ==== Parameters
</span><span class="inferred0"><a name="line702"></a> 702       #
</span><span class="inferred1"><a name="line703"></a> 703       # * +id+ - This should be the id or an array of ids to be updated.
</span><span class="inferred0"><a name="line704"></a> 704       # * +attributes+ - This should be a Hash of attributes to be set on the object, or an array of Hashes.
</span><span class="inferred1"><a name="line705"></a> 705       #
</span><span class="inferred0"><a name="line706"></a> 706       # ==== Examples
</span><span class="inferred1"><a name="line707"></a> 707       #
</span><span class="inferred0"><a name="line708"></a> 708       #   # Updating one record:
</span><span class="inferred1"><a name="line709"></a> 709       #   Person.update(15, { :user_name =&gt; 'Samuel', :group =&gt; 'expert' })
</span><span class="inferred0"><a name="line710"></a> 710       #
</span><span class="inferred1"><a name="line711"></a> 711       #   # Updating multiple records:
</span><span class="inferred0"><a name="line712"></a> 712       #   people = { 1 =&gt; { &quot;first_name&quot; =&gt; &quot;David&quot; }, 2 =&gt; { &quot;first_name&quot; =&gt; &quot;Jeremy&quot; } }
</span><span class="inferred1"><a name="line713"></a> 713       #   Person.update(people.keys, people.values)
</span><span class="marked0"><a name="line714"></a> 714       def update(id, attributes)
</span><span class="uncovered1"><a name="line715"></a> 715         if id.is_a?(Array)
</span><span class="uncovered0"><a name="line716"></a> 716           idx = -1
</span><span class="uncovered1"><a name="line717"></a> 717           id.collect { |one_id| idx += 1; update(one_id, attributes[idx]) }
</span><span class="uncovered0"><a name="line718"></a> 718         else
</span><span class="uncovered1"><a name="line719"></a> 719           object = find(id)
</span><span class="uncovered0"><a name="line720"></a> 720           object.update_attributes(attributes)
</span><span class="uncovered1"><a name="line721"></a> 721           object
</span><span class="uncovered0"><a name="line722"></a> 722         end
</span><span class="uncovered1"><a name="line723"></a> 723       end
</span><span class="inferred0"><a name="line724"></a> 724 
</span><span class="inferred1"><a name="line725"></a> 725       # Delete an object (or multiple objects) where the +id+ given matches the primary_key.  A SQL +DELETE+ command
</span><span class="inferred0"><a name="line726"></a> 726       # is executed on the database which means that no callbacks are fired off running this.  This is an efficient method
</span><span class="inferred1"><a name="line727"></a> 727       # of deleting records that don't need cleaning up after or other actions to be taken.
</span><span class="inferred0"><a name="line728"></a> 728       #
</span><span class="inferred1"><a name="line729"></a> 729       # Objects are _not_ instantiated with this method, and so +:dependent+ rules
</span><span class="inferred0"><a name="line730"></a> 730       # defined on associations are not honered.
</span><span class="inferred1"><a name="line731"></a> 731       #
</span><span class="inferred0"><a name="line732"></a> 732       # ==== Parameters
</span><span class="inferred1"><a name="line733"></a> 733       #
</span><span class="inferred0"><a name="line734"></a> 734       # * +id+ - Can be either an Integer or an Array of Integers.
</span><span class="inferred1"><a name="line735"></a> 735       #
</span><span class="inferred0"><a name="line736"></a> 736       # ==== Examples
</span><span class="inferred1"><a name="line737"></a> 737       #
</span><span class="inferred0"><a name="line738"></a> 738       #   # Delete a single object
</span><span class="inferred1"><a name="line739"></a> 739       #   Todo.delete(1)
</span><span class="inferred0"><a name="line740"></a> 740       #
</span><span class="inferred1"><a name="line741"></a> 741       #   # Delete multiple objects
</span><span class="inferred0"><a name="line742"></a> 742       #   todos = [1,2,3]
</span><span class="inferred1"><a name="line743"></a> 743       #   Todo.delete(todos)
</span><span class="marked0"><a name="line744"></a> 744       def delete(id)
</span><span class="uncovered1"><a name="line745"></a> 745         delete_all([ &quot;#{connection.quote_column_name(primary_key)} IN (?)&quot;, id ])
</span><span class="uncovered0"><a name="line746"></a> 746       end
</span><span class="inferred1"><a name="line747"></a> 747 
</span><span class="inferred0"><a name="line748"></a> 748       # Destroy an object (or multiple objects) that has the given id, the object is instantiated first,
</span><span class="inferred1"><a name="line749"></a> 749       # therefore all callbacks and filters are fired off before the object is deleted.  This method is
</span><span class="inferred0"><a name="line750"></a> 750       # less efficient than ActiveRecord#delete but allows cleanup methods and other actions to be run.
</span><span class="inferred1"><a name="line751"></a> 751       #
</span><span class="inferred0"><a name="line752"></a> 752       # This essentially finds the object (or multiple objects) with the given id, creates a new object
</span><span class="inferred1"><a name="line753"></a> 753       # from the attributes, and then calls destroy on it.
</span><span class="inferred0"><a name="line754"></a> 754       #
</span><span class="inferred1"><a name="line755"></a> 755       # ==== Parameters
</span><span class="inferred0"><a name="line756"></a> 756       #
</span><span class="inferred1"><a name="line757"></a> 757       # * +id+ - Can be either an Integer or an Array of Integers.
</span><span class="inferred0"><a name="line758"></a> 758       #
</span><span class="inferred1"><a name="line759"></a> 759       # ==== Examples
</span><span class="inferred0"><a name="line760"></a> 760       #
</span><span class="inferred1"><a name="line761"></a> 761       #   # Destroy a single object
</span><span class="inferred0"><a name="line762"></a> 762       #   Todo.destroy(1)
</span><span class="inferred1"><a name="line763"></a> 763       #
</span><span class="inferred0"><a name="line764"></a> 764       #   # Destroy multiple objects
</span><span class="inferred1"><a name="line765"></a> 765       #   todos = [1,2,3]
</span><span class="inferred0"><a name="line766"></a> 766       #   Todo.destroy(todos)
</span><span class="marked1"><a name="line767"></a> 767       def destroy(id)
</span><span class="uncovered0"><a name="line768"></a> 768         if id.is_a?(Array)
</span><span class="uncovered1"><a name="line769"></a> 769           id.map { |one_id| destroy(one_id) }
</span><span class="uncovered0"><a name="line770"></a> 770         else
</span><span class="uncovered1"><a name="line771"></a> 771           find(id).destroy
</span><span class="uncovered0"><a name="line772"></a> 772         end
</span><span class="uncovered1"><a name="line773"></a> 773       end
</span><span class="inferred0"><a name="line774"></a> 774 
</span><span class="inferred1"><a name="line775"></a> 775       # Updates all records with details given if they match a set of conditions supplied, limits and order can
</span><span class="inferred0"><a name="line776"></a> 776       # also be supplied. This method constructs a single SQL UPDATE statement and sends it straight to the
</span><span class="inferred1"><a name="line777"></a> 777       # database. It does not instantiate the involved models and it does not trigger Active Record callbacks.
</span><span class="inferred0"><a name="line778"></a> 778       #
</span><span class="inferred1"><a name="line779"></a> 779       # ==== Parameters
</span><span class="inferred0"><a name="line780"></a> 780       #
</span><span class="inferred1"><a name="line781"></a> 781       # * +updates+ - A string of column and value pairs that will be set on any records that match conditions.
</span><span class="inferred0"><a name="line782"></a> 782       #               What goes into the SET clause.
</span><span class="inferred1"><a name="line783"></a> 783       # * +conditions+ - An SQL fragment like &quot;administrator = 1&quot; or [ &quot;user_name = ?&quot;, username ]. See conditions in the intro for more info.
</span><span class="inferred0"><a name="line784"></a> 784       # * +options+ - Additional options are &lt;tt&gt;:limit&lt;/tt&gt; and &lt;tt&gt;:order&lt;/tt&gt;, see the examples for usage.
</span><span class="inferred1"><a name="line785"></a> 785       #
</span><span class="inferred0"><a name="line786"></a> 786       # ==== Examples
</span><span class="inferred1"><a name="line787"></a> 787       #
</span><span class="inferred0"><a name="line788"></a> 788       #   # Update all billing objects with the 3 different attributes given
</span><span class="inferred1"><a name="line789"></a> 789       #   Billing.update_all( &quot;category = 'authorized', approved = 1, author = 'David'&quot; )
</span><span class="inferred0"><a name="line790"></a> 790       #
</span><span class="inferred1"><a name="line791"></a> 791       #   # Update records that match our conditions
</span><span class="inferred0"><a name="line792"></a> 792       #   Billing.update_all( &quot;author = 'David'&quot;, &quot;title LIKE '%Rails%'&quot; )
</span><span class="inferred1"><a name="line793"></a> 793       #
</span><span class="inferred0"><a name="line794"></a> 794       #   # Update records that match our conditions but limit it to 5 ordered by date
</span><span class="inferred1"><a name="line795"></a> 795       #   Billing.update_all( &quot;author = 'David'&quot;, &quot;title LIKE '%Rails%'&quot;,
</span><span class="inferred0"><a name="line796"></a> 796       #                         :order =&gt; 'created_at', :limit =&gt; 5 )
</span><span class="marked1"><a name="line797"></a> 797       def update_all(updates, conditions = nil, options = {})
</span><span class="uncovered0"><a name="line798"></a> 798         sql  = &quot;UPDATE #{quoted_table_name} SET #{sanitize_sql_for_assignment(updates)} &quot;
</span><span class="uncovered1"><a name="line799"></a> 799 
</span><span class="uncovered0"><a name="line800"></a> 800         scope = scope(:find)
</span><span class="uncovered1"><a name="line801"></a> 801 
</span><span class="uncovered0"><a name="line802"></a> 802         select_sql = &quot;&quot;
</span><span class="uncovered1"><a name="line803"></a> 803         add_conditions!(select_sql, conditions, scope)
</span><span class="uncovered0"><a name="line804"></a> 804 
</span><span class="uncovered1"><a name="line805"></a> 805         if options.has_key?(:limit) || (scope &amp;&amp; scope[:limit])
</span><span class="uncovered0"><a name="line806"></a> 806           # Only take order from scope if limit is also provided by scope, this
</span><span class="uncovered1"><a name="line807"></a> 807           # is useful for updating a has_many association with a limit.
</span><span class="uncovered0"><a name="line808"></a> 808           add_order!(select_sql, options[:order], scope)
</span><span class="uncovered1"><a name="line809"></a> 809 
</span><span class="uncovered0"><a name="line810"></a> 810           add_limit!(select_sql, options, scope)
</span><span class="uncovered1"><a name="line811"></a> 811           sql.concat(connection.limited_update_conditions(select_sql, quoted_table_name, connection.quote_column_name(primary_key)))
</span><span class="uncovered0"><a name="line812"></a> 812         else
</span><span class="uncovered1"><a name="line813"></a> 813           add_order!(select_sql, options[:order], nil)
</span><span class="uncovered0"><a name="line814"></a> 814           sql.concat(select_sql)
</span><span class="uncovered1"><a name="line815"></a> 815         end
</span><span class="uncovered0"><a name="line816"></a> 816 
</span><span class="uncovered1"><a name="line817"></a> 817         connection.update(sql, &quot;#{name} Update&quot;)
</span><span class="uncovered0"><a name="line818"></a> 818       end
</span><span class="inferred1"><a name="line819"></a> 819 
</span><span class="inferred0"><a name="line820"></a> 820       # Destroys the records matching +conditions+ by instantiating each record and calling their +destroy+ method.
</span><span class="inferred1"><a name="line821"></a> 821       # This means at least 2*N database queries to destroy N records, so avoid +destroy_all+ if you are deleting
</span><span class="inferred0"><a name="line822"></a> 822       # many records. If you want to simply delete records without worrying about dependent associations or
</span><span class="inferred1"><a name="line823"></a> 823       # callbacks, use the much faster +delete_all+ method instead.
</span><span class="inferred0"><a name="line824"></a> 824       #
</span><span class="inferred1"><a name="line825"></a> 825       # ==== Parameters
</span><span class="inferred0"><a name="line826"></a> 826       #
</span><span class="inferred1"><a name="line827"></a> 827       # * +conditions+ - Conditions are specified the same way as with +find+ method.
</span><span class="inferred0"><a name="line828"></a> 828       #
</span><span class="inferred1"><a name="line829"></a> 829       # ==== Example
</span><span class="inferred0"><a name="line830"></a> 830       #
</span><span class="inferred1"><a name="line831"></a> 831       #   Person.destroy_all(&quot;last_login &lt; '2004-04-04'&quot;)
</span><span class="inferred0"><a name="line832"></a> 832       #
</span><span class="inferred1"><a name="line833"></a> 833       # This loads and destroys each person one by one, including its dependent associations and before_ and
</span><span class="inferred0"><a name="line834"></a> 834       # after_destroy callbacks.
</span><span class="inferred1"><a name="line835"></a> 835       #
</span><span class="inferred0"><a name="line836"></a> 836       # +conditions+ can be anything that +find+ also accepts:
</span><span class="inferred1"><a name="line837"></a> 837       #
</span><span class="inferred0"><a name="line838"></a> 838       #   Person.destroy_all(:last_login =&gt; 6.hours.ago)
</span><span class="marked1"><a name="line839"></a> 839       def destroy_all(conditions = nil)
</span><span class="uncovered0"><a name="line840"></a> 840         find(:all, :conditions =&gt; conditions).each { |object| object.destroy }
</span><span class="uncovered1"><a name="line841"></a> 841       end
</span><span class="inferred0"><a name="line842"></a> 842 
</span><span class="inferred1"><a name="line843"></a> 843       # Deletes the records matching +conditions+ without instantiating the records first, and hence not
</span><span class="inferred0"><a name="line844"></a> 844       # calling the +destroy+ method nor invoking callbacks. This is a single SQL DELETE statement that
</span><span class="inferred1"><a name="line845"></a> 845       # goes straight to the database, much more efficient than +destroy_all+. Be careful with relations
</span><span class="inferred0"><a name="line846"></a> 846       # though, in particular &lt;tt&gt;:dependent&lt;/tt&gt; rules defined on associations are not honored.
</span><span class="inferred1"><a name="line847"></a> 847       #
</span><span class="inferred0"><a name="line848"></a> 848       # ==== Parameters
</span><span class="inferred1"><a name="line849"></a> 849       #
</span><span class="inferred0"><a name="line850"></a> 850       # * +conditions+ - Conditions are specified the same way as with +find+ method.
</span><span class="inferred1"><a name="line851"></a> 851       #
</span><span class="inferred0"><a name="line852"></a> 852       # ==== Example
</span><span class="inferred1"><a name="line853"></a> 853       #
</span><span class="inferred0"><a name="line854"></a> 854       #   Post.delete_all(&quot;person_id = 5 AND (category = 'Something' OR category = 'Else')&quot;)
</span><span class="inferred1"><a name="line855"></a> 855       #   Post.delete_all([&quot;person_id = ? AND (category = ? OR category = ?)&quot;, 5, 'Something', 'Else'])
</span><span class="inferred0"><a name="line856"></a> 856       #
</span><span class="inferred1"><a name="line857"></a> 857       # Both calls delete the affected posts all at once with a single DELETE statement. If you need to destroy dependent
</span><span class="inferred0"><a name="line858"></a> 858       # associations or call your &lt;tt&gt;before_*&lt;/tt&gt; or +after_destroy+ callbacks, use the +destroy_all+ method instead.
</span><span class="marked1"><a name="line859"></a> 859       def delete_all(conditions = nil)
</span><span class="uncovered0"><a name="line860"></a> 860         sql = &quot;DELETE FROM #{quoted_table_name} &quot;
</span><span class="uncovered1"><a name="line861"></a> 861         add_conditions!(sql, conditions, scope(:find))
</span><span class="uncovered0"><a name="line862"></a> 862         connection.delete(sql, &quot;#{name} Delete all&quot;)
</span><span class="uncovered1"><a name="line863"></a> 863       end
</span><span class="inferred0"><a name="line864"></a> 864 
</span><span class="inferred1"><a name="line865"></a> 865       # Returns the result of an SQL statement that should only include a COUNT(*) in the SELECT part.
</span><span class="inferred0"><a name="line866"></a> 866       # The use of this method should be restricted to complicated SQL queries that can't be executed
</span><span class="inferred1"><a name="line867"></a> 867       # using the ActiveRecord::Calculations class methods.  Look into those before using this.
</span><span class="inferred0"><a name="line868"></a> 868       #
</span><span class="inferred1"><a name="line869"></a> 869       # ==== Parameters
</span><span class="inferred0"><a name="line870"></a> 870       #
</span><span class="inferred1"><a name="line871"></a> 871       # * +sql+ - An SQL statement which should return a count query from the database, see the example below.
</span><span class="inferred0"><a name="line872"></a> 872       #
</span><span class="inferred1"><a name="line873"></a> 873       # ==== Examples
</span><span class="inferred0"><a name="line874"></a> 874       #
</span><span class="inferred1"><a name="line875"></a> 875       #   Product.count_by_sql &quot;SELECT COUNT(*) FROM sales s, customers c WHERE s.customer_id = c.id&quot;
</span><span class="marked0"><a name="line876"></a> 876       def count_by_sql(sql)
</span><span class="uncovered1"><a name="line877"></a> 877         sql = sanitize_conditions(sql)
</span><span class="uncovered0"><a name="line878"></a> 878         connection.select_value(sql, &quot;#{name} Count&quot;).to_i
</span><span class="uncovered1"><a name="line879"></a> 879       end
</span><span class="inferred0"><a name="line880"></a> 880 
</span><span class="inferred1"><a name="line881"></a> 881       # A generic &quot;counter updater&quot; implementation, intended primarily to be
</span><span class="inferred0"><a name="line882"></a> 882       # used by increment_counter and decrement_counter, but which may also
</span><span class="inferred1"><a name="line883"></a> 883       # be useful on its own. It simply does a direct SQL update for the record
</span><span class="inferred0"><a name="line884"></a> 884       # with the given ID, altering the given hash of counters by the amount
</span><span class="inferred1"><a name="line885"></a> 885       # given by the corresponding value:
</span><span class="inferred0"><a name="line886"></a> 886       #
</span><span class="inferred1"><a name="line887"></a> 887       # ==== Parameters
</span><span class="inferred0"><a name="line888"></a> 888       #
</span><span class="inferred1"><a name="line889"></a> 889       # * +id+ - The id of the object you wish to update a counter on.
</span><span class="inferred0"><a name="line890"></a> 890       # * +counters+ - An Array of Hashes containing the names of the fields
</span><span class="inferred1"><a name="line891"></a> 891       #   to update as keys and the amount to update the field by as values.
</span><span class="inferred0"><a name="line892"></a> 892       #
</span><span class="inferred1"><a name="line893"></a> 893       # ==== Examples
</span><span class="inferred0"><a name="line894"></a> 894       #
</span><span class="inferred1"><a name="line895"></a> 895       #   # For the Post with id of 5, decrement the comment_count by 1, and
</span><span class="inferred0"><a name="line896"></a> 896       #   # increment the action_count by 1
</span><span class="inferred1"><a name="line897"></a> 897       #   Post.update_counters 5, :comment_count =&gt; -1, :action_count =&gt; 1
</span><span class="inferred0"><a name="line898"></a> 898       #   # Executes the following SQL:
</span><span class="inferred1"><a name="line899"></a> 899       #   # UPDATE posts
</span><span class="inferred0"><a name="line900"></a> 900       #   #    SET comment_count = comment_count - 1,
</span><span class="inferred1"><a name="line901"></a> 901       #   #        action_count = action_count + 1
</span><span class="inferred0"><a name="line902"></a> 902       #   #  WHERE id = 5
</span><span class="marked1"><a name="line903"></a> 903       def update_counters(id, counters)
</span><span class="uncovered0"><a name="line904"></a> 904         updates = counters.inject([]) { |list, (counter_name, increment)|
</span><span class="uncovered1"><a name="line905"></a> 905           sign = increment &lt; 0 ? &quot;-&quot; : &quot;+&quot;
</span><span class="uncovered0"><a name="line906"></a> 906           list &lt;&lt; &quot;#{connection.quote_column_name(counter_name)} = COALESCE(#{connection.quote_column_name(counter_name)}, 0) #{sign} #{increment.abs}&quot;
</span><span class="uncovered1"><a name="line907"></a> 907         }.join(&quot;, &quot;)
</span><span class="uncovered0"><a name="line908"></a> 908         update_all(updates, &quot;#{connection.quote_column_name(primary_key)} = #{quote_value(id)}&quot;)
</span><span class="uncovered1"><a name="line909"></a> 909       end
</span><span class="inferred0"><a name="line910"></a> 910 
</span><span class="inferred1"><a name="line911"></a> 911       # Increment a number field by one, usually representing a count.
</span><span class="inferred0"><a name="line912"></a> 912       #
</span><span class="inferred1"><a name="line913"></a> 913       # This is used for caching aggregate values, so that they don't need to be computed every time.
</span><span class="inferred0"><a name="line914"></a> 914       # For example, a DiscussionBoard may cache post_count and comment_count otherwise every time the board is
</span><span class="inferred1"><a name="line915"></a> 915       # shown it would have to run an SQL query to find how many posts and comments there are.
</span><span class="inferred0"><a name="line916"></a> 916       #
</span><span class="inferred1"><a name="line917"></a> 917       # ==== Parameters
</span><span class="inferred0"><a name="line918"></a> 918       #
</span><span class="inferred1"><a name="line919"></a> 919       # * +counter_name+ - The name of the field that should be incremented.
</span><span class="inferred0"><a name="line920"></a> 920       # * +id+ - The id of the object that should be incremented.
</span><span class="inferred1"><a name="line921"></a> 921       #
</span><span class="inferred0"><a name="line922"></a> 922       # ==== Examples
</span><span class="inferred1"><a name="line923"></a> 923       #
</span><span class="inferred0"><a name="line924"></a> 924       #   # Increment the post_count column for the record with an id of 5
</span><span class="inferred1"><a name="line925"></a> 925       #   DiscussionBoard.increment_counter(:post_count, 5)
</span><span class="marked0"><a name="line926"></a> 926       def increment_counter(counter_name, id)
</span><span class="uncovered1"><a name="line927"></a> 927         update_counters(id, counter_name =&gt; 1)
</span><span class="uncovered0"><a name="line928"></a> 928       end
</span><span class="inferred1"><a name="line929"></a> 929 
</span><span class="inferred0"><a name="line930"></a> 930       # Decrement a number field by one, usually representing a count.
</span><span class="inferred1"><a name="line931"></a> 931       #
</span><span class="inferred0"><a name="line932"></a> 932       # This works the same as increment_counter but reduces the column value by 1 instead of increasing it.
</span><span class="inferred1"><a name="line933"></a> 933       #
</span><span class="inferred0"><a name="line934"></a> 934       # ==== Parameters
</span><span class="inferred1"><a name="line935"></a> 935       #
</span><span class="inferred0"><a name="line936"></a> 936       # * +counter_name+ - The name of the field that should be decremented.
</span><span class="inferred1"><a name="line937"></a> 937       # * +id+ - The id of the object that should be decremented.
</span><span class="inferred0"><a name="line938"></a> 938       #
</span><span class="inferred1"><a name="line939"></a> 939       # ==== Examples
</span><span class="inferred0"><a name="line940"></a> 940       #
</span><span class="inferred1"><a name="line941"></a> 941       #   # Decrement the post_count column for the record with an id of 5
</span><span class="inferred0"><a name="line942"></a> 942       #   DiscussionBoard.decrement_counter(:post_count, 5)
</span><span class="marked1"><a name="line943"></a> 943       def decrement_counter(counter_name, id)
</span><span class="uncovered0"><a name="line944"></a> 944         update_counters(id, counter_name =&gt; -1)
</span><span class="uncovered1"><a name="line945"></a> 945       end
</span><span class="inferred0"><a name="line946"></a> 946 
</span><span class="inferred1"><a name="line947"></a> 947 
</span><span class="inferred0"><a name="line948"></a> 948       # Attributes named in this macro are protected from mass-assignment,
</span><span class="inferred1"><a name="line949"></a> 949       # such as &lt;tt&gt;new(attributes)&lt;/tt&gt;,
</span><span class="inferred0"><a name="line950"></a> 950       # &lt;tt&gt;update_attributes(attributes)&lt;/tt&gt;, or
</span><span class="inferred1"><a name="line951"></a> 951       # &lt;tt&gt;attributes=(attributes)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line952"></a> 952       #
</span><span class="inferred1"><a name="line953"></a> 953       # Mass-assignment to these attributes will simply be ignored, to assign
</span><span class="inferred0"><a name="line954"></a> 954       # to them you can use direct writer methods. This is meant to protect
</span><span class="inferred1"><a name="line955"></a> 955       # sensitive attributes from being overwritten by malicious users
</span><span class="inferred0"><a name="line956"></a> 956       # tampering with URLs or forms.
</span><span class="inferred1"><a name="line957"></a> 957       #
</span><span class="inferred0"><a name="line958"></a> 958       #   class Customer &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line959"></a> 959       #     attr_protected :credit_rating
</span><span class="inferred0"><a name="line960"></a> 960       #   end
</span><span class="inferred1"><a name="line961"></a> 961       #
</span><span class="inferred0"><a name="line962"></a> 962       #   customer = Customer.new(&quot;name&quot; =&gt; David, &quot;credit_rating&quot; =&gt; &quot;Excellent&quot;)
</span><span class="inferred1"><a name="line963"></a> 963       #   customer.credit_rating # =&gt; nil
</span><span class="inferred0"><a name="line964"></a> 964       #   customer.attributes = { &quot;description&quot; =&gt; &quot;Jolly fellow&quot;, &quot;credit_rating&quot; =&gt; &quot;Superb&quot; }
</span><span class="inferred1"><a name="line965"></a> 965       #   customer.credit_rating # =&gt; nil
</span><span class="inferred0"><a name="line966"></a> 966       #
</span><span class="inferred1"><a name="line967"></a> 967       #   customer.credit_rating = &quot;Average&quot;
</span><span class="inferred0"><a name="line968"></a> 968       #   customer.credit_rating # =&gt; &quot;Average&quot;
</span><span class="inferred1"><a name="line969"></a> 969       #
</span><span class="inferred0"><a name="line970"></a> 970       # To start from an all-closed default and enable attributes as needed,
</span><span class="inferred1"><a name="line971"></a> 971       # have a look at +attr_accessible+.
</span><span class="marked0"><a name="line972"></a> 972       def attr_protected(*attributes)
</span><span class="uncovered1"><a name="line973"></a> 973         write_inheritable_attribute(:attr_protected, Set.new(attributes.map(&amp;:to_s)) + (protected_attributes || []))
</span><span class="uncovered0"><a name="line974"></a> 974       end
</span><span class="inferred1"><a name="line975"></a> 975 
</span><span class="inferred0"><a name="line976"></a> 976       # Returns an array of all the attributes that have been protected from mass-assignment.
</span><span class="marked1"><a name="line977"></a> 977       def protected_attributes # :nodoc:
</span><span class="marked0"><a name="line978"></a> 978         read_inheritable_attribute(:attr_protected)
</span><span class="marked1"><a name="line979"></a> 979       end
</span><span class="inferred0"><a name="line980"></a> 980 
</span><span class="inferred1"><a name="line981"></a> 981       # Specifies a white list of model attributes that can be set via
</span><span class="inferred0"><a name="line982"></a> 982       # mass-assignment, such as &lt;tt&gt;new(attributes)&lt;/tt&gt;,
</span><span class="inferred1"><a name="line983"></a> 983       # &lt;tt&gt;update_attributes(attributes)&lt;/tt&gt;, or
</span><span class="inferred0"><a name="line984"></a> 984       # &lt;tt&gt;attributes=(attributes)&lt;/tt&gt;
</span><span class="inferred1"><a name="line985"></a> 985       #
</span><span class="inferred0"><a name="line986"></a> 986       # This is the opposite of the +attr_protected+ macro: Mass-assignment
</span><span class="inferred1"><a name="line987"></a> 987       # will only set attributes in this list, to assign to the rest of
</span><span class="inferred0"><a name="line988"></a> 988       # attributes you can use direct writer methods. This is meant to protect
</span><span class="inferred1"><a name="line989"></a> 989       # sensitive attributes from being overwritten by malicious users
</span><span class="inferred0"><a name="line990"></a> 990       # tampering with URLs or forms. If you'd rather start from an all-open
</span><span class="inferred1"><a name="line991"></a> 991       # default and restrict attributes as needed, have a look at
</span><span class="inferred0"><a name="line992"></a> 992       # +attr_protected+.
</span><span class="inferred1"><a name="line993"></a> 993       #
</span><span class="inferred0"><a name="line994"></a> 994       #   class Customer &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line995"></a> 995       #     attr_accessible :name, :nickname
</span><span class="inferred0"><a name="line996"></a> 996       #   end
</span><span class="inferred1"><a name="line997"></a> 997       #
</span><span class="inferred0"><a name="line998"></a> 998       #   customer = Customer.new(:name =&gt; &quot;David&quot;, :nickname =&gt; &quot;Dave&quot;, :credit_rating =&gt; &quot;Excellent&quot;)
</span><span class="inferred1"><a name="line999"></a> 999       #   customer.credit_rating # =&gt; nil
</span><span class="inferred0"><a name="line1000"></a>1000       #   customer.attributes = { :name =&gt; &quot;Jolly fellow&quot;, :credit_rating =&gt; &quot;Superb&quot; }
</span><span class="inferred1"><a name="line1001"></a>1001       #   customer.credit_rating # =&gt; nil
</span><span class="inferred0"><a name="line1002"></a>1002       #
</span><span class="inferred1"><a name="line1003"></a>1003       #   customer.credit_rating = &quot;Average&quot;
</span><span class="inferred0"><a name="line1004"></a>1004       #   customer.credit_rating # =&gt; &quot;Average&quot;
</span><span class="marked1"><a name="line1005"></a>1005       def attr_accessible(*attributes)
</span><span class="uncovered0"><a name="line1006"></a>1006         write_inheritable_attribute(:attr_accessible, Set.new(attributes.map(&amp;:to_s)) + (accessible_attributes || []))
</span><span class="uncovered1"><a name="line1007"></a>1007       end
</span><span class="inferred0"><a name="line1008"></a>1008 
</span><span class="inferred1"><a name="line1009"></a>1009       # Returns an array of all the attributes that have been made accessible to mass-assignment.
</span><span class="marked0"><a name="line1010"></a>1010       def accessible_attributes # :nodoc:
</span><span class="marked1"><a name="line1011"></a>1011         read_inheritable_attribute(:attr_accessible)
</span><span class="marked0"><a name="line1012"></a>1012       end
</span><span class="inferred1"><a name="line1013"></a>1013 
</span><span class="inferred0"><a name="line1014"></a>1014        # Attributes listed as readonly can be set for a new record, but will be ignored in database updates afterwards.
</span><span class="marked1"><a name="line1015"></a>1015        def attr_readonly(*attributes)
</span><span class="uncovered0"><a name="line1016"></a>1016          write_inheritable_attribute(:attr_readonly, Set.new(attributes.map(&amp;:to_s)) + (readonly_attributes || []))
</span><span class="uncovered1"><a name="line1017"></a>1017        end
</span><span class="inferred0"><a name="line1018"></a>1018 
</span><span class="inferred1"><a name="line1019"></a>1019        # Returns an array of all the attributes that have been specified as readonly.
</span><span class="marked0"><a name="line1020"></a>1020        def readonly_attributes
</span><span class="marked1"><a name="line1021"></a>1021          read_inheritable_attribute(:attr_readonly)
</span><span class="marked0"><a name="line1022"></a>1022        end
</span><span class="inferred1"><a name="line1023"></a>1023 
</span><span class="inferred0"><a name="line1024"></a>1024       # If you have an attribute that needs to be saved to the database as an object, and retrieved as the same object,
</span><span class="inferred1"><a name="line1025"></a>1025       # then specify the name of that attribute using this method and it will be handled automatically.
</span><span class="inferred0"><a name="line1026"></a>1026       # The serialization is done through YAML. If +class_name+ is specified, the serialized object must be of that
</span><span class="inferred1"><a name="line1027"></a>1027       # class on retrieval or SerializationTypeMismatch will be raised.
</span><span class="inferred0"><a name="line1028"></a>1028       #
</span><span class="inferred1"><a name="line1029"></a>1029       # ==== Parameters
</span><span class="inferred0"><a name="line1030"></a>1030       #
</span><span class="inferred1"><a name="line1031"></a>1031       # * +attr_name+ - The field name that should be serialized.
</span><span class="inferred0"><a name="line1032"></a>1032       # * +class_name+ - Optional, class name that the object type should be equal to.
</span><span class="inferred1"><a name="line1033"></a>1033       #
</span><span class="inferred0"><a name="line1034"></a>1034       # ==== Example
</span><span class="inferred1"><a name="line1035"></a>1035       #   # Serialize a preferences attribute
</span><span class="inferred0"><a name="line1036"></a>1036       #   class User
</span><span class="inferred1"><a name="line1037"></a>1037       #     serialize :preferences
</span><span class="inferred0"><a name="line1038"></a>1038       #   end
</span><span class="marked1"><a name="line1039"></a>1039       def serialize(attr_name, class_name = Object)
</span><span class="uncovered0"><a name="line1040"></a>1040         serialized_attributes[attr_name.to_s] = class_name
</span><span class="uncovered1"><a name="line1041"></a>1041       end
</span><span class="inferred0"><a name="line1042"></a>1042 
</span><span class="inferred1"><a name="line1043"></a>1043       # Returns a hash of all the attributes that have been specified for serialization as keys and their class restriction as values.
</span><span class="marked0"><a name="line1044"></a>1044       def serialized_attributes
</span><span class="marked1"><a name="line1045"></a>1045         read_inheritable_attribute(:attr_serialized) or write_inheritable_attribute(:attr_serialized, {})
</span><span class="marked0"><a name="line1046"></a>1046       end
</span><span class="inferred1"><a name="line1047"></a>1047 
</span><span class="inferred0"><a name="line1048"></a>1048 
</span><span class="inferred1"><a name="line1049"></a>1049       # Guesses the table name (in forced lower-case) based on the name of the class in the inheritance hierarchy descending
</span><span class="inferred0"><a name="line1050"></a>1050       # directly from ActiveRecord::Base. So if the hierarchy looks like: Reply &lt; Message &lt; ActiveRecord::Base, then Message is used
</span><span class="inferred1"><a name="line1051"></a>1051       # to guess the table name even when called on Reply. The rules used to do the guess are handled by the Inflector class
</span><span class="inferred0"><a name="line1052"></a>1052       # in Active Support, which knows almost all common English inflections. You can add new inflections in config/initializers/inflections.rb.
</span><span class="inferred1"><a name="line1053"></a>1053       #
</span><span class="inferred0"><a name="line1054"></a>1054       # Nested classes are given table names prefixed by the singular form of
</span><span class="inferred1"><a name="line1055"></a>1055       # the parent's table name. Enclosing modules are not considered.
</span><span class="inferred0"><a name="line1056"></a>1056       #
</span><span class="inferred1"><a name="line1057"></a>1057       # ==== Examples
</span><span class="inferred0"><a name="line1058"></a>1058       #
</span><span class="inferred1"><a name="line1059"></a>1059       #   class Invoice &lt; ActiveRecord::Base; end;
</span><span class="inferred0"><a name="line1060"></a>1060       #   file                  class               table_name
</span><span class="inferred1"><a name="line1061"></a>1061       #   invoice.rb            Invoice             invoices
</span><span class="inferred0"><a name="line1062"></a>1062       #
</span><span class="inferred1"><a name="line1063"></a>1063       #   class Invoice &lt; ActiveRecord::Base; class Lineitem &lt; ActiveRecord::Base; end; end;
</span><span class="inferred0"><a name="line1064"></a>1064       #   file                  class               table_name
</span><span class="inferred1"><a name="line1065"></a>1065       #   invoice.rb            Invoice::Lineitem   invoice_lineitems
</span><span class="inferred0"><a name="line1066"></a>1066       #
</span><span class="inferred1"><a name="line1067"></a>1067       #   module Invoice; class Lineitem &lt; ActiveRecord::Base; end; end;
</span><span class="inferred0"><a name="line1068"></a>1068       #   file                  class               table_name
</span><span class="inferred1"><a name="line1069"></a>1069       #   invoice/lineitem.rb   Invoice::Lineitem   lineitems
</span><span class="inferred0"><a name="line1070"></a>1070       #
</span><span class="inferred1"><a name="line1071"></a>1071       # Additionally, the class-level +table_name_prefix+ is prepended and the
</span><span class="inferred0"><a name="line1072"></a>1072       # +table_name_suffix+ is appended.  So if you have &quot;myapp_&quot; as a prefix,
</span><span class="inferred1"><a name="line1073"></a>1073       # the table name guess for an Invoice class becomes &quot;myapp_invoices&quot;.
</span><span class="inferred0"><a name="line1074"></a>1074       # Invoice::Lineitem becomes &quot;myapp_invoice_lineitems&quot;.
</span><span class="inferred1"><a name="line1075"></a>1075       #
</span><span class="inferred0"><a name="line1076"></a>1076       # You can also overwrite this class method to allow for unguessable
</span><span class="inferred1"><a name="line1077"></a>1077       # links, such as a Mouse class with a link to a &quot;mice&quot; table. Example:
</span><span class="inferred0"><a name="line1078"></a>1078       #
</span><span class="inferred1"><a name="line1079"></a>1079       #   class Mouse &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1080"></a>1080       #     set_table_name &quot;mice&quot;
</span><span class="inferred1"><a name="line1081"></a>1081       #   end
</span><span class="marked0"><a name="line1082"></a>1082       def table_name
</span><span class="marked1"><a name="line1083"></a>1083         reset_table_name
</span><span class="marked0"><a name="line1084"></a>1084       end
</span><span class="inferred1"><a name="line1085"></a>1085 
</span><span class="marked0"><a name="line1086"></a>1086       def reset_table_name #:nodoc:
</span><span class="marked1"><a name="line1087"></a>1087         base = base_class
</span><span class="inferred0"><a name="line1088"></a>1088 
</span><span class="marked1"><a name="line1089"></a>1089         name =
</span><span class="inferred0"><a name="line1090"></a>1090           # STI subclasses always use their superclass' table.
</span><span class="marked1"><a name="line1091"></a>1091           unless self == base
</span><span class="uncovered0"><a name="line1092"></a>1092             base.table_name
</span><span class="inferred1"><a name="line1093"></a>1093           else
</span><span class="inferred0"><a name="line1094"></a>1094             # Nested classes are prefixed with singular parent table name.
</span><span class="marked1"><a name="line1095"></a>1095             if parent &lt; ActiveRecord::Base &amp;&amp; !parent.abstract_class?
</span><span class="uncovered0"><a name="line1096"></a>1096               contained = parent.table_name
</span><span class="uncovered1"><a name="line1097"></a>1097               contained = contained.singularize if parent.pluralize_table_names
</span><span class="uncovered0"><a name="line1098"></a>1098               contained &lt;&lt; '_'
</span><span class="uncovered1"><a name="line1099"></a>1099             end
</span><span class="marked0"><a name="line1100"></a>1100             name = &quot;#{table_name_prefix}#{contained}#{undecorated_table_name(base.name)}#{table_name_suffix}&quot;
</span><span class="inferred1"><a name="line1101"></a>1101           end
</span><span class="inferred0"><a name="line1102"></a>1102 
</span><span class="marked1"><a name="line1103"></a>1103         set_table_name(name)
</span><span class="marked0"><a name="line1104"></a>1104         name
</span><span class="inferred1"><a name="line1105"></a>1105       end
</span><span class="inferred0"><a name="line1106"></a>1106 
</span><span class="inferred1"><a name="line1107"></a>1107       # Defines the primary key field -- can be overridden in subclasses. Overwriting will negate any effect of the
</span><span class="inferred0"><a name="line1108"></a>1108       # primary_key_prefix_type setting, though.
</span><span class="marked1"><a name="line1109"></a>1109       def primary_key
</span><span class="marked0"><a name="line1110"></a>1110         reset_primary_key
</span><span class="marked1"><a name="line1111"></a>1111       end
</span><span class="inferred0"><a name="line1112"></a>1112 
</span><span class="marked1"><a name="line1113"></a>1113       def reset_primary_key #:nodoc:
</span><span class="marked0"><a name="line1114"></a>1114         key = get_primary_key(base_class.name)
</span><span class="marked1"><a name="line1115"></a>1115         set_primary_key(key)
</span><span class="marked0"><a name="line1116"></a>1116         key
</span><span class="inferred1"><a name="line1117"></a>1117       end
</span><span class="inferred0"><a name="line1118"></a>1118 
</span><span class="marked1"><a name="line1119"></a>1119       def get_primary_key(base_name) #:nodoc:
</span><span class="marked0"><a name="line1120"></a>1120         key = 'id'
</span><span class="marked1"><a name="line1121"></a>1121         case primary_key_prefix_type
</span><span class="marked0"><a name="line1122"></a>1122           when :table_name
</span><span class="uncovered1"><a name="line1123"></a>1123             key = base_name.to_s.foreign_key(false)
</span><span class="marked0"><a name="line1124"></a>1124           when :table_name_with_underscore
</span><span class="uncovered1"><a name="line1125"></a>1125             key = base_name.to_s.foreign_key
</span><span class="uncovered0"><a name="line1126"></a>1126         end
</span><span class="marked1"><a name="line1127"></a>1127         key
</span><span class="inferred0"><a name="line1128"></a>1128       end
</span><span class="inferred1"><a name="line1129"></a>1129 
</span><span class="inferred0"><a name="line1130"></a>1130       # Defines the column name for use with single table inheritance
</span><span class="inferred1"><a name="line1131"></a>1131       # -- can be set in subclasses like so: self.inheritance_column = &quot;type_id&quot;
</span><span class="marked0"><a name="line1132"></a>1132       def inheritance_column
</span><span class="marked1"><a name="line1133"></a>1133         @inheritance_column ||= &quot;type&quot;.freeze
</span><span class="marked0"><a name="line1134"></a>1134       end
</span><span class="inferred1"><a name="line1135"></a>1135 
</span><span class="inferred0"><a name="line1136"></a>1136       # Lazy-set the sequence name to the connection's default.  This method
</span><span class="inferred1"><a name="line1137"></a>1137       # is only ever called once since set_sequence_name overrides it.
</span><span class="marked0"><a name="line1138"></a>1138       def sequence_name #:nodoc:
</span><span class="uncovered1"><a name="line1139"></a>1139         reset_sequence_name
</span><span class="uncovered0"><a name="line1140"></a>1140       end
</span><span class="inferred1"><a name="line1141"></a>1141 
</span><span class="marked0"><a name="line1142"></a>1142       def reset_sequence_name #:nodoc:
</span><span class="uncovered1"><a name="line1143"></a>1143         default = connection.default_sequence_name(table_name, primary_key)
</span><span class="uncovered0"><a name="line1144"></a>1144         set_sequence_name(default)
</span><span class="uncovered1"><a name="line1145"></a>1145         default
</span><span class="uncovered0"><a name="line1146"></a>1146       end
</span><span class="inferred1"><a name="line1147"></a>1147 
</span><span class="inferred0"><a name="line1148"></a>1148       # Sets the table name to use to the given value, or (if the value
</span><span class="inferred1"><a name="line1149"></a>1149       # is nil or false) to the value returned by the given block.
</span><span class="inferred0"><a name="line1150"></a>1150       #
</span><span class="inferred1"><a name="line1151"></a>1151       #   class Project &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1152"></a>1152       #     set_table_name &quot;project&quot;
</span><span class="inferred1"><a name="line1153"></a>1153       #   end
</span><span class="marked0"><a name="line1154"></a>1154       def set_table_name(value = nil, &amp;block)
</span><span class="marked1"><a name="line1155"></a>1155         define_attr_method :table_name, value, &amp;block
</span><span class="inferred0"><a name="line1156"></a>1156       end
</span><span class="marked1"><a name="line1157"></a>1157       alias :table_name= :set_table_name
</span><span class="inferred0"><a name="line1158"></a>1158 
</span><span class="inferred1"><a name="line1159"></a>1159       # Sets the name of the primary key column to use to the given value,
</span><span class="inferred0"><a name="line1160"></a>1160       # or (if the value is nil or false) to the value returned by the given
</span><span class="inferred1"><a name="line1161"></a>1161       # block.
</span><span class="inferred0"><a name="line1162"></a>1162       #
</span><span class="inferred1"><a name="line1163"></a>1163       #   class Project &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1164"></a>1164       #     set_primary_key &quot;sysid&quot;
</span><span class="inferred1"><a name="line1165"></a>1165       #   end
</span><span class="marked0"><a name="line1166"></a>1166       def set_primary_key(value = nil, &amp;block)
</span><span class="marked1"><a name="line1167"></a>1167         define_attr_method :primary_key, value, &amp;block
</span><span class="inferred0"><a name="line1168"></a>1168       end
</span><span class="marked1"><a name="line1169"></a>1169       alias :primary_key= :set_primary_key
</span><span class="inferred0"><a name="line1170"></a>1170 
</span><span class="inferred1"><a name="line1171"></a>1171       # Sets the name of the inheritance column to use to the given value,
</span><span class="inferred0"><a name="line1172"></a>1172       # or (if the value # is nil or false) to the value returned by the
</span><span class="inferred1"><a name="line1173"></a>1173       # given block.
</span><span class="inferred0"><a name="line1174"></a>1174       #
</span><span class="inferred1"><a name="line1175"></a>1175       #   class Project &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1176"></a>1176       #     set_inheritance_column do
</span><span class="inferred1"><a name="line1177"></a>1177       #       original_inheritance_column + &quot;_id&quot;
</span><span class="inferred0"><a name="line1178"></a>1178       #     end
</span><span class="inferred1"><a name="line1179"></a>1179       #   end
</span><span class="marked0"><a name="line1180"></a>1180       def set_inheritance_column(value = nil, &amp;block)
</span><span class="uncovered1"><a name="line1181"></a>1181         define_attr_method :inheritance_column, value, &amp;block
</span><span class="uncovered0"><a name="line1182"></a>1182       end
</span><span class="marked1"><a name="line1183"></a>1183       alias :inheritance_column= :set_inheritance_column
</span><span class="inferred0"><a name="line1184"></a>1184 
</span><span class="inferred1"><a name="line1185"></a>1185       # Sets the name of the sequence to use when generating ids to the given
</span><span class="inferred0"><a name="line1186"></a>1186       # value, or (if the value is nil or false) to the value returned by the
</span><span class="inferred1"><a name="line1187"></a>1187       # given block. This is required for Oracle and is useful for any
</span><span class="inferred0"><a name="line1188"></a>1188       # database which relies on sequences for primary key generation.
</span><span class="inferred1"><a name="line1189"></a>1189       #
</span><span class="inferred0"><a name="line1190"></a>1190       # If a sequence name is not explicitly set when using Oracle or Firebird,
</span><span class="inferred1"><a name="line1191"></a>1191       # it will default to the commonly used pattern of: #{table_name}_seq
</span><span class="inferred0"><a name="line1192"></a>1192       #
</span><span class="inferred1"><a name="line1193"></a>1193       # If a sequence name is not explicitly set when using PostgreSQL, it
</span><span class="inferred0"><a name="line1194"></a>1194       # will discover the sequence corresponding to your primary key for you.
</span><span class="inferred1"><a name="line1195"></a>1195       #
</span><span class="inferred0"><a name="line1196"></a>1196       #   class Project &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line1197"></a>1197       #     set_sequence_name &quot;projectseq&quot;   # default would have been &quot;project_seq&quot;
</span><span class="inferred0"><a name="line1198"></a>1198       #   end
</span><span class="marked1"><a name="line1199"></a>1199       def set_sequence_name(value = nil, &amp;block)
</span><span class="uncovered0"><a name="line1200"></a>1200         define_attr_method :sequence_name, value, &amp;block
</span><span class="uncovered1"><a name="line1201"></a>1201       end
</span><span class="marked0"><a name="line1202"></a>1202       alias :sequence_name= :set_sequence_name
</span><span class="inferred1"><a name="line1203"></a>1203 
</span><span class="inferred0"><a name="line1204"></a>1204       # Turns the +table_name+ back into a class name following the reverse rules of +table_name+.
</span><span class="marked1"><a name="line1205"></a>1205       def class_name(table_name = table_name) # :nodoc:
</span><span class="uncovered0"><a name="line1206"></a>1206         # remove any prefix and/or suffix from the table name
</span><span class="uncovered1"><a name="line1207"></a>1207         class_name = table_name[table_name_prefix.length..-(table_name_suffix.length + 1)].camelize
</span><span class="uncovered0"><a name="line1208"></a>1208         class_name = class_name.singularize if pluralize_table_names
</span><span class="uncovered1"><a name="line1209"></a>1209         class_name
</span><span class="uncovered0"><a name="line1210"></a>1210       end
</span><span class="inferred1"><a name="line1211"></a>1211 
</span><span class="inferred0"><a name="line1212"></a>1212       # Indicates whether the table associated with this class exists
</span><span class="marked1"><a name="line1213"></a>1213       def table_exists?
</span><span class="uncovered0"><a name="line1214"></a>1214         connection.table_exists?(table_name)
</span><span class="uncovered1"><a name="line1215"></a>1215       end
</span><span class="inferred0"><a name="line1216"></a>1216 
</span><span class="inferred1"><a name="line1217"></a>1217       # Returns an array of column objects for the table associated with this class.
</span><span class="marked0"><a name="line1218"></a>1218       def columns
</span><span class="marked1"><a name="line1219"></a>1219         unless defined?(@columns) &amp;&amp; @columns
</span><span class="marked0"><a name="line1220"></a>1220           @columns = connection.columns(table_name, &quot;#{name} Columns&quot;)
</span><span class="marked1"><a name="line1221"></a>1221           @columns.each { |column| column.primary = column.name == primary_key }
</span><span class="inferred0"><a name="line1222"></a>1222         end
</span><span class="marked1"><a name="line1223"></a>1223         @columns
</span><span class="inferred0"><a name="line1224"></a>1224       end
</span><span class="inferred1"><a name="line1225"></a>1225 
</span><span class="inferred0"><a name="line1226"></a>1226       # Returns a hash of column objects for the table associated with this class.
</span><span class="marked1"><a name="line1227"></a>1227       def columns_hash
</span><span class="marked0"><a name="line1228"></a>1228         @columns_hash ||= columns.inject({}) { |hash, column| hash[column.name] = column; hash }
</span><span class="marked1"><a name="line1229"></a>1229       end
</span><span class="inferred0"><a name="line1230"></a>1230 
</span><span class="inferred1"><a name="line1231"></a>1231       # Returns an array of column names as strings.
</span><span class="marked0"><a name="line1232"></a>1232       def column_names
</span><span class="uncovered1"><a name="line1233"></a>1233         @column_names ||= columns.map { |column| column.name }
</span><span class="uncovered0"><a name="line1234"></a>1234       end
</span><span class="inferred1"><a name="line1235"></a>1235 
</span><span class="inferred0"><a name="line1236"></a>1236       # Returns an array of column objects where the primary id, all columns ending in &quot;_id&quot; or &quot;_count&quot;,
</span><span class="inferred1"><a name="line1237"></a>1237       # and columns used for single table inheritance have been removed.
</span><span class="marked0"><a name="line1238"></a>1238       def content_columns
</span><span class="uncovered1"><a name="line1239"></a>1239         @content_columns ||= columns.reject { |c| c.primary || c.name =~ /(_id|_count)$/ || c.name == inheritance_column }
</span><span class="uncovered0"><a name="line1240"></a>1240       end
</span><span class="inferred1"><a name="line1241"></a>1241 
</span><span class="inferred0"><a name="line1242"></a>1242       # Returns a hash of all the methods added to query each of the columns in the table with the name of the method as the key
</span><span class="inferred1"><a name="line1243"></a>1243       # and true as the value. This makes it possible to do O(1) lookups in respond_to? to check if a given method for attribute
</span><span class="inferred0"><a name="line1244"></a>1244       # is available.
</span><span class="marked1"><a name="line1245"></a>1245       def column_methods_hash #:nodoc:
</span><span class="uncovered0"><a name="line1246"></a>1246         @dynamic_methods_hash ||= column_names.inject(Hash.new(false)) do |methods, attr|
</span><span class="uncovered1"><a name="line1247"></a>1247           attr_name = attr.to_s
</span><span class="uncovered0"><a name="line1248"></a>1248           methods[attr.to_sym]       = attr_name
</span><span class="uncovered1"><a name="line1249"></a>1249           methods[&quot;#{attr}=&quot;.to_sym] = attr_name
</span><span class="uncovered0"><a name="line1250"></a>1250           methods[&quot;#{attr}?&quot;.to_sym] = attr_name
</span><span class="uncovered1"><a name="line1251"></a>1251           methods[&quot;#{attr}_before_type_cast&quot;.to_sym] = attr_name
</span><span class="uncovered0"><a name="line1252"></a>1252           methods
</span><span class="uncovered1"><a name="line1253"></a>1253         end
</span><span class="uncovered0"><a name="line1254"></a>1254       end
</span><span class="inferred1"><a name="line1255"></a>1255 
</span><span class="inferred0"><a name="line1256"></a>1256       # Resets all the cached information about columns, which will cause them
</span><span class="inferred1"><a name="line1257"></a>1257       # to be reloaded on the next request.
</span><span class="inferred0"><a name="line1258"></a>1258       #
</span><span class="inferred1"><a name="line1259"></a>1259       # The most common usage pattern for this method is probably in a migration,
</span><span class="inferred0"><a name="line1260"></a>1260       # when just after creating a table you want to populate it with some default
</span><span class="inferred1"><a name="line1261"></a>1261       # values, eg:
</span><span class="inferred0"><a name="line1262"></a>1262       #
</span><span class="inferred1"><a name="line1263"></a>1263       #  class CreateJobLevels &lt; ActiveRecord::Migration
</span><span class="inferred0"><a name="line1264"></a>1264       #    def self.up
</span><span class="inferred1"><a name="line1265"></a>1265       #      create_table :job_levels do |t|
</span><span class="inferred0"><a name="line1266"></a>1266       #        t.integer :id
</span><span class="inferred1"><a name="line1267"></a>1267       #        t.string :name
</span><span class="inferred0"><a name="line1268"></a>1268       #
</span><span class="inferred1"><a name="line1269"></a>1269       #        t.timestamps
</span><span class="inferred0"><a name="line1270"></a>1270       #      end
</span><span class="inferred1"><a name="line1271"></a>1271       #
</span><span class="inferred0"><a name="line1272"></a>1272       #      JobLevel.reset_column_information
</span><span class="inferred1"><a name="line1273"></a>1273       #      %w{assistant executive manager director}.each do |type|
</span><span class="inferred0"><a name="line1274"></a>1274       #        JobLevel.create(:name =&gt; type)
</span><span class="inferred1"><a name="line1275"></a>1275       #      end
</span><span class="inferred0"><a name="line1276"></a>1276       #    end
</span><span class="inferred1"><a name="line1277"></a>1277       #
</span><span class="inferred0"><a name="line1278"></a>1278       #    def self.down
</span><span class="inferred1"><a name="line1279"></a>1279       #      drop_table :job_levels
</span><span class="inferred0"><a name="line1280"></a>1280       #    end
</span><span class="inferred1"><a name="line1281"></a>1281       #  end
</span><span class="marked0"><a name="line1282"></a>1282       def reset_column_information
</span><span class="uncovered1"><a name="line1283"></a>1283         generated_methods.each { |name| undef_method(name) }
</span><span class="uncovered0"><a name="line1284"></a>1284         @column_names = @columns = @columns_hash = @content_columns = @dynamic_methods_hash = @generated_methods = @inheritance_column = nil
</span><span class="uncovered1"><a name="line1285"></a>1285       end
</span><span class="inferred0"><a name="line1286"></a>1286 
</span><span class="marked1"><a name="line1287"></a>1287       def reset_column_information_and_inheritable_attributes_for_all_subclasses#:nodoc:
</span><span class="uncovered0"><a name="line1288"></a>1288         subclasses.each { |klass| klass.reset_inheritable_attributes; klass.reset_column_information }
</span><span class="uncovered1"><a name="line1289"></a>1289       end
</span><span class="inferred0"><a name="line1290"></a>1290 
</span><span class="marked1"><a name="line1291"></a>1291       def self_and_descendents_from_active_record#nodoc:
</span><span class="marked0"><a name="line1292"></a>1292         klass = self
</span><span class="marked1"><a name="line1293"></a>1293         classes = [klass]
</span><span class="marked0"><a name="line1294"></a>1294         while klass != klass.base_class  
</span><span class="uncovered1"><a name="line1295"></a>1295           classes &lt;&lt; klass = klass.superclass
</span><span class="uncovered0"><a name="line1296"></a>1296         end
</span><span class="marked1"><a name="line1297"></a>1297         classes
</span><span class="uncovered0"><a name="line1298"></a>1298       rescue
</span><span class="uncovered1"><a name="line1299"></a>1299         # OPTIMIZE this rescue is to fix this test: ./test/cases/reflection_test.rb:56:in `test_human_name_for_column'
</span><span class="uncovered0"><a name="line1300"></a>1300         # Appearantly the method base_class causes some trouble.
</span><span class="uncovered1"><a name="line1301"></a>1301         # It now works for sure.
</span><span class="uncovered0"><a name="line1302"></a>1302         [self]
</span><span class="marked1"><a name="line1303"></a>1303       end
</span><span class="inferred0"><a name="line1304"></a>1304 
</span><span class="inferred1"><a name="line1305"></a>1305       # Transforms attribute key names into a more humane format, such as &quot;First name&quot; instead of &quot;first_name&quot;. Example:
</span><span class="inferred0"><a name="line1306"></a>1306       #   Person.human_attribute_name(&quot;first_name&quot;) # =&gt; &quot;First name&quot;
</span><span class="inferred1"><a name="line1307"></a>1307       # This used to be depricated in favor of humanize, but is now preferred, because it automatically uses the I18n
</span><span class="inferred0"><a name="line1308"></a>1308       # module now.
</span><span class="inferred1"><a name="line1309"></a>1309       # Specify +options+ with additional translating options.
</span><span class="marked0"><a name="line1310"></a>1310       def human_attribute_name(attribute_key_name, options = {})
</span><span class="marked1"><a name="line1311"></a>1311         defaults = self_and_descendents_from_active_record.map do |klass|
</span><span class="marked0"><a name="line1312"></a>1312           :&quot;#{klass.name.underscore}.#{attribute_key_name}&quot;
</span><span class="inferred1"><a name="line1313"></a>1313         end
</span><span class="marked0"><a name="line1314"></a>1314         defaults &lt;&lt; options[:default] if options[:default]
</span><span class="marked1"><a name="line1315"></a>1315         defaults.flatten!
</span><span class="marked0"><a name="line1316"></a>1316         defaults &lt;&lt; attribute_key_name.humanize
</span><span class="marked1"><a name="line1317"></a>1317         options[:count] ||= 1
</span><span class="marked0"><a name="line1318"></a>1318         I18n.translate(defaults.shift, options.merge(:default =&gt; defaults, :scope =&gt; [:activerecord, :attributes]))
</span><span class="inferred1"><a name="line1319"></a>1319       end
</span><span class="inferred0"><a name="line1320"></a>1320 
</span><span class="inferred1"><a name="line1321"></a>1321       # Transform the modelname into a more humane format, using I18n.
</span><span class="inferred0"><a name="line1322"></a>1322       # Defaults to the basic humanize method.
</span><span class="inferred1"><a name="line1323"></a>1323       # Default scope of the translation is activerecord.models
</span><span class="inferred0"><a name="line1324"></a>1324       # Specify +options+ with additional translating options.
</span><span class="marked1"><a name="line1325"></a>1325       def human_name(options = {})
</span><span class="marked0"><a name="line1326"></a>1326         defaults = self_and_descendents_from_active_record.map do |klass|
</span><span class="marked1"><a name="line1327"></a>1327           :&quot;#{klass.name.underscore}&quot;
</span><span class="inferred0"><a name="line1328"></a>1328         end 
</span><span class="marked1"><a name="line1329"></a>1329         defaults &lt;&lt; self.name.humanize
</span><span class="marked0"><a name="line1330"></a>1330         I18n.translate(defaults.shift, {:scope =&gt; [:activerecord, :models], :count =&gt; 1, :default =&gt; defaults}.merge(options))
</span><span class="inferred1"><a name="line1331"></a>1331       end
</span><span class="inferred0"><a name="line1332"></a>1332 
</span><span class="inferred1"><a name="line1333"></a>1333       # True if this isn't a concrete subclass needing a STI type condition.
</span><span class="marked0"><a name="line1334"></a>1334       def descends_from_active_record?
</span><span class="marked1"><a name="line1335"></a>1335         if superclass.abstract_class?
</span><span class="uncovered0"><a name="line1336"></a>1336           superclass.descends_from_active_record?
</span><span class="inferred1"><a name="line1337"></a>1337         else
</span><span class="marked0"><a name="line1338"></a>1338           superclass == Base || !columns_hash.include?(inheritance_column)
</span><span class="inferred1"><a name="line1339"></a>1339         end
</span><span class="marked0"><a name="line1340"></a>1340       end
</span><span class="inferred1"><a name="line1341"></a>1341 
</span><span class="marked0"><a name="line1342"></a>1342       def finder_needs_type_condition? #:nodoc:
</span><span class="inferred1"><a name="line1343"></a>1343         # This is like this because benchmarking justifies the strange :false stuff
</span><span class="marked0"><a name="line1344"></a>1344         :true == (@finder_needs_type_condition ||= descends_from_active_record? ? :false : :true)
</span><span class="marked1"><a name="line1345"></a>1345       end
</span><span class="inferred0"><a name="line1346"></a>1346 
</span><span class="inferred1"><a name="line1347"></a>1347       # Returns a string like 'Post id:integer, title:string, body:text'
</span><span class="marked0"><a name="line1348"></a>1348       def inspect
</span><span class="uncovered1"><a name="line1349"></a>1349         if self == Base
</span><span class="uncovered0"><a name="line1350"></a>1350           super
</span><span class="uncovered1"><a name="line1351"></a>1351         elsif abstract_class?
</span><span class="uncovered0"><a name="line1352"></a>1352           &quot;#{super}(abstract)&quot;
</span><span class="uncovered1"><a name="line1353"></a>1353         elsif table_exists?
</span><span class="uncovered0"><a name="line1354"></a>1354           attr_list = columns.map { |c| &quot;#{c.name}: #{c.type}&quot; } * ', '
</span><span class="uncovered1"><a name="line1355"></a>1355           &quot;#{super}(#{attr_list})&quot;
</span><span class="uncovered0"><a name="line1356"></a>1356         else
</span><span class="uncovered1"><a name="line1357"></a>1357           &quot;#{super}(Table doesn't exist)&quot;
</span><span class="uncovered0"><a name="line1358"></a>1358         end
</span><span class="uncovered1"><a name="line1359"></a>1359       end
</span><span class="inferred0"><a name="line1360"></a>1360 
</span><span class="inferred1"><a name="line1361"></a>1361 
</span><span class="marked0"><a name="line1362"></a>1362       def quote_value(value, column = nil) #:nodoc:
</span><span class="marked1"><a name="line1363"></a>1363         connection.quote(value,column)
</span><span class="marked0"><a name="line1364"></a>1364       end
</span><span class="inferred1"><a name="line1365"></a>1365 
</span><span class="inferred0"><a name="line1366"></a>1366       # Used to sanitize objects before they're used in an SQL SELECT statement. Delegates to &lt;tt&gt;connection.quote&lt;/tt&gt;.
</span><span class="marked1"><a name="line1367"></a>1367       def sanitize(object) #:nodoc:
</span><span class="uncovered0"><a name="line1368"></a>1368         connection.quote(object)
</span><span class="uncovered1"><a name="line1369"></a>1369       end
</span><span class="inferred0"><a name="line1370"></a>1370 
</span><span class="inferred1"><a name="line1371"></a>1371       # Log and benchmark multiple statements in a single block. Example:
</span><span class="inferred0"><a name="line1372"></a>1372       #
</span><span class="inferred1"><a name="line1373"></a>1373       #   Project.benchmark(&quot;Creating project&quot;) do
</span><span class="inferred0"><a name="line1374"></a>1374       #     project = Project.create(&quot;name&quot; =&gt; &quot;stuff&quot;)
</span><span class="inferred1"><a name="line1375"></a>1375       #     project.create_manager(&quot;name&quot; =&gt; &quot;David&quot;)
</span><span class="inferred0"><a name="line1376"></a>1376       #     project.milestones &lt;&lt; Milestone.find(:all)
</span><span class="inferred1"><a name="line1377"></a>1377       #   end
</span><span class="inferred0"><a name="line1378"></a>1378       #
</span><span class="inferred1"><a name="line1379"></a>1379       # The benchmark is only recorded if the current level of the logger is less than or equal to the &lt;tt&gt;log_level&lt;/tt&gt;,
</span><span class="inferred0"><a name="line1380"></a>1380       # which makes it easy to include benchmarking statements in production software that will remain inexpensive because
</span><span class="inferred1"><a name="line1381"></a>1381       # the benchmark will only be conducted if the log level is low enough.
</span><span class="inferred0"><a name="line1382"></a>1382       #
</span><span class="inferred1"><a name="line1383"></a>1383       # The logging of the multiple statements is turned off unless &lt;tt&gt;use_silence&lt;/tt&gt; is set to false.
</span><span class="marked0"><a name="line1384"></a>1384       def benchmark(title, log_level = Logger::DEBUG, use_silence = true)
</span><span class="uncovered1"><a name="line1385"></a>1385         if logger &amp;&amp; logger.level &lt;= log_level
</span><span class="uncovered0"><a name="line1386"></a>1386           result = nil
</span><span class="uncovered1"><a name="line1387"></a>1387           seconds = Benchmark.realtime { result = use_silence ? silence { yield } : yield }
</span><span class="uncovered0"><a name="line1388"></a>1388           logger.add(log_level, &quot;#{title} (#{'%.1f' % (seconds * 1000)}ms)&quot;)
</span><span class="uncovered1"><a name="line1389"></a>1389           result
</span><span class="uncovered0"><a name="line1390"></a>1390         else
</span><span class="uncovered1"><a name="line1391"></a>1391           yield
</span><span class="uncovered0"><a name="line1392"></a>1392         end
</span><span class="uncovered1"><a name="line1393"></a>1393       end
</span><span class="inferred0"><a name="line1394"></a>1394 
</span><span class="inferred1"><a name="line1395"></a>1395       # Silences the logger for the duration of the block.
</span><span class="marked0"><a name="line1396"></a>1396       def silence
</span><span class="marked1"><a name="line1397"></a>1397         old_logger_level, logger.level = logger.level, Logger::ERROR if logger
</span><span class="marked0"><a name="line1398"></a>1398         yield
</span><span class="inferred1"><a name="line1399"></a>1399       ensure
</span><span class="marked0"><a name="line1400"></a>1400         logger.level = old_logger_level if logger
</span><span class="marked1"><a name="line1401"></a>1401       end
</span><span class="inferred0"><a name="line1402"></a>1402 
</span><span class="inferred1"><a name="line1403"></a>1403       # Overwrite the default class equality method to provide support for association proxies.
</span><span class="marked0"><a name="line1404"></a>1404       def ===(object)
</span><span class="uncovered1"><a name="line1405"></a>1405         object.is_a?(self)
</span><span class="uncovered0"><a name="line1406"></a>1406       end
</span><span class="inferred1"><a name="line1407"></a>1407 
</span><span class="inferred0"><a name="line1408"></a>1408       # Returns the base AR subclass that this class descends from. If A
</span><span class="inferred1"><a name="line1409"></a>1409       # extends AR::Base, A.base_class will return A. If B descends from A
</span><span class="inferred0"><a name="line1410"></a>1410       # through some arbitrarily deep hierarchy, B.base_class will return A.
</span><span class="marked1"><a name="line1411"></a>1411       def base_class
</span><span class="marked0"><a name="line1412"></a>1412         class_of_active_record_descendant(self)
</span><span class="marked1"><a name="line1413"></a>1413       end
</span><span class="inferred0"><a name="line1414"></a>1414 
</span><span class="inferred1"><a name="line1415"></a>1415       # Set this to true if this is an abstract class (see &lt;tt&gt;abstract_class?&lt;/tt&gt;).
</span><span class="marked0"><a name="line1416"></a>1416       attr_accessor :abstract_class
</span><span class="inferred1"><a name="line1417"></a>1417 
</span><span class="inferred0"><a name="line1418"></a>1418       # Returns whether this class is a base AR class.  If A is a base class and
</span><span class="inferred1"><a name="line1419"></a>1419       # B descends from A, then B.base_class will return B.
</span><span class="marked0"><a name="line1420"></a>1420       def abstract_class?
</span><span class="marked1"><a name="line1421"></a>1421         defined?(@abstract_class) &amp;&amp; @abstract_class == true
</span><span class="marked0"><a name="line1422"></a>1422       end
</span><span class="inferred1"><a name="line1423"></a>1423 
</span><span class="marked0"><a name="line1424"></a>1424       def respond_to?(method_id, include_private = false)
</span><span class="marked1"><a name="line1425"></a>1425         if match = DynamicFinderMatch.match(method_id)
</span><span class="uncovered0"><a name="line1426"></a>1426           return true if all_attributes_exists?(match.attribute_names)
</span><span class="uncovered1"><a name="line1427"></a>1427         end
</span><span class="marked0"><a name="line1428"></a>1428         super
</span><span class="inferred1"><a name="line1429"></a>1429       end
</span><span class="inferred0"><a name="line1430"></a>1430 
</span><span class="marked1"><a name="line1431"></a>1431       def sti_name
</span><span class="uncovered0"><a name="line1432"></a>1432         store_full_sti_class ? name : name.demodulize
</span><span class="uncovered1"><a name="line1433"></a>1433       end
</span><span class="inferred0"><a name="line1434"></a>1434 
</span><span class="inferred1"><a name="line1435"></a>1435       # Merges conditions so that the result is a valid +condition+
</span><span class="marked0"><a name="line1436"></a>1436       def merge_conditions(*conditions)
</span><span class="marked1"><a name="line1437"></a>1437         segments = []
</span><span class="inferred0"><a name="line1438"></a>1438 
</span><span class="marked1"><a name="line1439"></a>1439         conditions.each do |condition|
</span><span class="marked0"><a name="line1440"></a>1440           unless condition.blank?
</span><span class="marked1"><a name="line1441"></a>1441             sql = sanitize_sql(condition)
</span><span class="marked0"><a name="line1442"></a>1442             segments &lt;&lt; sql unless sql.blank?
</span><span class="inferred1"><a name="line1443"></a>1443           end
</span><span class="inferred0"><a name="line1444"></a>1444         end
</span><span class="inferred1"><a name="line1445"></a>1445 
</span><span class="marked0"><a name="line1446"></a>1446         &quot;(#{segments.join(') AND (')})&quot; unless segments.empty?
</span><span class="inferred1"><a name="line1447"></a>1447       end
</span><span class="inferred0"><a name="line1448"></a>1448 
</span><span class="marked1"><a name="line1449"></a>1449       private
</span><span class="marked0"><a name="line1450"></a>1450         def find_initial(options)
</span><span class="uncovered1"><a name="line1451"></a>1451           options.update(:limit =&gt; 1)
</span><span class="uncovered0"><a name="line1452"></a>1452           find_every(options).first
</span><span class="uncovered1"><a name="line1453"></a>1453         end
</span><span class="inferred0"><a name="line1454"></a>1454 
</span><span class="marked1"><a name="line1455"></a>1455         def find_last(options)
</span><span class="uncovered0"><a name="line1456"></a>1456           order = options[:order]
</span><span class="uncovered1"><a name="line1457"></a>1457 
</span><span class="uncovered0"><a name="line1458"></a>1458           if order
</span><span class="uncovered1"><a name="line1459"></a>1459             order = reverse_sql_order(order)
</span><span class="uncovered0"><a name="line1460"></a>1460           elsif !scoped?(:find, :order)
</span><span class="uncovered1"><a name="line1461"></a>1461             order = &quot;#{table_name}.#{primary_key} DESC&quot;
</span><span class="uncovered0"><a name="line1462"></a>1462           end
</span><span class="uncovered1"><a name="line1463"></a>1463 
</span><span class="uncovered0"><a name="line1464"></a>1464           if scoped?(:find, :order)
</span><span class="uncovered1"><a name="line1465"></a>1465             scoped_order = reverse_sql_order(scope(:find, :order))
</span><span class="uncovered0"><a name="line1466"></a>1466             scoped_methods.select { |s| s[:find].update(:order =&gt; scoped_order) }
</span><span class="uncovered1"><a name="line1467"></a>1467           end
</span><span class="uncovered0"><a name="line1468"></a>1468 
</span><span class="uncovered1"><a name="line1469"></a>1469           find_initial(options.merge({ :order =&gt; order }))
</span><span class="uncovered0"><a name="line1470"></a>1470         end
</span><span class="inferred1"><a name="line1471"></a>1471 
</span><span class="marked0"><a name="line1472"></a>1472         def reverse_sql_order(order_query)
</span><span class="uncovered1"><a name="line1473"></a>1473           reversed_query = order_query.split(/,/).each { |s|
</span><span class="uncovered0"><a name="line1474"></a>1474             if s.match(/\s(asc|ASC)$/)
</span><span class="uncovered1"><a name="line1475"></a>1475               s.gsub!(/\s(asc|ASC)$/, ' DESC')
</span><span class="uncovered0"><a name="line1476"></a>1476             elsif s.match(/\s(desc|DESC)$/)
</span><span class="uncovered1"><a name="line1477"></a>1477               s.gsub!(/\s(desc|DESC)$/, ' ASC')
</span><span class="uncovered0"><a name="line1478"></a>1478             elsif !s.match(/\s(asc|ASC|desc|DESC)$/)
</span><span class="uncovered1"><a name="line1479"></a>1479               s.concat(' DESC')
</span><span class="uncovered0"><a name="line1480"></a>1480             end
</span><span class="uncovered1"><a name="line1481"></a>1481           }.join(',')
</span><span class="uncovered0"><a name="line1482"></a>1482         end
</span><span class="inferred1"><a name="line1483"></a>1483 
</span><span class="marked0"><a name="line1484"></a>1484         def find_every(options)
</span><span class="marked1"><a name="line1485"></a>1485           include_associations = merge_includes(scope(:find, :include), options[:include])
</span><span class="inferred0"><a name="line1486"></a>1486 
</span><span class="marked1"><a name="line1487"></a>1487           if include_associations.any? &amp;&amp; references_eager_loaded_tables?(options)
</span><span class="uncovered0"><a name="line1488"></a>1488             records = find_with_associations(options)
</span><span class="inferred1"><a name="line1489"></a>1489           else
</span><span class="marked0"><a name="line1490"></a>1490             records = find_by_sql(construct_finder_sql(options))
</span><span class="marked1"><a name="line1491"></a>1491             if include_associations.any?
</span><span class="uncovered0"><a name="line1492"></a>1492               preload_associations(records, include_associations)
</span><span class="uncovered1"><a name="line1493"></a>1493             end
</span><span class="uncovered0"><a name="line1494"></a>1494           end
</span><span class="inferred1"><a name="line1495"></a>1495 
</span><span class="marked0"><a name="line1496"></a>1496           records.each { |record| record.readonly! } if options[:readonly]
</span><span class="inferred1"><a name="line1497"></a>1497 
</span><span class="marked0"><a name="line1498"></a>1498           records
</span><span class="inferred1"><a name="line1499"></a>1499         end
</span><span class="inferred0"><a name="line1500"></a>1500 
</span><span class="marked1"><a name="line1501"></a>1501         def find_from_ids(ids, options)
</span><span class="marked0"><a name="line1502"></a>1502           expects_array = ids.first.kind_of?(Array)
</span><span class="marked1"><a name="line1503"></a>1503           return ids.first if expects_array &amp;&amp; ids.first.empty?
</span><span class="inferred0"><a name="line1504"></a>1504 
</span><span class="marked1"><a name="line1505"></a>1505           ids = ids.flatten.compact.uniq
</span><span class="inferred0"><a name="line1506"></a>1506 
</span><span class="marked1"><a name="line1507"></a>1507           case ids.size
</span><span class="marked0"><a name="line1508"></a>1508             when 0
</span><span class="uncovered1"><a name="line1509"></a>1509               raise RecordNotFound, &quot;Couldn't find #{name} without an ID&quot;
</span><span class="marked0"><a name="line1510"></a>1510             when 1
</span><span class="marked1"><a name="line1511"></a>1511               result = find_one(ids.first, options)
</span><span class="marked0"><a name="line1512"></a>1512               expects_array ? [ result ] : result
</span><span class="uncovered1"><a name="line1513"></a>1513             else
</span><span class="uncovered0"><a name="line1514"></a>1514               find_some(ids, options)
</span><span class="uncovered1"><a name="line1515"></a>1515           end
</span><span class="uncovered0"><a name="line1516"></a>1516         end
</span><span class="inferred1"><a name="line1517"></a>1517 
</span><span class="marked0"><a name="line1518"></a>1518         def find_one(id, options)
</span><span class="marked1"><a name="line1519"></a>1519           conditions = &quot; AND (#{sanitize_sql(options[:conditions])})&quot; if options[:conditions]
</span><span class="marked0"><a name="line1520"></a>1520           options.update :conditions =&gt; &quot;#{quoted_table_name}.#{connection.quote_column_name(primary_key)} = #{quote_value(id,columns_hash[primary_key])}#{conditions}&quot;
</span><span class="inferred1"><a name="line1521"></a>1521 
</span><span class="inferred0"><a name="line1522"></a>1522           # Use find_every(options).first since the primary key condition
</span><span class="inferred1"><a name="line1523"></a>1523           # already ensures we have a single record. Using find_initial adds
</span><span class="inferred0"><a name="line1524"></a>1524           # a superfluous :limit =&gt; 1.
</span><span class="marked1"><a name="line1525"></a>1525           if result = find_every(options).first
</span><span class="marked0"><a name="line1526"></a>1526             result
</span><span class="uncovered1"><a name="line1527"></a>1527           else
</span><span class="uncovered0"><a name="line1528"></a>1528             raise RecordNotFound, &quot;Couldn't find #{name} with ID=#{id}#{conditions}&quot;
</span><span class="uncovered1"><a name="line1529"></a>1529           end
</span><span class="uncovered0"><a name="line1530"></a>1530         end
</span><span class="inferred1"><a name="line1531"></a>1531 
</span><span class="marked0"><a name="line1532"></a>1532         def find_some(ids, options)
</span><span class="uncovered1"><a name="line1533"></a>1533           conditions = &quot; AND (#{sanitize_sql(options[:conditions])})&quot; if options[:conditions]
</span><span class="uncovered0"><a name="line1534"></a>1534           ids_list   = ids.map { |id| quote_value(id,columns_hash[primary_key]) }.join(',')
</span><span class="uncovered1"><a name="line1535"></a>1535           options.update :conditions =&gt; &quot;#{quoted_table_name}.#{connection.quote_column_name(primary_key)} IN (#{ids_list})#{conditions}&quot;
</span><span class="uncovered0"><a name="line1536"></a>1536 
</span><span class="uncovered1"><a name="line1537"></a>1537           result = find_every(options)
</span><span class="uncovered0"><a name="line1538"></a>1538 
</span><span class="uncovered1"><a name="line1539"></a>1539           # Determine expected size from limit and offset, not just ids.size.
</span><span class="uncovered0"><a name="line1540"></a>1540           expected_size =
</span><span class="uncovered1"><a name="line1541"></a>1541             if options[:limit] &amp;&amp; ids.size &gt; options[:limit]
</span><span class="uncovered0"><a name="line1542"></a>1542               options[:limit]
</span><span class="uncovered1"><a name="line1543"></a>1543             else
</span><span class="uncovered0"><a name="line1544"></a>1544               ids.size
</span><span class="uncovered1"><a name="line1545"></a>1545             end
</span><span class="uncovered0"><a name="line1546"></a>1546 
</span><span class="uncovered1"><a name="line1547"></a>1547           # 11 ids with limit 3, offset 9 should give 2 results.
</span><span class="uncovered0"><a name="line1548"></a>1548           if options[:offset] &amp;&amp; (ids.size - options[:offset] &lt; expected_size)
</span><span class="uncovered1"><a name="line1549"></a>1549             expected_size = ids.size - options[:offset]
</span><span class="uncovered0"><a name="line1550"></a>1550           end
</span><span class="uncovered1"><a name="line1551"></a>1551 
</span><span class="uncovered0"><a name="line1552"></a>1552           if result.size == expected_size
</span><span class="uncovered1"><a name="line1553"></a>1553             result
</span><span class="uncovered0"><a name="line1554"></a>1554           else
</span><span class="uncovered1"><a name="line1555"></a>1555             raise RecordNotFound, &quot;Couldn't find all #{name.pluralize} with IDs (#{ids_list})#{conditions} (found #{result.size} results, but was looking for #{expected_size})&quot;
</span><span class="uncovered0"><a name="line1556"></a>1556           end
</span><span class="uncovered1"><a name="line1557"></a>1557         end
</span><span class="inferred0"><a name="line1558"></a>1558 
</span><span class="inferred1"><a name="line1559"></a>1559         # Finder methods must instantiate through this method to work with the
</span><span class="inferred0"><a name="line1560"></a>1560         # single-table inheritance model that makes it possible to create
</span><span class="inferred1"><a name="line1561"></a>1561         # objects of different types from the same table.
</span><span class="marked0"><a name="line1562"></a>1562         def instantiate(record)
</span><span class="marked1"><a name="line1563"></a>1563           object =
</span><span class="marked0"><a name="line1564"></a>1564             if subclass_name = record[inheritance_column]
</span><span class="uncovered1"><a name="line1565"></a>1565               # No type given.
</span><span class="uncovered0"><a name="line1566"></a>1566               if subclass_name.empty?
</span><span class="uncovered1"><a name="line1567"></a>1567                 allocate
</span><span class="uncovered0"><a name="line1568"></a>1568 
</span><span class="uncovered1"><a name="line1569"></a>1569               else
</span><span class="uncovered0"><a name="line1570"></a>1570                 # Ignore type if no column is present since it was probably
</span><span class="uncovered1"><a name="line1571"></a>1571                 # pulled in from a sloppy join.
</span><span class="uncovered0"><a name="line1572"></a>1572                 unless columns_hash.include?(inheritance_column)
</span><span class="uncovered1"><a name="line1573"></a>1573                   allocate
</span><span class="uncovered0"><a name="line1574"></a>1574 
</span><span class="uncovered1"><a name="line1575"></a>1575                 else
</span><span class="uncovered0"><a name="line1576"></a>1576                   begin
</span><span class="uncovered1"><a name="line1577"></a>1577                     compute_type(subclass_name).allocate
</span><span class="uncovered0"><a name="line1578"></a>1578                   rescue NameError
</span><span class="uncovered1"><a name="line1579"></a>1579                     raise SubclassNotFound,
</span><span class="uncovered0"><a name="line1580"></a>1580                       &quot;The single-table inheritance mechanism failed to locate the subclass: '#{record[inheritance_column]}'. &quot; +
</span><span class="uncovered1"><a name="line1581"></a>1581                       &quot;This error is raised because the column '#{inheritance_column}' is reserved for storing the class in case of inheritance. &quot; +
</span><span class="uncovered0"><a name="line1582"></a>1582                       &quot;Please rename this column if you didn't intend it to be used for storing the inheritance class &quot; +
</span><span class="uncovered1"><a name="line1583"></a>1583                       &quot;or overwrite #{self.to_s}.inheritance_column to use another column for that information.&quot;
</span><span class="uncovered0"><a name="line1584"></a>1584                   end
</span><span class="uncovered1"><a name="line1585"></a>1585                 end
</span><span class="uncovered0"><a name="line1586"></a>1586               end
</span><span class="inferred1"><a name="line1587"></a>1587             else
</span><span class="marked0"><a name="line1588"></a>1588               allocate
</span><span class="inferred1"><a name="line1589"></a>1589             end
</span><span class="inferred0"><a name="line1590"></a>1590 
</span><span class="marked1"><a name="line1591"></a>1591           object.instance_variable_set(&quot;@attributes&quot;, record)
</span><span class="marked0"><a name="line1592"></a>1592           object.instance_variable_set(&quot;@attributes_cache&quot;, Hash.new)
</span><span class="inferred1"><a name="line1593"></a>1593 
</span><span class="marked0"><a name="line1594"></a>1594           if object.respond_to_without_attributes?(:after_find)
</span><span class="uncovered1"><a name="line1595"></a>1595             object.send(:callback, :after_find)
</span><span class="uncovered0"><a name="line1596"></a>1596           end
</span><span class="inferred1"><a name="line1597"></a>1597 
</span><span class="marked0"><a name="line1598"></a>1598           if object.respond_to_without_attributes?(:after_initialize)
</span><span class="uncovered1"><a name="line1599"></a>1599             object.send(:callback, :after_initialize)
</span><span class="uncovered0"><a name="line1600"></a>1600           end
</span><span class="inferred1"><a name="line1601"></a>1601 
</span><span class="marked0"><a name="line1602"></a>1602           object
</span><span class="inferred1"><a name="line1603"></a>1603         end
</span><span class="inferred0"><a name="line1604"></a>1604 
</span><span class="inferred1"><a name="line1605"></a>1605         # Nest the type name in the same module as this class.
</span><span class="inferred0"><a name="line1606"></a>1606         # Bar is &quot;MyApp::Business::Bar&quot; relative to MyApp::Business::Foo
</span><span class="marked1"><a name="line1607"></a>1607         def type_name_with_module(type_name)
</span><span class="uncovered0"><a name="line1608"></a>1608           if store_full_sti_class
</span><span class="uncovered1"><a name="line1609"></a>1609             type_name
</span><span class="uncovered0"><a name="line1610"></a>1610           else
</span><span class="uncovered1"><a name="line1611"></a>1611             (/^::/ =~ type_name) ? type_name : &quot;#{parent.name}::#{type_name}&quot;
</span><span class="uncovered0"><a name="line1612"></a>1612           end
</span><span class="uncovered1"><a name="line1613"></a>1613         end
</span><span class="inferred0"><a name="line1614"></a>1614 
</span><span class="marked1"><a name="line1615"></a>1615         def default_select(qualified)
</span><span class="marked0"><a name="line1616"></a>1616           if qualified
</span><span class="uncovered1"><a name="line1617"></a>1617             quoted_table_name + '.*'
</span><span class="inferred0"><a name="line1618"></a>1618           else
</span><span class="marked1"><a name="line1619"></a>1619             '*'
</span><span class="inferred0"><a name="line1620"></a>1620           end
</span><span class="marked1"><a name="line1621"></a>1621         end
</span><span class="inferred0"><a name="line1622"></a>1622 
</span><span class="marked1"><a name="line1623"></a>1623         def construct_finder_sql(options)
</span><span class="marked0"><a name="line1624"></a>1624           scope = scope(:find)
</span><span class="marked1"><a name="line1625"></a>1625           sql  = &quot;SELECT #{options[:select] || (scope &amp;&amp; scope[:select]) || default_select(options[:joins] || (scope &amp;&amp; scope[:joins]))} &quot;
</span><span class="marked0"><a name="line1626"></a>1626           sql &lt;&lt; &quot;FROM #{(scope &amp;&amp; scope[:from]) || options[:from] || quoted_table_name} &quot;
</span><span class="inferred1"><a name="line1627"></a>1627 
</span><span class="marked0"><a name="line1628"></a>1628           add_joins!(sql, options[:joins], scope)
</span><span class="marked1"><a name="line1629"></a>1629           add_conditions!(sql, options[:conditions], scope)
</span><span class="inferred0"><a name="line1630"></a>1630 
</span><span class="marked1"><a name="line1631"></a>1631           add_group!(sql, options[:group], scope)
</span><span class="marked0"><a name="line1632"></a>1632           add_order!(sql, options[:order], scope)
</span><span class="marked1"><a name="line1633"></a>1633           add_limit!(sql, options, scope)
</span><span class="marked0"><a name="line1634"></a>1634           add_lock!(sql, options, scope)
</span><span class="inferred1"><a name="line1635"></a>1635 
</span><span class="marked0"><a name="line1636"></a>1636           sql
</span><span class="inferred1"><a name="line1637"></a>1637         end
</span><span class="inferred0"><a name="line1638"></a>1638 
</span><span class="inferred1"><a name="line1639"></a>1639         # Merges includes so that the result is a valid +include+
</span><span class="marked0"><a name="line1640"></a>1640         def merge_includes(first, second)
</span><span class="marked1"><a name="line1641"></a>1641          (safe_to_array(first) + safe_to_array(second)).uniq
</span><span class="marked0"><a name="line1642"></a>1642         end
</span><span class="inferred1"><a name="line1643"></a>1643 
</span><span class="marked0"><a name="line1644"></a>1644         def merge_joins(*joins)
</span><span class="uncovered1"><a name="line1645"></a>1645           if joins.any?{|j| j.is_a?(String) || array_of_strings?(j) }
</span><span class="uncovered0"><a name="line1646"></a>1646             joins = joins.collect do |join|
</span><span class="uncovered1"><a name="line1647"></a>1647               join = [join] if join.is_a?(String)
</span><span class="uncovered0"><a name="line1648"></a>1648               unless array_of_strings?(join)
</span><span class="uncovered1"><a name="line1649"></a>1649                 join_dependency = ActiveRecord::Associations::ClassMethods::InnerJoinDependency.new(self, join, nil)
</span><span class="uncovered0"><a name="line1650"></a>1650                 join = join_dependency.join_associations.collect { |assoc| assoc.association_join }
</span><span class="uncovered1"><a name="line1651"></a>1651               end
</span><span class="uncovered0"><a name="line1652"></a>1652               join
</span><span class="uncovered1"><a name="line1653"></a>1653             end
</span><span class="uncovered0"><a name="line1654"></a>1654             joins.flatten.uniq
</span><span class="uncovered1"><a name="line1655"></a>1655           else
</span><span class="uncovered0"><a name="line1656"></a>1656             joins.collect{|j| safe_to_array(j)}.flatten.uniq
</span><span class="uncovered1"><a name="line1657"></a>1657           end
</span><span class="uncovered0"><a name="line1658"></a>1658         end
</span><span class="inferred1"><a name="line1659"></a>1659 
</span><span class="inferred0"><a name="line1660"></a>1660         # Object#to_a is deprecated, though it does have the desired behavior
</span><span class="marked1"><a name="line1661"></a>1661         def safe_to_array(o)
</span><span class="marked0"><a name="line1662"></a>1662           case o
</span><span class="marked1"><a name="line1663"></a>1663           when NilClass
</span><span class="marked0"><a name="line1664"></a>1664             []
</span><span class="uncovered1"><a name="line1665"></a>1665           when Array
</span><span class="uncovered0"><a name="line1666"></a>1666             o
</span><span class="uncovered1"><a name="line1667"></a>1667           else
</span><span class="uncovered0"><a name="line1668"></a>1668             [o]
</span><span class="uncovered1"><a name="line1669"></a>1669           end
</span><span class="marked0"><a name="line1670"></a>1670         end
</span><span class="inferred1"><a name="line1671"></a>1671 
</span><span class="marked0"><a name="line1672"></a>1672         def array_of_strings?(o)
</span><span class="uncovered1"><a name="line1673"></a>1673           o.is_a?(Array) &amp;&amp; o.all?{|obj| obj.is_a?(String)}
</span><span class="uncovered0"><a name="line1674"></a>1674         end
</span><span class="inferred1"><a name="line1675"></a>1675 
</span><span class="marked0"><a name="line1676"></a>1676         def add_order!(sql, order, scope = :auto)
</span><span class="marked1"><a name="line1677"></a>1677           scope = scope(:find) if :auto == scope
</span><span class="marked0"><a name="line1678"></a>1678           scoped_order = scope[:order] if scope
</span><span class="marked1"><a name="line1679"></a>1679           if order
</span><span class="marked0"><a name="line1680"></a>1680             sql &lt;&lt; &quot; ORDER BY #{order}&quot;
</span><span class="marked1"><a name="line1681"></a>1681             sql &lt;&lt; &quot;, #{scoped_order}&quot; if scoped_order
</span><span class="inferred0"><a name="line1682"></a>1682           else
</span><span class="marked1"><a name="line1683"></a>1683             sql &lt;&lt; &quot; ORDER BY #{scoped_order}&quot; if scoped_order
</span><span class="inferred0"><a name="line1684"></a>1684           end
</span><span class="inferred1"><a name="line1685"></a>1685         end
</span><span class="inferred0"><a name="line1686"></a>1686 
</span><span class="marked1"><a name="line1687"></a>1687         def add_group!(sql, group, scope = :auto)
</span><span class="marked0"><a name="line1688"></a>1688           if group
</span><span class="uncovered1"><a name="line1689"></a>1689             sql &lt;&lt; &quot; GROUP BY #{group}&quot;
</span><span class="inferred0"><a name="line1690"></a>1690           else
</span><span class="marked1"><a name="line1691"></a>1691             scope = scope(:find) if :auto == scope
</span><span class="marked0"><a name="line1692"></a>1692             if scope &amp;&amp; (scoped_group = scope[:group])
</span><span class="uncovered1"><a name="line1693"></a>1693               sql &lt;&lt; &quot; GROUP BY #{scoped_group}&quot;
</span><span class="uncovered0"><a name="line1694"></a>1694             end
</span><span class="uncovered1"><a name="line1695"></a>1695           end
</span><span class="marked0"><a name="line1696"></a>1696         end
</span><span class="inferred1"><a name="line1697"></a>1697 
</span><span class="inferred0"><a name="line1698"></a>1698         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.
</span><span class="marked1"><a name="line1699"></a>1699         def add_limit!(sql, options, scope = :auto)
</span><span class="marked0"><a name="line1700"></a>1700           scope = scope(:find) if :auto == scope
</span><span class="inferred1"><a name="line1701"></a>1701 
</span><span class="marked0"><a name="line1702"></a>1702           if scope
</span><span class="uncovered1"><a name="line1703"></a>1703             options[:limit] ||= scope[:limit]
</span><span class="uncovered0"><a name="line1704"></a>1704             options[:offset] ||= scope[:offset]
</span><span class="uncovered1"><a name="line1705"></a>1705           end
</span><span class="inferred0"><a name="line1706"></a>1706 
</span><span class="marked1"><a name="line1707"></a>1707           connection.add_limit_offset!(sql, options)
</span><span class="inferred0"><a name="line1708"></a>1708         end
</span><span class="inferred1"><a name="line1709"></a>1709 
</span><span class="inferred0"><a name="line1710"></a>1710         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.
</span><span class="inferred1"><a name="line1711"></a>1711         # The &lt;tt&gt;:lock&lt;/tt&gt; option has precedence over a scoped &lt;tt&gt;:lock&lt;/tt&gt;.
</span><span class="marked0"><a name="line1712"></a>1712         def add_lock!(sql, options, scope = :auto)
</span><span class="marked1"><a name="line1713"></a>1713           scope = scope(:find) if :auto == scope
</span><span class="marked0"><a name="line1714"></a>1714           options = options.reverse_merge(:lock =&gt; scope[:lock]) if scope
</span><span class="marked1"><a name="line1715"></a>1715           connection.add_lock!(sql, options)
</span><span class="inferred0"><a name="line1716"></a>1716         end
</span><span class="inferred1"><a name="line1717"></a>1717 
</span><span class="inferred0"><a name="line1718"></a>1718         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.
</span><span class="marked1"><a name="line1719"></a>1719         def add_joins!(sql, joins, scope = :auto)
</span><span class="marked0"><a name="line1720"></a>1720           scope = scope(:find) if :auto == scope
</span><span class="marked1"><a name="line1721"></a>1721           merged_joins = scope &amp;&amp; scope[:joins] &amp;&amp; joins ? merge_joins(scope[:joins], joins) : (joins || scope &amp;&amp; scope[:joins])
</span><span class="marked0"><a name="line1722"></a>1722           case merged_joins
</span><span class="marked1"><a name="line1723"></a>1723           when Symbol, Hash, Array
</span><span class="uncovered0"><a name="line1724"></a>1724             if array_of_strings?(merged_joins)
</span><span class="uncovered1"><a name="line1725"></a>1725               sql &lt;&lt; merged_joins.join(' ') + &quot; &quot;
</span><span class="uncovered0"><a name="line1726"></a>1726             else
</span><span class="uncovered1"><a name="line1727"></a>1727               join_dependency = ActiveRecord::Associations::ClassMethods::InnerJoinDependency.new(self, merged_joins, nil)
</span><span class="uncovered0"><a name="line1728"></a>1728               sql &lt;&lt; &quot; #{join_dependency.join_associations.collect { |assoc| assoc.association_join }.join} &quot;
</span><span class="uncovered1"><a name="line1729"></a>1729             end
</span><span class="marked0"><a name="line1730"></a>1730           when String
</span><span class="uncovered1"><a name="line1731"></a>1731             sql &lt;&lt; &quot; #{merged_joins} &quot;
</span><span class="uncovered0"><a name="line1732"></a>1732           end
</span><span class="uncovered1"><a name="line1733"></a>1733         end
</span><span class="inferred0"><a name="line1734"></a>1734 
</span><span class="inferred1"><a name="line1735"></a>1735         # Adds a sanitized version of +conditions+ to the +sql+ string. Note that the passed-in +sql+ string is changed.
</span><span class="inferred0"><a name="line1736"></a>1736         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.
</span><span class="marked1"><a name="line1737"></a>1737         def add_conditions!(sql, conditions, scope = :auto)
</span><span class="marked0"><a name="line1738"></a>1738           scope = scope(:find) if :auto == scope
</span><span class="marked1"><a name="line1739"></a>1739           conditions = [conditions]
</span><span class="marked0"><a name="line1740"></a>1740           conditions &lt;&lt; scope[:conditions] if scope
</span><span class="marked1"><a name="line1741"></a>1741           conditions &lt;&lt; type_condition if finder_needs_type_condition?
</span><span class="marked0"><a name="line1742"></a>1742           merged_conditions = merge_conditions(*conditions)
</span><span class="marked1"><a name="line1743"></a>1743           sql &lt;&lt; &quot;WHERE #{merged_conditions} &quot; unless merged_conditions.blank?
</span><span class="inferred0"><a name="line1744"></a>1744         end
</span><span class="inferred1"><a name="line1745"></a>1745 
</span><span class="marked0"><a name="line1746"></a>1746         def type_condition(table_alias=nil)
</span><span class="uncovered1"><a name="line1747"></a>1747           quoted_table_alias = self.connection.quote_table_name(table_alias || table_name)
</span><span class="uncovered0"><a name="line1748"></a>1748           quoted_inheritance_column = connection.quote_column_name(inheritance_column)
</span><span class="uncovered1"><a name="line1749"></a>1749           type_condition = subclasses.inject(&quot;#{quoted_table_alias}.#{quoted_inheritance_column} = '#{sti_name}' &quot;) do |condition, subclass|
</span><span class="uncovered0"><a name="line1750"></a>1750             condition &lt;&lt; &quot;OR #{quoted_table_alias}.#{quoted_inheritance_column} = '#{subclass.sti_name}' &quot;
</span><span class="uncovered1"><a name="line1751"></a>1751           end
</span><span class="uncovered0"><a name="line1752"></a>1752 
</span><span class="uncovered1"><a name="line1753"></a>1753           &quot; (#{type_condition}) &quot;
</span><span class="uncovered0"><a name="line1754"></a>1754         end
</span><span class="inferred1"><a name="line1755"></a>1755 
</span><span class="inferred0"><a name="line1756"></a>1756         # Guesses the table name, but does not decorate it with prefix and suffix information.
</span><span class="marked1"><a name="line1757"></a>1757         def undecorated_table_name(class_name = base_class.name)
</span><span class="marked0"><a name="line1758"></a>1758           table_name = class_name.to_s.demodulize.underscore
</span><span class="marked1"><a name="line1759"></a>1759           table_name = table_name.pluralize if pluralize_table_names
</span><span class="marked0"><a name="line1760"></a>1760           table_name
</span><span class="inferred1"><a name="line1761"></a>1761         end
</span><span class="inferred0"><a name="line1762"></a>1762 
</span><span class="inferred1"><a name="line1763"></a>1763         # Enables dynamic finders like find_by_user_name(user_name) and find_by_user_name_and_password(user_name, password) that are turned into
</span><span class="inferred0"><a name="line1764"></a>1764         # find(:first, :conditions =&gt; [&quot;user_name = ?&quot;, user_name]) and  find(:first, :conditions =&gt; [&quot;user_name = ? AND password = ?&quot;, user_name, password])
</span><span class="inferred1"><a name="line1765"></a>1765         # respectively. Also works for find(:all) by using find_all_by_amount(50) that is turned into find(:all, :conditions =&gt; [&quot;amount = ?&quot;, 50]).
</span><span class="inferred0"><a name="line1766"></a>1766         #
</span><span class="inferred1"><a name="line1767"></a>1767         # It's even possible to use all the additional parameters to find. For example, the full interface for find_all_by_amount
</span><span class="inferred0"><a name="line1768"></a>1768         # is actually find_all_by_amount(amount, options).
</span><span class="inferred1"><a name="line1769"></a>1769         #
</span><span class="inferred0"><a name="line1770"></a>1770         # This also enables you to initialize a record if it is not found, such as find_or_initialize_by_amount(amount)
</span><span class="inferred1"><a name="line1771"></a>1771         # or find_or_create_by_user_and_password(user, password).
</span><span class="inferred0"><a name="line1772"></a>1772         #
</span><span class="inferred1"><a name="line1773"></a>1773         # Each dynamic finder or initializer/creator is also defined in the class after it is first invoked, so that future
</span><span class="inferred0"><a name="line1774"></a>1774         # attempts to use it do not run through method_missing.
</span><span class="marked1"><a name="line1775"></a>1775         def method_missing(method_id, *arguments, &amp;block)
</span><span class="uncovered0"><a name="line1776"></a>1776           if match = DynamicFinderMatch.match(method_id)
</span><span class="uncovered1"><a name="line1777"></a>1777             attribute_names = match.attribute_names
</span><span class="uncovered0"><a name="line1778"></a>1778             super unless all_attributes_exists?(attribute_names)
</span><span class="uncovered1"><a name="line1779"></a>1779             if match.finder?
</span><span class="uncovered0"><a name="line1780"></a>1780               finder = match.finder
</span><span class="uncovered1"><a name="line1781"></a>1781               bang = match.bang?
</span><span class="uncovered0"><a name="line1782"></a>1782               self.class_eval %{
</span><span class="uncovered1"><a name="line1783"></a>1783                 def self.#{method_id}(*args)
</span><span class="uncovered0"><a name="line1784"></a>1784                   options = args.extract_options!
</span><span class="uncovered1"><a name="line1785"></a>1785                   attributes = construct_attributes_from_arguments([:#{attribute_names.join(',:')}], args)
</span><span class="uncovered0"><a name="line1786"></a>1786                   finder_options = { :conditions =&gt; attributes }
</span><span class="uncovered1"><a name="line1787"></a>1787                   validate_find_options(options)
</span><span class="uncovered0"><a name="line1788"></a>1788                   set_readonly_option!(options)
</span><span class="uncovered1"><a name="line1789"></a>1789 
</span><span class="uncovered0"><a name="line1790"></a>1790                   #{'result = ' if bang}if options[:conditions]
</span><span class="uncovered1"><a name="line1791"></a>1791                     with_scope(:find =&gt; finder_options) do
</span><span class="uncovered0"><a name="line1792"></a>1792                       find(:#{finder}, options)
</span><span class="uncovered1"><a name="line1793"></a>1793                     end
</span><span class="uncovered0"><a name="line1794"></a>1794                   else
</span><span class="uncovered1"><a name="line1795"></a>1795                     find(:#{finder}, options.merge(finder_options))
</span><span class="uncovered0"><a name="line1796"></a>1796                   end
</span><span class="uncovered1"><a name="line1797"></a>1797                   #{'result || raise(RecordNotFound)' if bang}
</span><span class="uncovered0"><a name="line1798"></a>1798                 end
</span><span class="uncovered1"><a name="line1799"></a>1799               }, __FILE__, __LINE__
</span><span class="uncovered0"><a name="line1800"></a>1800               send(method_id, *arguments)
</span><span class="uncovered1"><a name="line1801"></a>1801             elsif match.instantiator?
</span><span class="uncovered0"><a name="line1802"></a>1802               instantiator = match.instantiator
</span><span class="uncovered1"><a name="line1803"></a>1803               self.class_eval %{
</span><span class="uncovered0"><a name="line1804"></a>1804                 def self.#{method_id}(*args)
</span><span class="uncovered1"><a name="line1805"></a>1805                   guard_protected_attributes = false
</span><span class="uncovered0"><a name="line1806"></a>1806 
</span><span class="uncovered1"><a name="line1807"></a>1807                   if args[0].is_a?(Hash)
</span><span class="uncovered0"><a name="line1808"></a>1808                     guard_protected_attributes = true
</span><span class="uncovered1"><a name="line1809"></a>1809                     attributes = args[0].with_indifferent_access
</span><span class="uncovered0"><a name="line1810"></a>1810                     find_attributes = attributes.slice(*[:#{attribute_names.join(',:')}])
</span><span class="uncovered1"><a name="line1811"></a>1811                   else
</span><span class="uncovered0"><a name="line1812"></a>1812                     find_attributes = attributes = construct_attributes_from_arguments([:#{attribute_names.join(',:')}], args)
</span><span class="uncovered1"><a name="line1813"></a>1813                   end
</span><span class="uncovered0"><a name="line1814"></a>1814 
</span><span class="uncovered1"><a name="line1815"></a>1815                   options = { :conditions =&gt; find_attributes }
</span><span class="uncovered0"><a name="line1816"></a>1816                   set_readonly_option!(options)
</span><span class="uncovered1"><a name="line1817"></a>1817 
</span><span class="uncovered0"><a name="line1818"></a>1818                   record = find(:first, options)
</span><span class="uncovered1"><a name="line1819"></a>1819 
</span><span class="uncovered0"><a name="line1820"></a>1820                   if record.nil?
</span><span class="uncovered1"><a name="line1821"></a>1821                     record = self.new { |r| r.send(:attributes=, attributes, guard_protected_attributes) }
</span><span class="uncovered0"><a name="line1822"></a>1822                     #{'yield(record) if block_given?'}
</span><span class="uncovered1"><a name="line1823"></a>1823                     #{'record.save' if instantiator == :create}
</span><span class="uncovered0"><a name="line1824"></a>1824                     record
</span><span class="uncovered1"><a name="line1825"></a>1825                   else
</span><span class="uncovered0"><a name="line1826"></a>1826                     record
</span><span class="uncovered1"><a name="line1827"></a>1827                   end
</span><span class="uncovered0"><a name="line1828"></a>1828                 end
</span><span class="uncovered1"><a name="line1829"></a>1829               }, __FILE__, __LINE__
</span><span class="uncovered0"><a name="line1830"></a>1830               send(method_id, *arguments, &amp;block)
</span><span class="uncovered1"><a name="line1831"></a>1831             end
</span><span class="uncovered0"><a name="line1832"></a>1832           else
</span><span class="uncovered1"><a name="line1833"></a>1833             super
</span><span class="uncovered0"><a name="line1834"></a>1834           end
</span><span class="uncovered1"><a name="line1835"></a>1835         end
</span><span class="inferred0"><a name="line1836"></a>1836 
</span><span class="marked1"><a name="line1837"></a>1837         def construct_attributes_from_arguments(attribute_names, arguments)
</span><span class="uncovered0"><a name="line1838"></a>1838           attributes = {}
</span><span class="uncovered1"><a name="line1839"></a>1839           attribute_names.each_with_index { |name, idx| attributes[name] = arguments[idx] }
</span><span class="uncovered0"><a name="line1840"></a>1840           attributes
</span><span class="uncovered1"><a name="line1841"></a>1841         end
</span><span class="inferred0"><a name="line1842"></a>1842 
</span><span class="inferred1"><a name="line1843"></a>1843         # Similar in purpose to +expand_hash_conditions_for_aggregates+.
</span><span class="marked0"><a name="line1844"></a>1844         def expand_attribute_names_for_aggregates(attribute_names)
</span><span class="uncovered1"><a name="line1845"></a>1845           expanded_attribute_names = []
</span><span class="uncovered0"><a name="line1846"></a>1846           attribute_names.each do |attribute_name|
</span><span class="uncovered1"><a name="line1847"></a>1847             unless (aggregation = reflect_on_aggregation(attribute_name.to_sym)).nil?
</span><span class="uncovered0"><a name="line1848"></a>1848               aggregate_mapping(aggregation).each do |field_attr, aggregate_attr|
</span><span class="uncovered1"><a name="line1849"></a>1849                 expanded_attribute_names &lt;&lt; field_attr
</span><span class="uncovered0"><a name="line1850"></a>1850               end
</span><span class="uncovered1"><a name="line1851"></a>1851             else
</span><span class="uncovered0"><a name="line1852"></a>1852               expanded_attribute_names &lt;&lt; attribute_name
</span><span class="uncovered1"><a name="line1853"></a>1853             end
</span><span class="uncovered0"><a name="line1854"></a>1854           end
</span><span class="uncovered1"><a name="line1855"></a>1855           expanded_attribute_names
</span><span class="uncovered0"><a name="line1856"></a>1856         end
</span><span class="inferred1"><a name="line1857"></a>1857 
</span><span class="marked0"><a name="line1858"></a>1858         def all_attributes_exists?(attribute_names)
</span><span class="uncovered1"><a name="line1859"></a>1859           attribute_names = expand_attribute_names_for_aggregates(attribute_names)
</span><span class="uncovered0"><a name="line1860"></a>1860           attribute_names.all? { |name| column_methods_hash.include?(name.to_sym) }
</span><span class="uncovered1"><a name="line1861"></a>1861         end
</span><span class="inferred0"><a name="line1862"></a>1862 
</span><span class="marked1"><a name="line1863"></a>1863         def attribute_condition(argument)
</span><span class="uncovered0"><a name="line1864"></a>1864           case argument
</span><span class="uncovered1"><a name="line1865"></a>1865             when nil   then &quot;IS ?&quot;
</span><span class="uncovered0"><a name="line1866"></a>1866             when Array, ActiveRecord::Associations::AssociationCollection, ActiveRecord::NamedScope::Scope then &quot;IN (?)&quot;
</span><span class="uncovered1"><a name="line1867"></a>1867             when Range then &quot;BETWEEN ? AND ?&quot;
</span><span class="uncovered0"><a name="line1868"></a>1868             else            &quot;= ?&quot;
</span><span class="uncovered1"><a name="line1869"></a>1869           end
</span><span class="uncovered0"><a name="line1870"></a>1870         end
</span><span class="inferred1"><a name="line1871"></a>1871 
</span><span class="inferred0"><a name="line1872"></a>1872         # Interpret Array and Hash as conditions and anything else as an id.
</span><span class="marked1"><a name="line1873"></a>1873         def expand_id_conditions(id_or_conditions)
</span><span class="marked0"><a name="line1874"></a>1874           case id_or_conditions
</span><span class="marked1"><a name="line1875"></a>1875             when Array, Hash then id_or_conditions
</span><span class="uncovered0"><a name="line1876"></a>1876             else sanitize_sql(primary_key =&gt; id_or_conditions)
</span><span class="uncovered1"><a name="line1877"></a>1877           end
</span><span class="marked0"><a name="line1878"></a>1878         end
</span><span class="inferred1"><a name="line1879"></a>1879 
</span><span class="inferred0"><a name="line1880"></a>1880 
</span><span class="inferred1"><a name="line1881"></a>1881         # Defines an &quot;attribute&quot; method (like +inheritance_column+ or
</span><span class="inferred0"><a name="line1882"></a>1882         # +table_name+). A new (class) method will be created with the
</span><span class="inferred1"><a name="line1883"></a>1883         # given name. If a value is specified, the new method will
</span><span class="inferred0"><a name="line1884"></a>1884         # return that value (as a string). Otherwise, the given block
</span><span class="inferred1"><a name="line1885"></a>1885         # will be used to compute the value of the method.
</span><span class="inferred0"><a name="line1886"></a>1886         #
</span><span class="inferred1"><a name="line1887"></a>1887         # The original method will be aliased, with the new name being
</span><span class="inferred0"><a name="line1888"></a>1888         # prefixed with &quot;original_&quot;. This allows the new method to
</span><span class="inferred1"><a name="line1889"></a>1889         # access the original value.
</span><span class="inferred0"><a name="line1890"></a>1890         #
</span><span class="inferred1"><a name="line1891"></a>1891         # Example:
</span><span class="inferred0"><a name="line1892"></a>1892         #
</span><span class="inferred1"><a name="line1893"></a>1893         #   class A &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1894"></a>1894         #     define_attr_method :primary_key, &quot;sysid&quot;
</span><span class="inferred1"><a name="line1895"></a>1895         #     define_attr_method( :inheritance_column ) do
</span><span class="inferred0"><a name="line1896"></a>1896         #       original_inheritance_column + &quot;_id&quot;
</span><span class="inferred1"><a name="line1897"></a>1897         #     end
</span><span class="inferred0"><a name="line1898"></a>1898         #   end
</span><span class="marked1"><a name="line1899"></a>1899         def define_attr_method(name, value=nil, &amp;block)
</span><span class="marked0"><a name="line1900"></a>1900           sing = class &lt;&lt; self; self; end
</span><span class="marked1"><a name="line1901"></a>1901           sing.send :alias_method, &quot;original_#{name}&quot;, name
</span><span class="marked0"><a name="line1902"></a>1902           if block_given?
</span><span class="uncovered1"><a name="line1903"></a>1903             sing.send :define_method, name, &amp;block
</span><span class="inferred0"><a name="line1904"></a>1904           else
</span><span class="inferred1"><a name="line1905"></a>1905             # use eval instead of a block to work around a memory leak in dev
</span><span class="inferred0"><a name="line1906"></a>1906             # mode in fcgi
</span><span class="marked1"><a name="line1907"></a>1907             sing.class_eval &quot;def #{name}; #{value.to_s.inspect}; end&quot;
</span><span class="inferred0"><a name="line1908"></a>1908           end
</span><span class="inferred1"><a name="line1909"></a>1909         end
</span><span class="inferred0"><a name="line1910"></a>1910 
</span><span class="marked1"><a name="line1911"></a>1911       protected
</span><span class="inferred0"><a name="line1912"></a>1912         # Scope parameters to method calls within the block.  Takes a hash of method_name =&gt; parameters hash.
</span><span class="inferred1"><a name="line1913"></a>1913         # method_name may be &lt;tt&gt;:find&lt;/tt&gt; or &lt;tt&gt;:create&lt;/tt&gt;. &lt;tt&gt;:find&lt;/tt&gt; parameters may include the &lt;tt&gt;:conditions&lt;/tt&gt;, &lt;tt&gt;:joins&lt;/tt&gt;,
</span><span class="inferred0"><a name="line1914"></a>1914         # &lt;tt&gt;:include&lt;/tt&gt;, &lt;tt&gt;:offset&lt;/tt&gt;, &lt;tt&gt;:limit&lt;/tt&gt;, and &lt;tt&gt;:readonly&lt;/tt&gt; options. &lt;tt&gt;:create&lt;/tt&gt; parameters are an attributes hash.
</span><span class="inferred1"><a name="line1915"></a>1915         #
</span><span class="inferred0"><a name="line1916"></a>1916         #   class Article &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line1917"></a>1917         #     def self.create_with_scope
</span><span class="inferred0"><a name="line1918"></a>1918         #       with_scope(:find =&gt; { :conditions =&gt; &quot;blog_id = 1&quot; }, :create =&gt; { :blog_id =&gt; 1 }) do
</span><span class="inferred1"><a name="line1919"></a>1919         #         find(1) # =&gt; SELECT * from articles WHERE blog_id = 1 AND id = 1
</span><span class="inferred0"><a name="line1920"></a>1920         #         a = create(1)
</span><span class="inferred1"><a name="line1921"></a>1921         #         a.blog_id # =&gt; 1
</span><span class="inferred0"><a name="line1922"></a>1922         #       end
</span><span class="inferred1"><a name="line1923"></a>1923         #     end
</span><span class="inferred0"><a name="line1924"></a>1924         #   end
</span><span class="inferred1"><a name="line1925"></a>1925         #
</span><span class="inferred0"><a name="line1926"></a>1926         # In nested scopings, all previous parameters are overwritten by the innermost rule, with the exception of
</span><span class="inferred1"><a name="line1927"></a>1927         # &lt;tt&gt;:conditions&lt;/tt&gt; and &lt;tt&gt;:include&lt;/tt&gt; options in &lt;tt&gt;:find&lt;/tt&gt;, which are merged.
</span><span class="inferred0"><a name="line1928"></a>1928         #
</span><span class="inferred1"><a name="line1929"></a>1929         #   class Article &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1930"></a>1930         #     def self.find_with_scope
</span><span class="inferred1"><a name="line1931"></a>1931         #       with_scope(:find =&gt; { :conditions =&gt; &quot;blog_id = 1&quot;, :limit =&gt; 1 }, :create =&gt; { :blog_id =&gt; 1 }) do
</span><span class="inferred0"><a name="line1932"></a>1932         #         with_scope(:find =&gt; { :limit =&gt; 10 })
</span><span class="inferred1"><a name="line1933"></a>1933         #           find(:all) # =&gt; SELECT * from articles WHERE blog_id = 1 LIMIT 10
</span><span class="inferred0"><a name="line1934"></a>1934         #         end
</span><span class="inferred1"><a name="line1935"></a>1935         #         with_scope(:find =&gt; { :conditions =&gt; &quot;author_id = 3&quot; })
</span><span class="inferred0"><a name="line1936"></a>1936         #           find(:all) # =&gt; SELECT * from articles WHERE blog_id = 1 AND author_id = 3 LIMIT 1
</span><span class="inferred1"><a name="line1937"></a>1937         #         end
</span><span class="inferred0"><a name="line1938"></a>1938         #       end
</span><span class="inferred1"><a name="line1939"></a>1939         #     end
</span><span class="inferred0"><a name="line1940"></a>1940         #   end
</span><span class="inferred1"><a name="line1941"></a>1941         #
</span><span class="inferred0"><a name="line1942"></a>1942         # You can ignore any previous scopings by using the &lt;tt&gt;with_exclusive_scope&lt;/tt&gt; method.
</span><span class="inferred1"><a name="line1943"></a>1943         #
</span><span class="inferred0"><a name="line1944"></a>1944         #   class Article &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line1945"></a>1945         #     def self.find_with_exclusive_scope
</span><span class="inferred0"><a name="line1946"></a>1946         #       with_scope(:find =&gt; { :conditions =&gt; &quot;blog_id = 1&quot;, :limit =&gt; 1 }) do
</span><span class="inferred1"><a name="line1947"></a>1947         #         with_exclusive_scope(:find =&gt; { :limit =&gt; 10 })
</span><span class="inferred0"><a name="line1948"></a>1948         #           find(:all) # =&gt; SELECT * from articles LIMIT 10
</span><span class="inferred1"><a name="line1949"></a>1949         #         end
</span><span class="inferred0"><a name="line1950"></a>1950         #       end
</span><span class="inferred1"><a name="line1951"></a>1951         #     end
</span><span class="inferred0"><a name="line1952"></a>1952         #   end
</span><span class="inferred1"><a name="line1953"></a>1953         #
</span><span class="inferred0"><a name="line1954"></a>1954         # *Note*: the +:find+ scope also has effect on update and deletion methods,
</span><span class="inferred1"><a name="line1955"></a>1955         # like +update_all+ and +delete_all+.
</span><span class="marked0"><a name="line1956"></a>1956         def with_scope(method_scoping = {}, action = :merge, &amp;block)
</span><span class="marked1"><a name="line1957"></a>1957           method_scoping = method_scoping.method_scoping if method_scoping.respond_to?(:method_scoping)
</span><span class="inferred0"><a name="line1958"></a>1958 
</span><span class="inferred1"><a name="line1959"></a>1959           # Dup first and second level of hash (method and params).
</span><span class="marked0"><a name="line1960"></a>1960           method_scoping = method_scoping.inject({}) do |hash, (method, params)|
</span><span class="uncovered1"><a name="line1961"></a>1961             hash[method] = (params == true) ? params : params.dup
</span><span class="uncovered0"><a name="line1962"></a>1962             hash
</span><span class="uncovered1"><a name="line1963"></a>1963           end
</span><span class="inferred0"><a name="line1964"></a>1964 
</span><span class="marked1"><a name="line1965"></a>1965           method_scoping.assert_valid_keys([ :find, :create ])
</span><span class="inferred0"><a name="line1966"></a>1966 
</span><span class="marked1"><a name="line1967"></a>1967           if f = method_scoping[:find]
</span><span class="uncovered0"><a name="line1968"></a>1968             f.assert_valid_keys(VALID_FIND_OPTIONS)
</span><span class="uncovered1"><a name="line1969"></a>1969             set_readonly_option! f
</span><span class="uncovered0"><a name="line1970"></a>1970           end
</span><span class="inferred1"><a name="line1971"></a>1971 
</span><span class="inferred0"><a name="line1972"></a>1972           # Merge scopings
</span><span class="marked1"><a name="line1973"></a>1973           if action == :merge &amp;&amp; current_scoped_methods
</span><span class="uncovered0"><a name="line1974"></a>1974             method_scoping = current_scoped_methods.inject(method_scoping) do |hash, (method, params)|
</span><span class="uncovered1"><a name="line1975"></a>1975               case hash[method]
</span><span class="uncovered0"><a name="line1976"></a>1976                 when Hash
</span><span class="uncovered1"><a name="line1977"></a>1977                   if method == :find
</span><span class="uncovered0"><a name="line1978"></a>1978                     (hash[method].keys + params.keys).uniq.each do |key|
</span><span class="uncovered1"><a name="line1979"></a>1979                       merge = hash[method][key] &amp;&amp; params[key] # merge if both scopes have the same key
</span><span class="uncovered0"><a name="line1980"></a>1980                       if key == :conditions &amp;&amp; merge
</span><span class="uncovered1"><a name="line1981"></a>1981                         hash[method][key] = merge_conditions(params[key], hash[method][key])
</span><span class="uncovered0"><a name="line1982"></a>1982                       elsif key == :include &amp;&amp; merge
</span><span class="uncovered1"><a name="line1983"></a>1983                         hash[method][key] = merge_includes(hash[method][key], params[key]).uniq
</span><span class="uncovered0"><a name="line1984"></a>1984                       elsif key == :joins &amp;&amp; merge
</span><span class="uncovered1"><a name="line1985"></a>1985                         hash[method][key] = merge_joins(params[key], hash[method][key])
</span><span class="uncovered0"><a name="line1986"></a>1986                       else
</span><span class="uncovered1"><a name="line1987"></a>1987                         hash[method][key] = hash[method][key] || params[key]
</span><span class="uncovered0"><a name="line1988"></a>1988                       end
</span><span class="uncovered1"><a name="line1989"></a>1989                     end
</span><span class="uncovered0"><a name="line1990"></a>1990                   else
</span><span class="uncovered1"><a name="line1991"></a>1991                     hash[method] = params.merge(hash[method])
</span><span class="uncovered0"><a name="line1992"></a>1992                   end
</span><span class="uncovered1"><a name="line1993"></a>1993                 else
</span><span class="uncovered0"><a name="line1994"></a>1994                   hash[method] = params
</span><span class="uncovered1"><a name="line1995"></a>1995               end
</span><span class="uncovered0"><a name="line1996"></a>1996               hash
</span><span class="uncovered1"><a name="line1997"></a>1997             end
</span><span class="uncovered0"><a name="line1998"></a>1998           end
</span><span class="inferred1"><a name="line1999"></a>1999 
</span><span class="marked0"><a name="line2000"></a>2000           self.scoped_methods &lt;&lt; method_scoping
</span><span class="inferred1"><a name="line2001"></a>2001 
</span><span class="marked0"><a name="line2002"></a>2002           begin
</span><span class="marked1"><a name="line2003"></a>2003             yield
</span><span class="inferred0"><a name="line2004"></a>2004           ensure
</span><span class="marked1"><a name="line2005"></a>2005             self.scoped_methods.pop
</span><span class="inferred0"><a name="line2006"></a>2006           end
</span><span class="inferred1"><a name="line2007"></a>2007         end
</span><span class="inferred0"><a name="line2008"></a>2008 
</span><span class="inferred1"><a name="line2009"></a>2009         # Works like with_scope, but discards any nested properties.
</span><span class="marked0"><a name="line2010"></a>2010         def with_exclusive_scope(method_scoping = {}, &amp;block)
</span><span class="marked1"><a name="line2011"></a>2011           with_scope(method_scoping, :overwrite, &amp;block)
</span><span class="inferred0"><a name="line2012"></a>2012         end
</span><span class="inferred1"><a name="line2013"></a>2013 
</span><span class="marked0"><a name="line2014"></a>2014         def subclasses #:nodoc:
</span><span class="uncovered1"><a name="line2015"></a>2015           @@subclasses[self] ||= []
</span><span class="uncovered0"><a name="line2016"></a>2016           @@subclasses[self] + extra = @@subclasses[self].inject([]) {|list, subclass| list + subclass.subclasses }
</span><span class="uncovered1"><a name="line2017"></a>2017         end
</span><span class="inferred0"><a name="line2018"></a>2018 
</span><span class="inferred1"><a name="line2019"></a>2019         # Test whether the given method and optional key are scoped.
</span><span class="marked0"><a name="line2020"></a>2020         def scoped?(method, key = nil) #:nodoc:
</span><span class="marked1"><a name="line2021"></a>2021           if current_scoped_methods &amp;&amp; (scope = current_scoped_methods[method])
</span><span class="uncovered0"><a name="line2022"></a>2022             !key || scope.has_key?(key)
</span><span class="uncovered1"><a name="line2023"></a>2023           end
</span><span class="marked0"><a name="line2024"></a>2024         end
</span><span class="inferred1"><a name="line2025"></a>2025 
</span><span class="inferred0"><a name="line2026"></a>2026         # Retrieve the scope for the given method and optional key.
</span><span class="marked1"><a name="line2027"></a>2027         def scope(method, key = nil) #:nodoc:
</span><span class="marked0"><a name="line2028"></a>2028           if current_scoped_methods &amp;&amp; (scope = current_scoped_methods[method])
</span><span class="uncovered1"><a name="line2029"></a>2029             key ? scope[key] : scope
</span><span class="uncovered0"><a name="line2030"></a>2030           end
</span><span class="marked1"><a name="line2031"></a>2031         end
</span><span class="inferred0"><a name="line2032"></a>2032 
</span><span class="marked1"><a name="line2033"></a>2033         def scoped_methods #:nodoc:
</span><span class="marked0"><a name="line2034"></a>2034           Thread.current[:&quot;#{self}_scoped_methods&quot;] ||= []
</span><span class="marked1"><a name="line2035"></a>2035         end
</span><span class="inferred0"><a name="line2036"></a>2036 
</span><span class="marked1"><a name="line2037"></a>2037         def current_scoped_methods #:nodoc:
</span><span class="marked0"><a name="line2038"></a>2038           scoped_methods.last
</span><span class="marked1"><a name="line2039"></a>2039         end
</span><span class="inferred0"><a name="line2040"></a>2040 
</span><span class="inferred1"><a name="line2041"></a>2041         # Returns the class type of the record using the current module as a prefix. So descendents of
</span><span class="inferred0"><a name="line2042"></a>2042         # MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.
</span><span class="marked1"><a name="line2043"></a>2043         def compute_type(type_name)
</span><span class="uncovered0"><a name="line2044"></a>2044           modularized_name = type_name_with_module(type_name)
</span><span class="uncovered1"><a name="line2045"></a>2045           silence_warnings do
</span><span class="uncovered0"><a name="line2046"></a>2046             begin
</span><span class="uncovered1"><a name="line2047"></a>2047               class_eval(modularized_name, __FILE__, __LINE__)
</span><span class="uncovered0"><a name="line2048"></a>2048             rescue NameError
</span><span class="uncovered1"><a name="line2049"></a>2049               class_eval(type_name, __FILE__, __LINE__)
</span><span class="uncovered0"><a name="line2050"></a>2050             end
</span><span class="uncovered1"><a name="line2051"></a>2051           end
</span><span class="uncovered0"><a name="line2052"></a>2052         end
</span><span class="inferred1"><a name="line2053"></a>2053 
</span><span class="inferred0"><a name="line2054"></a>2054         # Returns the class descending directly from Active Record in the inheritance hierarchy.
</span><span class="marked1"><a name="line2055"></a>2055         def class_of_active_record_descendant(klass)
</span><span class="marked0"><a name="line2056"></a>2056           if klass.superclass == Base || klass.superclass.abstract_class?
</span><span class="marked1"><a name="line2057"></a>2057             klass
</span><span class="uncovered0"><a name="line2058"></a>2058           elsif klass.superclass.nil?
</span><span class="uncovered1"><a name="line2059"></a>2059             raise ActiveRecordError, &quot;#{name} doesn't belong in a hierarchy descending from ActiveRecord&quot;
</span><span class="uncovered0"><a name="line2060"></a>2060           else
</span><span class="uncovered1"><a name="line2061"></a>2061             class_of_active_record_descendant(klass.superclass)
</span><span class="uncovered0"><a name="line2062"></a>2062           end
</span><span class="marked1"><a name="line2063"></a>2063         end
</span><span class="inferred0"><a name="line2064"></a>2064 
</span><span class="inferred1"><a name="line2065"></a>2065         # Returns the name of the class descending directly from Active Record in the inheritance hierarchy.
</span><span class="marked0"><a name="line2066"></a>2066         def class_name_of_active_record_descendant(klass) #:nodoc:
</span><span class="uncovered1"><a name="line2067"></a>2067           klass.base_class.name
</span><span class="uncovered0"><a name="line2068"></a>2068         end
</span><span class="inferred1"><a name="line2069"></a>2069 
</span><span class="inferred0"><a name="line2070"></a>2070         # Accepts an array, hash, or string of SQL conditions and sanitizes
</span><span class="inferred1"><a name="line2071"></a>2071         # them into a valid SQL fragment for a WHERE clause.
</span><span class="inferred0"><a name="line2072"></a>2072         #   [&quot;name='%s' and group_id='%s'&quot;, &quot;foo'bar&quot;, 4]  returns  &quot;name='foo''bar' and group_id='4'&quot;
</span><span class="inferred1"><a name="line2073"></a>2073         #   { :name =&gt; &quot;foo'bar&quot;, :group_id =&gt; 4 }  returns &quot;name='foo''bar' and group_id='4'&quot;
</span><span class="inferred0"><a name="line2074"></a>2074         #   &quot;name='foo''bar' and group_id='4'&quot; returns &quot;name='foo''bar' and group_id='4'&quot;
</span><span class="marked1"><a name="line2075"></a>2075         def sanitize_sql_for_conditions(condition)
</span><span class="marked0"><a name="line2076"></a>2076           return nil if condition.blank?
</span><span class="inferred1"><a name="line2077"></a>2077 
</span><span class="marked0"><a name="line2078"></a>2078           case condition
</span><span class="marked1"><a name="line2079"></a>2079             when Array; sanitize_sql_array(condition)
</span><span class="marked0"><a name="line2080"></a>2080             when Hash;  sanitize_sql_hash_for_conditions(condition)
</span><span class="marked1"><a name="line2081"></a>2081             else        condition
</span><span class="inferred0"><a name="line2082"></a>2082           end
</span><span class="inferred1"><a name="line2083"></a>2083         end
</span><span class="marked0"><a name="line2084"></a>2084         alias_method :sanitize_sql, :sanitize_sql_for_conditions
</span><span class="inferred1"><a name="line2085"></a>2085 
</span><span class="inferred0"><a name="line2086"></a>2086         # Accepts an array, hash, or string of SQL conditions and sanitizes
</span><span class="inferred1"><a name="line2087"></a>2087         # them into a valid SQL fragment for a SET clause.
</span><span class="inferred0"><a name="line2088"></a>2088         #   { :name =&gt; nil, :group_id =&gt; 4 }  returns &quot;name = NULL , group_id='4'&quot;
</span><span class="marked1"><a name="line2089"></a>2089         def sanitize_sql_for_assignment(assignments)
</span><span class="uncovered0"><a name="line2090"></a>2090           case assignments
</span><span class="uncovered1"><a name="line2091"></a>2091             when Array; sanitize_sql_array(assignments)
</span><span class="uncovered0"><a name="line2092"></a>2092             when Hash;  sanitize_sql_hash_for_assignment(assignments)
</span><span class="uncovered1"><a name="line2093"></a>2093             else        assignments
</span><span class="uncovered0"><a name="line2094"></a>2094           end
</span><span class="uncovered1"><a name="line2095"></a>2095         end
</span><span class="inferred0"><a name="line2096"></a>2096 
</span><span class="marked1"><a name="line2097"></a>2097         def aggregate_mapping(reflection)
</span><span class="uncovered0"><a name="line2098"></a>2098           mapping = reflection.options[:mapping] || [reflection.name, reflection.name]
</span><span class="uncovered1"><a name="line2099"></a>2099           mapping.first.is_a?(Array) ? mapping : [mapping]
</span><span class="uncovered0"><a name="line2100"></a>2100         end
</span><span class="inferred1"><a name="line2101"></a>2101 
</span><span class="inferred0"><a name="line2102"></a>2102         # Accepts a hash of SQL conditions and replaces those attributes
</span><span class="inferred1"><a name="line2103"></a>2103         # that correspond to a +composed_of+ relationship with their expanded
</span><span class="inferred0"><a name="line2104"></a>2104         # aggregate attribute values.
</span><span class="inferred1"><a name="line2105"></a>2105         # Given:
</span><span class="inferred0"><a name="line2106"></a>2106         #     class Person &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line2107"></a>2107         #       composed_of :address, :class_name =&gt; &quot;Address&quot;,
</span><span class="inferred0"><a name="line2108"></a>2108         #         :mapping =&gt; [%w(address_street street), %w(address_city city)]
</span><span class="inferred1"><a name="line2109"></a>2109         #     end
</span><span class="inferred0"><a name="line2110"></a>2110         # Then:
</span><span class="inferred1"><a name="line2111"></a>2111         #     { :address =&gt; Address.new(&quot;813 abc st.&quot;, &quot;chicago&quot;) }
</span><span class="inferred0"><a name="line2112"></a>2112         #       # =&gt; { :address_street =&gt; &quot;813 abc st.&quot;, :address_city =&gt; &quot;chicago&quot; }
</span><span class="marked1"><a name="line2113"></a>2113         def expand_hash_conditions_for_aggregates(attrs)
</span><span class="uncovered0"><a name="line2114"></a>2114           expanded_attrs = {}
</span><span class="uncovered1"><a name="line2115"></a>2115           attrs.each do |attr, value|
</span><span class="uncovered0"><a name="line2116"></a>2116             unless (aggregation = reflect_on_aggregation(attr.to_sym)).nil?
</span><span class="uncovered1"><a name="line2117"></a>2117               mapping = aggregate_mapping(aggregation)
</span><span class="uncovered0"><a name="line2118"></a>2118               mapping.each do |field_attr, aggregate_attr|
</span><span class="uncovered1"><a name="line2119"></a>2119                 if mapping.size == 1 &amp;&amp; !value.respond_to?(aggregate_attr)
</span><span class="uncovered0"><a name="line2120"></a>2120                   expanded_attrs[field_attr] = value
</span><span class="uncovered1"><a name="line2121"></a>2121                 else
</span><span class="uncovered0"><a name="line2122"></a>2122                   expanded_attrs[field_attr] = value.send(aggregate_attr)
</span><span class="uncovered1"><a name="line2123"></a>2123                 end
</span><span class="uncovered0"><a name="line2124"></a>2124               end
</span><span class="uncovered1"><a name="line2125"></a>2125             else
</span><span class="uncovered0"><a name="line2126"></a>2126               expanded_attrs[attr] = value
</span><span class="uncovered1"><a name="line2127"></a>2127             end
</span><span class="uncovered0"><a name="line2128"></a>2128           end
</span><span class="uncovered1"><a name="line2129"></a>2129           expanded_attrs
</span><span class="uncovered0"><a name="line2130"></a>2130         end
</span><span class="inferred1"><a name="line2131"></a>2131 
</span><span class="inferred0"><a name="line2132"></a>2132         # Sanitizes a hash of attribute/value pairs into SQL conditions for a WHERE clause.
</span><span class="inferred1"><a name="line2133"></a>2133         #   { :name =&gt; &quot;foo'bar&quot;, :group_id =&gt; 4 }
</span><span class="inferred0"><a name="line2134"></a>2134         #     # =&gt; &quot;name='foo''bar' and group_id= 4&quot;
</span><span class="inferred1"><a name="line2135"></a>2135         #   { :status =&gt; nil, :group_id =&gt; [1,2,3] }
</span><span class="inferred0"><a name="line2136"></a>2136         #     # =&gt; &quot;status IS NULL and group_id IN (1,2,3)&quot;
</span><span class="inferred1"><a name="line2137"></a>2137         #   { :age =&gt; 13..18 }
</span><span class="inferred0"><a name="line2138"></a>2138         #     # =&gt; &quot;age BETWEEN 13 AND 18&quot;
</span><span class="inferred1"><a name="line2139"></a>2139         #   { 'other_records.id' =&gt; 7 }
</span><span class="inferred0"><a name="line2140"></a>2140         #     # =&gt; &quot;`other_records`.`id` = 7&quot;
</span><span class="inferred1"><a name="line2141"></a>2141         #   { :other_records =&gt; { :id =&gt; 7 } }
</span><span class="inferred0"><a name="line2142"></a>2142         #     # =&gt; &quot;`other_records`.`id` = 7&quot;
</span><span class="inferred1"><a name="line2143"></a>2143         # And for value objects on a composed_of relationship:
</span><span class="inferred0"><a name="line2144"></a>2144         #   { :address =&gt; Address.new(&quot;123 abc st.&quot;, &quot;chicago&quot;) }
</span><span class="inferred1"><a name="line2145"></a>2145         #     # =&gt; &quot;address_street='123 abc st.' and address_city='chicago'&quot;
</span><span class="marked0"><a name="line2146"></a>2146         def sanitize_sql_hash_for_conditions(attrs, table_name = quoted_table_name)
</span><span class="uncovered1"><a name="line2147"></a>2147           attrs = expand_hash_conditions_for_aggregates(attrs)
</span><span class="uncovered0"><a name="line2148"></a>2148 
</span><span class="uncovered1"><a name="line2149"></a>2149           conditions = attrs.map do |attr, value|
</span><span class="uncovered0"><a name="line2150"></a>2150             unless value.is_a?(Hash)
</span><span class="uncovered1"><a name="line2151"></a>2151               attr = attr.to_s
</span><span class="uncovered0"><a name="line2152"></a>2152 
</span><span class="uncovered1"><a name="line2153"></a>2153               # Extract table name from qualified attribute names.
</span><span class="uncovered0"><a name="line2154"></a>2154               if attr.include?('.')
</span><span class="uncovered1"><a name="line2155"></a>2155                 table_name, attr = attr.split('.', 2)
</span><span class="uncovered0"><a name="line2156"></a>2156                 table_name = connection.quote_table_name(table_name)
</span><span class="uncovered1"><a name="line2157"></a>2157               end
</span><span class="uncovered0"><a name="line2158"></a>2158 
</span><span class="uncovered1"><a name="line2159"></a>2159               &quot;#{table_name}.#{connection.quote_column_name(attr)} #{attribute_condition(value)}&quot;
</span><span class="uncovered0"><a name="line2160"></a>2160             else
</span><span class="uncovered1"><a name="line2161"></a>2161               sanitize_sql_hash_for_conditions(value, connection.quote_table_name(attr.to_s))
</span><span class="uncovered0"><a name="line2162"></a>2162             end
</span><span class="uncovered1"><a name="line2163"></a>2163           end.join(' AND ')
</span><span class="uncovered0"><a name="line2164"></a>2164 
</span><span class="uncovered1"><a name="line2165"></a>2165           replace_bind_variables(conditions, expand_range_bind_variables(attrs.values))
</span><span class="uncovered0"><a name="line2166"></a>2166         end
</span><span class="marked1"><a name="line2167"></a>2167         alias_method :sanitize_sql_hash, :sanitize_sql_hash_for_conditions
</span><span class="inferred0"><a name="line2168"></a>2168 
</span><span class="inferred1"><a name="line2169"></a>2169         # Sanitizes a hash of attribute/value pairs into SQL conditions for a SET clause.
</span><span class="inferred0"><a name="line2170"></a>2170         #   { :status =&gt; nil, :group_id =&gt; 1 }
</span><span class="inferred1"><a name="line2171"></a>2171         #     # =&gt; &quot;status = NULL , group_id = 1&quot;
</span><span class="marked0"><a name="line2172"></a>2172         def sanitize_sql_hash_for_assignment(attrs)
</span><span class="uncovered1"><a name="line2173"></a>2173           attrs.map do |attr, value|
</span><span class="uncovered0"><a name="line2174"></a>2174             &quot;#{connection.quote_column_name(attr)} = #{quote_bound_value(value)}&quot;
</span><span class="uncovered1"><a name="line2175"></a>2175           end.join(', ')
</span><span class="uncovered0"><a name="line2176"></a>2176         end
</span><span class="inferred1"><a name="line2177"></a>2177 
</span><span class="inferred0"><a name="line2178"></a>2178         # Accepts an array of conditions.  The array has each value
</span><span class="inferred1"><a name="line2179"></a>2179         # sanitized and interpolated into the SQL statement.
</span><span class="inferred0"><a name="line2180"></a>2180         #   [&quot;name='%s' and group_id='%s'&quot;, &quot;foo'bar&quot;, 4]  returns  &quot;name='foo''bar' and group_id='4'&quot;
</span><span class="marked1"><a name="line2181"></a>2181         def sanitize_sql_array(ary)
</span><span class="marked0"><a name="line2182"></a>2182           statement, *values = ary
</span><span class="marked1"><a name="line2183"></a>2183           if values.first.is_a?(Hash) and statement =~ /:\w+/
</span><span class="inferred0"><a name="line2184"></a>2184             replace_named_bind_variables(statement, values.first)
</span><span class="marked1"><a name="line2185"></a>2185           elsif statement.include?('?')
</span><span class="marked0"><a name="line2186"></a>2186             replace_bind_variables(statement, values)
</span><span class="uncovered1"><a name="line2187"></a>2187           else
</span><span class="uncovered0"><a name="line2188"></a>2188             statement % values.collect { |value| connection.quote_string(value.to_s) }
</span><span class="uncovered1"><a name="line2189"></a>2189           end
</span><span class="uncovered0"><a name="line2190"></a>2190         end
</span><span class="inferred1"><a name="line2191"></a>2191 
</span><span class="marked0"><a name="line2192"></a>2192         alias_method :sanitize_conditions, :sanitize_sql
</span><span class="inferred1"><a name="line2193"></a>2193 
</span><span class="marked0"><a name="line2194"></a>2194         def replace_bind_variables(statement, values) #:nodoc:
</span><span class="marked1"><a name="line2195"></a>2195           raise_if_bind_arity_mismatch(statement, statement.count('?'), values.size)
</span><span class="marked0"><a name="line2196"></a>2196           bound = values.dup
</span><span class="marked1"><a name="line2197"></a>2197           statement.gsub('?') { quote_bound_value(bound.shift) }
</span><span class="inferred0"><a name="line2198"></a>2198         end
</span><span class="inferred1"><a name="line2199"></a>2199 
</span><span class="marked0"><a name="line2200"></a>2200         def replace_named_bind_variables(statement, bind_vars) #:nodoc:
</span><span class="uncovered1"><a name="line2201"></a>2201           statement.gsub(/(:?):([a-zA-Z]\w*)/) do
</span><span class="uncovered0"><a name="line2202"></a>2202             if $1 == ':' # skip postgresql casts
</span><span class="uncovered1"><a name="line2203"></a>2203               $&amp; # return the whole match
</span><span class="uncovered0"><a name="line2204"></a>2204             elsif bind_vars.include?(match = $2.to_sym)
</span><span class="uncovered1"><a name="line2205"></a>2205               quote_bound_value(bind_vars[match])
</span><span class="uncovered0"><a name="line2206"></a>2206             else
</span><span class="uncovered1"><a name="line2207"></a>2207               raise PreparedStatementInvalid, &quot;missing value for :#{match} in #{statement}&quot;
</span><span class="uncovered0"><a name="line2208"></a>2208             end
</span><span class="uncovered1"><a name="line2209"></a>2209           end
</span><span class="uncovered0"><a name="line2210"></a>2210         end
</span><span class="inferred1"><a name="line2211"></a>2211 
</span><span class="marked0"><a name="line2212"></a>2212         def expand_range_bind_variables(bind_vars) #:nodoc:
</span><span class="uncovered1"><a name="line2213"></a>2213           expanded = []
</span><span class="uncovered0"><a name="line2214"></a>2214 
</span><span class="uncovered1"><a name="line2215"></a>2215           bind_vars.each do |var|
</span><span class="uncovered0"><a name="line2216"></a>2216             next if var.is_a?(Hash)
</span><span class="uncovered1"><a name="line2217"></a>2217 
</span><span class="uncovered0"><a name="line2218"></a>2218             if var.is_a?(Range)
</span><span class="uncovered1"><a name="line2219"></a>2219               expanded &lt;&lt; var.first
</span><span class="uncovered0"><a name="line2220"></a>2220               expanded &lt;&lt; var.last
</span><span class="uncovered1"><a name="line2221"></a>2221             else
</span><span class="uncovered0"><a name="line2222"></a>2222               expanded &lt;&lt; var
</span><span class="uncovered1"><a name="line2223"></a>2223             end
</span><span class="uncovered0"><a name="line2224"></a>2224           end
</span><span class="uncovered1"><a name="line2225"></a>2225 
</span><span class="uncovered0"><a name="line2226"></a>2226           expanded
</span><span class="uncovered1"><a name="line2227"></a>2227         end
</span><span class="inferred0"><a name="line2228"></a>2228 
</span><span class="marked1"><a name="line2229"></a>2229         def quote_bound_value(value) #:nodoc:
</span><span class="marked0"><a name="line2230"></a>2230           if value.respond_to?(:map) &amp;&amp; !value.acts_like?(:string)
</span><span class="uncovered1"><a name="line2231"></a>2231             if value.respond_to?(:empty?) &amp;&amp; value.empty?
</span><span class="uncovered0"><a name="line2232"></a>2232               connection.quote(nil)
</span><span class="uncovered1"><a name="line2233"></a>2233             else
</span><span class="uncovered0"><a name="line2234"></a>2234               value.map { |v| connection.quote(v) }.join(',')
</span><span class="uncovered1"><a name="line2235"></a>2235             end
</span><span class="inferred0"><a name="line2236"></a>2236           else
</span><span class="marked1"><a name="line2237"></a>2237             connection.quote(value)
</span><span class="inferred0"><a name="line2238"></a>2238           end
</span><span class="marked1"><a name="line2239"></a>2239         end
</span><span class="inferred0"><a name="line2240"></a>2240 
</span><span class="marked1"><a name="line2241"></a>2241         def raise_if_bind_arity_mismatch(statement, expected, provided) #:nodoc:
</span><span class="marked0"><a name="line2242"></a>2242           unless expected == provided
</span><span class="uncovered1"><a name="line2243"></a>2243             raise PreparedStatementInvalid, &quot;wrong number of bind variables (#{provided} for #{expected}) in: #{statement}&quot;
</span><span class="uncovered0"><a name="line2244"></a>2244           end
</span><span class="marked1"><a name="line2245"></a>2245         end
</span><span class="inferred0"><a name="line2246"></a>2246 
</span><span class="marked1"><a name="line2247"></a>2247         VALID_FIND_OPTIONS = [ :conditions, :include, :joins, :limit, :offset,
</span><span class="inferred0"><a name="line2248"></a>2248                                :order, :select, :readonly, :group, :from, :lock ]
</span><span class="inferred1"><a name="line2249"></a>2249 
</span><span class="marked0"><a name="line2250"></a>2250         def validate_find_options(options) #:nodoc:
</span><span class="marked1"><a name="line2251"></a>2251           options.assert_valid_keys(VALID_FIND_OPTIONS)
</span><span class="marked0"><a name="line2252"></a>2252         end
</span><span class="inferred1"><a name="line2253"></a>2253 
</span><span class="marked0"><a name="line2254"></a>2254         def set_readonly_option!(options) #:nodoc:
</span><span class="inferred1"><a name="line2255"></a>2255           # Inherit :readonly from finder scope if set.  Otherwise,
</span><span class="inferred0"><a name="line2256"></a>2256           # if :joins is not blank then :readonly defaults to true.
</span><span class="marked1"><a name="line2257"></a>2257           unless options.has_key?(:readonly)
</span><span class="marked0"><a name="line2258"></a>2258             if scoped_readonly = scope(:find, :readonly)
</span><span class="uncovered1"><a name="line2259"></a>2259               options[:readonly] = scoped_readonly
</span><span class="marked0"><a name="line2260"></a>2260             elsif !options[:joins].blank? &amp;&amp; !options[:select]
</span><span class="uncovered1"><a name="line2261"></a>2261               options[:readonly] = true
</span><span class="uncovered0"><a name="line2262"></a>2262             end
</span><span class="uncovered1"><a name="line2263"></a>2263           end
</span><span class="marked0"><a name="line2264"></a>2264         end
</span><span class="inferred1"><a name="line2265"></a>2265 
</span><span class="marked0"><a name="line2266"></a>2266         def encode_quoted_value(value) #:nodoc:
</span><span class="uncovered1"><a name="line2267"></a>2267           quoted_value = connection.quote(value)
</span><span class="uncovered0"><a name="line2268"></a>2268           quoted_value = &quot;'#{quoted_value[1..-2].gsub(/\'/, &quot;\\\\'&quot;)}'&quot; if quoted_value.include?(&quot;\\\'&quot;) # (for ruby mode) &quot;
</span><span class="uncovered1"><a name="line2269"></a>2269           quoted_value
</span><span class="uncovered0"><a name="line2270"></a>2270         end
</span><span class="uncovered1"><a name="line2271"></a>2271     end
</span><span class="inferred0"><a name="line2272"></a>2272 
</span><span class="marked1"><a name="line2273"></a>2273     public
</span><span class="inferred0"><a name="line2274"></a>2274       # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with
</span><span class="inferred1"><a name="line2275"></a>2275       # attributes but not yet saved (pass a hash with key names matching the associated table column names).
</span><span class="inferred0"><a name="line2276"></a>2276       # In both instances, valid attribute keys are determined by the column names of the associated table --
</span><span class="inferred1"><a name="line2277"></a>2277       # hence you can't have attributes that aren't part of the table columns.
</span><span class="marked0"><a name="line2278"></a>2278       def initialize(attributes = nil)
</span><span class="marked1"><a name="line2279"></a>2279         @attributes = attributes_from_column_definition
</span><span class="marked0"><a name="line2280"></a>2280         @attributes_cache = {}
</span><span class="marked1"><a name="line2281"></a>2281         @new_record = true
</span><span class="marked0"><a name="line2282"></a>2282         ensure_proper_type
</span><span class="marked1"><a name="line2283"></a>2283         self.attributes = attributes unless attributes.nil?
</span><span class="marked0"><a name="line2284"></a>2284         self.class.send(:scope, :create).each { |att,value| self.send(&quot;#{att}=&quot;, value) } if self.class.send(:scoped?, :create)
</span><span class="marked1"><a name="line2285"></a>2285         result = yield self if block_given?
</span><span class="marked0"><a name="line2286"></a>2286         callback(:after_initialize) if respond_to_without_attributes?(:after_initialize)
</span><span class="marked1"><a name="line2287"></a>2287         result
</span><span class="inferred0"><a name="line2288"></a>2288       end
</span><span class="inferred1"><a name="line2289"></a>2289 
</span><span class="inferred0"><a name="line2290"></a>2290       # A model instance's primary key is always available as model.id
</span><span class="inferred1"><a name="line2291"></a>2291       # whether you name it the default 'id' or set it to something else.
</span><span class="marked0"><a name="line2292"></a>2292       def id
</span><span class="marked1"><a name="line2293"></a>2293         attr_name = self.class.primary_key
</span><span class="marked0"><a name="line2294"></a>2294         column = column_for_attribute(attr_name)
</span><span class="inferred1"><a name="line2295"></a>2295 
</span><span class="marked0"><a name="line2296"></a>2296         self.class.send(:define_read_method, :id, attr_name, column)
</span><span class="inferred1"><a name="line2297"></a>2297         # now that the method exists, call it
</span><span class="marked0"><a name="line2298"></a>2298         self.send attr_name.to_sym
</span><span class="inferred1"><a name="line2299"></a>2299 
</span><span class="inferred0"><a name="line2300"></a>2300       end
</span><span class="inferred1"><a name="line2301"></a>2301 
</span><span class="inferred0"><a name="line2302"></a>2302       # Returns a String, which Action Pack uses for constructing an URL to this
</span><span class="inferred1"><a name="line2303"></a>2303       # object. The default implementation returns this record's id as a String,
</span><span class="inferred0"><a name="line2304"></a>2304       # or nil if this record's unsaved.
</span><span class="inferred1"><a name="line2305"></a>2305       #
</span><span class="inferred0"><a name="line2306"></a>2306       # For example, suppose that you have a Users model, and that you have a
</span><span class="inferred1"><a name="line2307"></a>2307       # &lt;tt&gt;map.resources :users&lt;/tt&gt; route. Normally, +users_path+ will
</span><span class="inferred0"><a name="line2308"></a>2308       # construct an URI with the user object's 'id' in it:
</span><span class="inferred1"><a name="line2309"></a>2309       #
</span><span class="inferred0"><a name="line2310"></a>2310       #   user = User.find_by_name('Phusion')
</span><span class="inferred1"><a name="line2311"></a>2311       #   user_path(path)  # =&gt; &quot;/users/1&quot;
</span><span class="inferred0"><a name="line2312"></a>2312       #
</span><span class="inferred1"><a name="line2313"></a>2313       # You can override +to_param+ in your model to make +users_path+ construct
</span><span class="inferred0"><a name="line2314"></a>2314       # an URI using the user's name instead of the user's id:
</span><span class="inferred1"><a name="line2315"></a>2315       #
</span><span class="inferred0"><a name="line2316"></a>2316       #   class User &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line2317"></a>2317       #     def to_param  # overridden
</span><span class="inferred0"><a name="line2318"></a>2318       #       name
</span><span class="inferred1"><a name="line2319"></a>2319       #     end
</span><span class="inferred0"><a name="line2320"></a>2320       #   end
</span><span class="inferred1"><a name="line2321"></a>2321       #   
</span><span class="inferred0"><a name="line2322"></a>2322       #   user = User.find_by_name('Phusion')
</span><span class="inferred1"><a name="line2323"></a>2323       #   user_path(path)  # =&gt; &quot;/users/Phusion&quot;
</span><span class="marked0"><a name="line2324"></a>2324       def to_param
</span><span class="uncovered1"><a name="line2325"></a>2325         # We can't use alias_method here, because method 'id' optimizes itself on the fly.
</span><span class="uncovered0"><a name="line2326"></a>2326         (id = self.id) ? id.to_s : nil # Be sure to stringify the id for routes
</span><span class="uncovered1"><a name="line2327"></a>2327       end
</span><span class="inferred0"><a name="line2328"></a>2328 
</span><span class="inferred1"><a name="line2329"></a>2329       # Returns a cache key that can be used to identify this record.
</span><span class="inferred0"><a name="line2330"></a>2330       #
</span><span class="inferred1"><a name="line2331"></a>2331       # ==== Examples
</span><span class="inferred0"><a name="line2332"></a>2332       #
</span><span class="inferred1"><a name="line2333"></a>2333       #   Product.new.cache_key     # =&gt; &quot;products/new&quot;
</span><span class="inferred0"><a name="line2334"></a>2334       #   Product.find(5).cache_key # =&gt; &quot;products/5&quot; (updated_at not available)
</span><span class="inferred1"><a name="line2335"></a>2335       #   Person.find(5).cache_key  # =&gt; &quot;people/5-20071224150000&quot; (updated_at available)
</span><span class="marked0"><a name="line2336"></a>2336       def cache_key
</span><span class="uncovered1"><a name="line2337"></a>2337         case
</span><span class="uncovered0"><a name="line2338"></a>2338         when new_record?
</span><span class="uncovered1"><a name="line2339"></a>2339           &quot;#{self.class.model_name.cache_key}/new&quot;
</span><span class="uncovered0"><a name="line2340"></a>2340         when timestamp = self[:updated_at]
</span><span class="uncovered1"><a name="line2341"></a>2341           &quot;#{self.class.model_name.cache_key}/#{id}-#{timestamp.to_s(:number)}&quot;
</span><span class="uncovered0"><a name="line2342"></a>2342         else
</span><span class="uncovered1"><a name="line2343"></a>2343           &quot;#{self.class.model_name.cache_key}/#{id}&quot;
</span><span class="uncovered0"><a name="line2344"></a>2344         end
</span><span class="uncovered1"><a name="line2345"></a>2345       end
</span><span class="inferred0"><a name="line2346"></a>2346 
</span><span class="marked1"><a name="line2347"></a>2347       def id_before_type_cast #:nodoc:
</span><span class="uncovered0"><a name="line2348"></a>2348         read_attribute_before_type_cast(self.class.primary_key)
</span><span class="uncovered1"><a name="line2349"></a>2349       end
</span><span class="inferred0"><a name="line2350"></a>2350 
</span><span class="marked1"><a name="line2351"></a>2351       def quoted_id #:nodoc:
</span><span class="uncovered0"><a name="line2352"></a>2352         quote_value(id, column_for_attribute(self.class.primary_key))
</span><span class="uncovered1"><a name="line2353"></a>2353       end
</span><span class="inferred0"><a name="line2354"></a>2354 
</span><span class="inferred1"><a name="line2355"></a>2355       # Sets the primary ID.
</span><span class="marked0"><a name="line2356"></a>2356       def id=(value)
</span><span class="uncovered1"><a name="line2357"></a>2357         write_attribute(self.class.primary_key, value)
</span><span class="uncovered0"><a name="line2358"></a>2358       end
</span><span class="inferred1"><a name="line2359"></a>2359 
</span><span class="inferred0"><a name="line2360"></a>2360       # Returns true if this object hasn't been saved yet -- that is, a record for the object doesn't exist yet.
</span><span class="marked1"><a name="line2361"></a>2361       def new_record?
</span><span class="marked0"><a name="line2362"></a>2362         defined?(@new_record) &amp;&amp; @new_record
</span><span class="marked1"><a name="line2363"></a>2363       end
</span><span class="inferred0"><a name="line2364"></a>2364 
</span><span class="inferred1"><a name="line2365"></a>2365       # :call-seq:
</span><span class="inferred0"><a name="line2366"></a>2366       #   save(perform_validation = true)
</span><span class="inferred1"><a name="line2367"></a>2367       #
</span><span class="inferred0"><a name="line2368"></a>2368       # Saves the model.
</span><span class="inferred1"><a name="line2369"></a>2369       #
</span><span class="inferred0"><a name="line2370"></a>2370       # If the model is new a record gets created in the database, otherwise
</span><span class="inferred1"><a name="line2371"></a>2371       # the existing record gets updated.
</span><span class="inferred0"><a name="line2372"></a>2372       #
</span><span class="inferred1"><a name="line2373"></a>2373       # If +perform_validation+ is true validations run. If any of them fail
</span><span class="inferred0"><a name="line2374"></a>2374       # the action is cancelled and +save+ returns +false+. If the flag is
</span><span class="inferred1"><a name="line2375"></a>2375       # false validations are bypassed altogether. See
</span><span class="inferred0"><a name="line2376"></a>2376       # ActiveRecord::Validations for more information. 
</span><span class="inferred1"><a name="line2377"></a>2377       #
</span><span class="inferred0"><a name="line2378"></a>2378       # There's a series of callbacks associated with +save+. If any of the
</span><span class="inferred1"><a name="line2379"></a>2379       # &lt;tt&gt;before_*&lt;/tt&gt; callbacks return +false+ the action is cancelled and
</span><span class="inferred0"><a name="line2380"></a>2380       # +save+ returns +false+. See ActiveRecord::Callbacks for further
</span><span class="inferred1"><a name="line2381"></a>2381       # details. 
</span><span class="marked0"><a name="line2382"></a>2382       def save
</span><span class="uncovered1"><a name="line2383"></a>2383         create_or_update
</span><span class="uncovered0"><a name="line2384"></a>2384       end
</span><span class="inferred1"><a name="line2385"></a>2385 
</span><span class="inferred0"><a name="line2386"></a>2386       # Saves the model.
</span><span class="inferred1"><a name="line2387"></a>2387       #
</span><span class="inferred0"><a name="line2388"></a>2388       # If the model is new a record gets created in the database, otherwise
</span><span class="inferred1"><a name="line2389"></a>2389       # the existing record gets updated.
</span><span class="inferred0"><a name="line2390"></a>2390       #
</span><span class="inferred1"><a name="line2391"></a>2391       # With &lt;tt&gt;save!&lt;/tt&gt; validations always run. If any of them fail
</span><span class="inferred0"><a name="line2392"></a>2392       # ActiveRecord::RecordInvalid gets raised. See ActiveRecord::Validations
</span><span class="inferred1"><a name="line2393"></a>2393       # for more information. 
</span><span class="inferred0"><a name="line2394"></a>2394       #
</span><span class="inferred1"><a name="line2395"></a>2395       # There's a series of callbacks associated with &lt;tt&gt;save!&lt;/tt&gt;. If any of
</span><span class="inferred0"><a name="line2396"></a>2396       # the &lt;tt&gt;before_*&lt;/tt&gt; callbacks return +false+ the action is cancelled
</span><span class="inferred1"><a name="line2397"></a>2397       # and &lt;tt&gt;save!&lt;/tt&gt; raises ActiveRecord::RecordNotSaved. See
</span><span class="inferred0"><a name="line2398"></a>2398       # ActiveRecord::Callbacks for further details. 
</span><span class="marked1"><a name="line2399"></a>2399       def save!
</span><span class="marked0"><a name="line2400"></a>2400         create_or_update || raise(RecordNotSaved)
</span><span class="marked1"><a name="line2401"></a>2401       end
</span><span class="inferred0"><a name="line2402"></a>2402 
</span><span class="inferred1"><a name="line2403"></a>2403       # Deletes the record in the database and freezes this instance to reflect that no changes should
</span><span class="inferred0"><a name="line2404"></a>2404       # be made (since they can't be persisted).
</span><span class="inferred1"><a name="line2405"></a>2405       #
</span><span class="inferred0"><a name="line2406"></a>2406       # Unlike #destroy, this method doesn't run any +before_delete+ and +after_delete+
</span><span class="inferred1"><a name="line2407"></a>2407       # callbacks, nor will it enforce any association +:dependent+ rules.
</span><span class="inferred0"><a name="line2408"></a>2408       # 
</span><span class="inferred1"><a name="line2409"></a>2409       # In addition to deleting this record, any defined +before_delete+ and +after_delete+
</span><span class="inferred0"><a name="line2410"></a>2410       # callbacks are run, and +:dependent+ rules defined on associations are run.
</span><span class="marked1"><a name="line2411"></a>2411       def delete
</span><span class="uncovered0"><a name="line2412"></a>2412         self.class.delete(id) unless new_record?
</span><span class="uncovered1"><a name="line2413"></a>2413         freeze
</span><span class="uncovered0"><a name="line2414"></a>2414       end
</span><span class="inferred1"><a name="line2415"></a>2415 
</span><span class="inferred0"><a name="line2416"></a>2416       # Deletes the record in the database and freezes this instance to reflect that no changes should
</span><span class="inferred1"><a name="line2417"></a>2417       # be made (since they can't be persisted).
</span><span class="marked0"><a name="line2418"></a>2418       def destroy
</span><span class="uncovered1"><a name="line2419"></a>2419         unless new_record?
</span><span class="uncovered0"><a name="line2420"></a>2420           connection.delete(
</span><span class="uncovered1"><a name="line2421"></a>2421             &quot;DELETE FROM #{self.class.quoted_table_name} &quot; +
</span><span class="uncovered0"><a name="line2422"></a>2422             &quot;WHERE #{connection.quote_column_name(self.class.primary_key)} = #{quoted_id}&quot;,
</span><span class="uncovered1"><a name="line2423"></a>2423             &quot;#{self.class.name} Destroy&quot;
</span><span class="uncovered0"><a name="line2424"></a>2424           )
</span><span class="uncovered1"><a name="line2425"></a>2425         end
</span><span class="uncovered0"><a name="line2426"></a>2426 
</span><span class="uncovered1"><a name="line2427"></a>2427         freeze
</span><span class="uncovered0"><a name="line2428"></a>2428       end
</span><span class="inferred1"><a name="line2429"></a>2429 
</span><span class="inferred0"><a name="line2430"></a>2430       # Returns a clone of the record that hasn't been assigned an id yet and
</span><span class="inferred1"><a name="line2431"></a>2431       # is treated as a new record.  Note that this is a &quot;shallow&quot; clone:
</span><span class="inferred0"><a name="line2432"></a>2432       # it copies the object's attributes only, not its associations.
</span><span class="inferred1"><a name="line2433"></a>2433       # The extent of a &quot;deep&quot; clone is application-specific and is therefore
</span><span class="inferred0"><a name="line2434"></a>2434       # left to the application to implement according to its need.
</span><span class="marked1"><a name="line2435"></a>2435       def clone
</span><span class="uncovered0"><a name="line2436"></a>2436         attrs = clone_attributes(:read_attribute_before_type_cast)
</span><span class="uncovered1"><a name="line2437"></a>2437         attrs.delete(self.class.primary_key)
</span><span class="uncovered0"><a name="line2438"></a>2438         record = self.class.new
</span><span class="uncovered1"><a name="line2439"></a>2439         record.send :instance_variable_set, '@attributes', attrs
</span><span class="uncovered0"><a name="line2440"></a>2440         record
</span><span class="uncovered1"><a name="line2441"></a>2441       end
</span><span class="inferred0"><a name="line2442"></a>2442 
</span><span class="inferred1"><a name="line2443"></a>2443       # Returns an instance of the specified +klass+ with the attributes of the current record. This is mostly useful in relation to
</span><span class="inferred0"><a name="line2444"></a>2444       # single-table inheritance structures where you want a subclass to appear as the superclass. This can be used along with record
</span><span class="inferred1"><a name="line2445"></a>2445       # identification in Action Pack to allow, say, &lt;tt&gt;Client &lt; Company&lt;/tt&gt; to do something like render &lt;tt&gt;:partial =&gt; @client.becomes(Company)&lt;/tt&gt;
</span><span class="inferred0"><a name="line2446"></a>2446       # to render that instance using the companies/company partial instead of clients/client.
</span><span class="inferred1"><a name="line2447"></a>2447       #
</span><span class="inferred0"><a name="line2448"></a>2448       # Note: The new instance will share a link to the same attributes as the original class. So any change to the attributes in either
</span><span class="inferred1"><a name="line2449"></a>2449       # instance will affect the other.
</span><span class="marked0"><a name="line2450"></a>2450       def becomes(klass)
</span><span class="uncovered1"><a name="line2451"></a>2451         returning klass.new do |became|
</span><span class="uncovered0"><a name="line2452"></a>2452           became.instance_variable_set(&quot;@attributes&quot;, @attributes)
</span><span class="uncovered1"><a name="line2453"></a>2453           became.instance_variable_set(&quot;@attributes_cache&quot;, @attributes_cache)
</span><span class="uncovered0"><a name="line2454"></a>2454           became.instance_variable_set(&quot;@new_record&quot;, new_record?)
</span><span class="uncovered1"><a name="line2455"></a>2455         end
</span><span class="uncovered0"><a name="line2456"></a>2456       end
</span><span class="inferred1"><a name="line2457"></a>2457 
</span><span class="inferred0"><a name="line2458"></a>2458       # Updates a single attribute and saves the record without going through the normal validation procedure.
</span><span class="inferred1"><a name="line2459"></a>2459       # This is especially useful for boolean flags on existing records. The regular +update_attribute+ method
</span><span class="inferred0"><a name="line2460"></a>2460       # in Base is replaced with this when the validations module is mixed in, which it is by default.
</span><span class="marked1"><a name="line2461"></a>2461       def update_attribute(name, value)
</span><span class="uncovered0"><a name="line2462"></a>2462         send(name.to_s + '=', value)
</span><span class="uncovered1"><a name="line2463"></a>2463         save(false)
</span><span class="uncovered0"><a name="line2464"></a>2464       end
</span><span class="inferred1"><a name="line2465"></a>2465 
</span><span class="inferred0"><a name="line2466"></a>2466       # Updates all the attributes from the passed-in Hash and saves the record. If the object is invalid, the saving will
</span><span class="inferred1"><a name="line2467"></a>2467       # fail and false will be returned.
</span><span class="marked0"><a name="line2468"></a>2468       def update_attributes(attributes)
</span><span class="uncovered1"><a name="line2469"></a>2469         self.attributes = attributes
</span><span class="uncovered0"><a name="line2470"></a>2470         save
</span><span class="uncovered1"><a name="line2471"></a>2471       end
</span><span class="inferred0"><a name="line2472"></a>2472 
</span><span class="inferred1"><a name="line2473"></a>2473       # Updates an object just like Base.update_attributes but calls save! instead of save so an exception is raised if the record is invalid.
</span><span class="marked0"><a name="line2474"></a>2474       def update_attributes!(attributes)
</span><span class="uncovered1"><a name="line2475"></a>2475         self.attributes = attributes
</span><span class="uncovered0"><a name="line2476"></a>2476         save!
</span><span class="uncovered1"><a name="line2477"></a>2477       end
</span><span class="inferred0"><a name="line2478"></a>2478 
</span><span class="inferred1"><a name="line2479"></a>2479       # Initializes +attribute+ to zero if +nil+ and adds the value passed as +by+ (default is 1).
</span><span class="inferred0"><a name="line2480"></a>2480       # The increment is performed directly on the underlying attribute, no setter is invoked.
</span><span class="inferred1"><a name="line2481"></a>2481       # Only makes sense for number-based attributes. Returns +self+.
</span><span class="marked0"><a name="line2482"></a>2482       def increment(attribute, by = 1)
</span><span class="uncovered1"><a name="line2483"></a>2483         self[attribute] ||= 0
</span><span class="uncovered0"><a name="line2484"></a>2484         self[attribute] += by
</span><span class="uncovered1"><a name="line2485"></a>2485         self
</span><span class="uncovered0"><a name="line2486"></a>2486       end
</span><span class="inferred1"><a name="line2487"></a>2487 
</span><span class="inferred0"><a name="line2488"></a>2488       # Wrapper around +increment+ that saves the record. This method differs from
</span><span class="inferred1"><a name="line2489"></a>2489       # its non-bang version in that it passes through the attribute setter.
</span><span class="inferred0"><a name="line2490"></a>2490       # Saving is not subjected to validation checks. Returns +true+ if the
</span><span class="inferred1"><a name="line2491"></a>2491       # record could be saved.
</span><span class="marked0"><a name="line2492"></a>2492       def increment!(attribute, by = 1)
</span><span class="uncovered1"><a name="line2493"></a>2493         increment(attribute, by).update_attribute(attribute, self[attribute])
</span><span class="uncovered0"><a name="line2494"></a>2494       end
</span><span class="inferred1"><a name="line2495"></a>2495 
</span><span class="inferred0"><a name="line2496"></a>2496       # Initializes +attribute+ to zero if +nil+ and subtracts the value passed as +by+ (default is 1).
</span><span class="inferred1"><a name="line2497"></a>2497       # The decrement is performed directly on the underlying attribute, no setter is invoked.
</span><span class="inferred0"><a name="line2498"></a>2498       # Only makes sense for number-based attributes. Returns +self+.
</span><span class="marked1"><a name="line2499"></a>2499       def decrement(attribute, by = 1)
</span><span class="uncovered0"><a name="line2500"></a>2500         self[attribute] ||= 0
</span><span class="uncovered1"><a name="line2501"></a>2501         self[attribute] -= by
</span><span class="uncovered0"><a name="line2502"></a>2502         self
</span><span class="uncovered1"><a name="line2503"></a>2503       end
</span><span class="inferred0"><a name="line2504"></a>2504 
</span><span class="inferred1"><a name="line2505"></a>2505       # Wrapper around +decrement+ that saves the record. This method differs from
</span><span class="inferred0"><a name="line2506"></a>2506       # its non-bang version in that it passes through the attribute setter.
</span><span class="inferred1"><a name="line2507"></a>2507       # Saving is not subjected to validation checks. Returns +true+ if the
</span><span class="inferred0"><a name="line2508"></a>2508       # record could be saved.
</span><span class="marked1"><a name="line2509"></a>2509       def decrement!(attribute, by = 1)
</span><span class="uncovered0"><a name="line2510"></a>2510         decrement(attribute, by).update_attribute(attribute, self[attribute])
</span><span class="uncovered1"><a name="line2511"></a>2511       end
</span><span class="inferred0"><a name="line2512"></a>2512 
</span><span class="inferred1"><a name="line2513"></a>2513       # Assigns to +attribute+ the boolean opposite of &lt;tt&gt;attribute?&lt;/tt&gt;. So
</span><span class="inferred0"><a name="line2514"></a>2514       # if the predicate returns +true+ the attribute will become +false+. This
</span><span class="inferred1"><a name="line2515"></a>2515       # method toggles directly the underlying value without calling any setter.
</span><span class="inferred0"><a name="line2516"></a>2516       # Returns +self+.
</span><span class="marked1"><a name="line2517"></a>2517       def toggle(attribute)
</span><span class="uncovered0"><a name="line2518"></a>2518         self[attribute] = !send(&quot;#{attribute}?&quot;)
</span><span class="uncovered1"><a name="line2519"></a>2519         self
</span><span class="uncovered0"><a name="line2520"></a>2520       end
</span><span class="inferred1"><a name="line2521"></a>2521 
</span><span class="inferred0"><a name="line2522"></a>2522       # Wrapper around +toggle+ that saves the record. This method differs from
</span><span class="inferred1"><a name="line2523"></a>2523       # its non-bang version in that it passes through the attribute setter.
</span><span class="inferred0"><a name="line2524"></a>2524       # Saving is not subjected to validation checks. Returns +true+ if the
</span><span class="inferred1"><a name="line2525"></a>2525       # record could be saved.
</span><span class="marked0"><a name="line2526"></a>2526       def toggle!(attribute)
</span><span class="uncovered1"><a name="line2527"></a>2527         toggle(attribute).update_attribute(attribute, self[attribute])
</span><span class="uncovered0"><a name="line2528"></a>2528       end
</span><span class="inferred1"><a name="line2529"></a>2529 
</span><span class="inferred0"><a name="line2530"></a>2530       # Reloads the attributes of this object from the database.
</span><span class="inferred1"><a name="line2531"></a>2531       # The optional options argument is passed to find when reloading so you
</span><span class="inferred0"><a name="line2532"></a>2532       # may do e.g. record.reload(:lock =&gt; true) to reload the same record with
</span><span class="inferred1"><a name="line2533"></a>2533       # an exclusive row lock.
</span><span class="marked0"><a name="line2534"></a>2534       def reload(options = nil)
</span><span class="uncovered1"><a name="line2535"></a>2535         clear_aggregation_cache
</span><span class="uncovered0"><a name="line2536"></a>2536         clear_association_cache
</span><span class="uncovered1"><a name="line2537"></a>2537         @attributes.update(self.class.find(self.id, options).instance_variable_get('@attributes'))
</span><span class="uncovered0"><a name="line2538"></a>2538         @attributes_cache = {}
</span><span class="uncovered1"><a name="line2539"></a>2539         self
</span><span class="uncovered0"><a name="line2540"></a>2540       end
</span><span class="inferred1"><a name="line2541"></a>2541 
</span><span class="inferred0"><a name="line2542"></a>2542       # Returns the value of the attribute identified by &lt;tt&gt;attr_name&lt;/tt&gt; after it has been typecast (for example,
</span><span class="inferred1"><a name="line2543"></a>2543       # &quot;2004-12-12&quot; in a data column is cast to a date object, like Date.new(2004, 12, 12)).
</span><span class="inferred0"><a name="line2544"></a>2544       # (Alias for the protected read_attribute method).
</span><span class="marked1"><a name="line2545"></a>2545       def [](attr_name)
</span><span class="uncovered0"><a name="line2546"></a>2546         read_attribute(attr_name)
</span><span class="uncovered1"><a name="line2547"></a>2547       end
</span><span class="inferred0"><a name="line2548"></a>2548 
</span><span class="inferred1"><a name="line2549"></a>2549       # Updates the attribute identified by &lt;tt&gt;attr_name&lt;/tt&gt; with the specified +value+.
</span><span class="inferred0"><a name="line2550"></a>2550       # (Alias for the protected write_attribute method).
</span><span class="marked1"><a name="line2551"></a>2551       def []=(attr_name, value)
</span><span class="uncovered0"><a name="line2552"></a>2552         write_attribute(attr_name, value)
</span><span class="uncovered1"><a name="line2553"></a>2553       end
</span><span class="inferred0"><a name="line2554"></a>2554 
</span><span class="inferred1"><a name="line2555"></a>2555       # Allows you to set all the attributes at once by passing in a hash with keys
</span><span class="inferred0"><a name="line2556"></a>2556       # matching the attribute names (which again matches the column names).
</span><span class="inferred1"><a name="line2557"></a>2557       #
</span><span class="inferred0"><a name="line2558"></a>2558       # If +guard_protected_attributes+ is true (the default), then sensitive
</span><span class="inferred1"><a name="line2559"></a>2559       # attributes can be protected from this form of mass-assignment by using
</span><span class="inferred0"><a name="line2560"></a>2560       # the +attr_protected+ macro. Or you can alternatively specify which
</span><span class="inferred1"><a name="line2561"></a>2561       # attributes *can* be accessed with the +attr_accessible+ macro. Then all the
</span><span class="inferred0"><a name="line2562"></a>2562       # attributes not included in that won't be allowed to be mass-assigned.
</span><span class="inferred1"><a name="line2563"></a>2563       #
</span><span class="inferred0"><a name="line2564"></a>2564       #   class User &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line2565"></a>2565       #     attr_protected :is_admin
</span><span class="inferred0"><a name="line2566"></a>2566       #   end
</span><span class="inferred1"><a name="line2567"></a>2567       #   
</span><span class="inferred0"><a name="line2568"></a>2568       #   user = User.new
</span><span class="inferred1"><a name="line2569"></a>2569       #   user.attributes = { :username =&gt; 'Phusion', :is_admin =&gt; true }
</span><span class="inferred0"><a name="line2570"></a>2570       #   user.username   # =&gt; &quot;Phusion&quot;
</span><span class="inferred1"><a name="line2571"></a>2571       #   user.is_admin?  # =&gt; false
</span><span class="inferred0"><a name="line2572"></a>2572       #   
</span><span class="inferred1"><a name="line2573"></a>2573       #   user.send(:attributes=, { :username =&gt; 'Phusion', :is_admin =&gt; true }, false)
</span><span class="inferred0"><a name="line2574"></a>2574       #   user.is_admin?  # =&gt; true
</span><span class="marked1"><a name="line2575"></a>2575       def attributes=(new_attributes, guard_protected_attributes = true)
</span><span class="marked0"><a name="line2576"></a>2576         return if new_attributes.nil?
</span><span class="marked1"><a name="line2577"></a>2577         attributes = new_attributes.dup
</span><span class="marked0"><a name="line2578"></a>2578         attributes.stringify_keys!
</span><span class="inferred1"><a name="line2579"></a>2579 
</span><span class="marked0"><a name="line2580"></a>2580         multi_parameter_attributes = []
</span><span class="marked1"><a name="line2581"></a>2581         attributes = remove_attributes_protected_from_mass_assignment(attributes) if guard_protected_attributes
</span><span class="inferred0"><a name="line2582"></a>2582 
</span><span class="marked1"><a name="line2583"></a>2583         attributes.each do |k, v|
</span><span class="marked0"><a name="line2584"></a>2584           if k.include?(&quot;(&quot;)
</span><span class="inferred1"><a name="line2585"></a>2585             multi_parameter_attributes &lt;&lt; [ k, v ]
</span><span class="inferred0"><a name="line2586"></a>2586           else
</span><span class="marked1"><a name="line2587"></a>2587             respond_to?(:&quot;#{k}=&quot;) ? send(:&quot;#{k}=&quot;, v) : raise(UnknownAttributeError, &quot;unknown attribute: #{k}&quot;)
</span><span class="inferred0"><a name="line2588"></a>2588           end
</span><span class="inferred1"><a name="line2589"></a>2589         end
</span><span class="inferred0"><a name="line2590"></a>2590 
</span><span class="marked1"><a name="line2591"></a>2591         assign_multiparameter_attributes(multi_parameter_attributes)
</span><span class="inferred0"><a name="line2592"></a>2592       end
</span><span class="inferred1"><a name="line2593"></a>2593 
</span><span class="inferred0"><a name="line2594"></a>2594 
</span><span class="inferred1"><a name="line2595"></a>2595       # Returns a hash of all the attributes with their names as keys and the values of the attributes as values.
</span><span class="marked0"><a name="line2596"></a>2596       def attributes
</span><span class="marked1"><a name="line2597"></a>2597         self.attribute_names.inject({}) do |attrs, name|
</span><span class="marked0"><a name="line2598"></a>2598           attrs[name] = read_attribute(name)
</span><span class="marked1"><a name="line2599"></a>2599           attrs
</span><span class="inferred0"><a name="line2600"></a>2600         end
</span><span class="marked1"><a name="line2601"></a>2601       end
</span><span class="inferred0"><a name="line2602"></a>2602 
</span><span class="inferred1"><a name="line2603"></a>2603       # Returns a hash of attributes before typecasting and deserialization.
</span><span class="marked0"><a name="line2604"></a>2604       def attributes_before_type_cast
</span><span class="uncovered1"><a name="line2605"></a>2605         self.attribute_names.inject({}) do |attrs, name|
</span><span class="uncovered0"><a name="line2606"></a>2606           attrs[name] = read_attribute_before_type_cast(name)
</span><span class="uncovered1"><a name="line2607"></a>2607           attrs
</span><span class="uncovered0"><a name="line2608"></a>2608         end
</span><span class="uncovered1"><a name="line2609"></a>2609       end
</span><span class="inferred0"><a name="line2610"></a>2610 
</span><span class="inferred1"><a name="line2611"></a>2611       # Format attributes nicely for inspect.
</span><span class="marked0"><a name="line2612"></a>2612       def attribute_for_inspect(attr_name)
</span><span class="uncovered1"><a name="line2613"></a>2613         value = read_attribute(attr_name)
</span><span class="uncovered0"><a name="line2614"></a>2614 
</span><span class="uncovered1"><a name="line2615"></a>2615         if value.is_a?(String) &amp;&amp; value.length &gt; 50
</span><span class="uncovered0"><a name="line2616"></a>2616           &quot;#{value[0..50]}...&quot;.inspect
</span><span class="uncovered1"><a name="line2617"></a>2617         elsif value.is_a?(Date) || value.is_a?(Time)
</span><span class="uncovered0"><a name="line2618"></a>2618           %(&quot;#{value.to_s(:db)}&quot;)
</span><span class="uncovered1"><a name="line2619"></a>2619         else
</span><span class="uncovered0"><a name="line2620"></a>2620           value.inspect
</span><span class="uncovered1"><a name="line2621"></a>2621         end
</span><span class="uncovered0"><a name="line2622"></a>2622       end
</span><span class="inferred1"><a name="line2623"></a>2623 
</span><span class="inferred0"><a name="line2624"></a>2624       # Returns true if the specified +attribute+ has been set by the user or by a database load and is neither
</span><span class="inferred1"><a name="line2625"></a>2625       # nil nor empty? (the latter only applies to objects that respond to empty?, most notably Strings).
</span><span class="marked0"><a name="line2626"></a>2626       def attribute_present?(attribute)
</span><span class="uncovered1"><a name="line2627"></a>2627         value = read_attribute(attribute)
</span><span class="uncovered0"><a name="line2628"></a>2628         !value.blank?
</span><span class="uncovered1"><a name="line2629"></a>2629       end
</span><span class="inferred0"><a name="line2630"></a>2630 
</span><span class="inferred1"><a name="line2631"></a>2631       # Returns true if the given attribute is in the attributes hash
</span><span class="marked0"><a name="line2632"></a>2632       def has_attribute?(attr_name)
</span><span class="marked1"><a name="line2633"></a>2633         @attributes.has_key?(attr_name.to_s)
</span><span class="marked0"><a name="line2634"></a>2634       end
</span><span class="inferred1"><a name="line2635"></a>2635 
</span><span class="inferred0"><a name="line2636"></a>2636       # Returns an array of names for the attributes available on this object sorted alphabetically.
</span><span class="marked1"><a name="line2637"></a>2637       def attribute_names
</span><span class="marked0"><a name="line2638"></a>2638         @attributes.keys.sort
</span><span class="marked1"><a name="line2639"></a>2639       end
</span><span class="inferred0"><a name="line2640"></a>2640 
</span><span class="inferred1"><a name="line2641"></a>2641       # Returns the column object for the named attribute.
</span><span class="marked0"><a name="line2642"></a>2642       def column_for_attribute(name)
</span><span class="marked1"><a name="line2643"></a>2643         self.class.columns_hash[name.to_s]
</span><span class="marked0"><a name="line2644"></a>2644       end
</span><span class="inferred1"><a name="line2645"></a>2645 
</span><span class="inferred0"><a name="line2646"></a>2646       # Returns true if the +comparison_object+ is the same object, or is of the same type and has the same id.
</span><span class="marked1"><a name="line2647"></a>2647       def ==(comparison_object)
</span><span class="inferred0"><a name="line2648"></a>2648         comparison_object.equal?(self) ||
</span><span class="inferred1"><a name="line2649"></a>2649           (comparison_object.instance_of?(self.class) &amp;&amp;
</span><span class="marked0"><a name="line2650"></a>2650             comparison_object.id == id &amp;&amp;
</span><span class="marked1"><a name="line2651"></a>2651             !comparison_object.new_record?)
</span><span class="marked0"><a name="line2652"></a>2652       end
</span><span class="inferred1"><a name="line2653"></a>2653 
</span><span class="inferred0"><a name="line2654"></a>2654       # Delegates to ==
</span><span class="marked1"><a name="line2655"></a>2655       def eql?(comparison_object)
</span><span class="uncovered0"><a name="line2656"></a>2656         self == (comparison_object)
</span><span class="uncovered1"><a name="line2657"></a>2657       end
</span><span class="inferred0"><a name="line2658"></a>2658 
</span><span class="inferred1"><a name="line2659"></a>2659       # Delegates to id in order to allow two records of the same type and id to work with something like:
</span><span class="inferred0"><a name="line2660"></a>2660       #   [ Person.find(1), Person.find(2), Person.find(3) ] &amp; [ Person.find(1), Person.find(4) ] # =&gt; [ Person.find(1) ]
</span><span class="marked1"><a name="line2661"></a>2661       def hash
</span><span class="uncovered0"><a name="line2662"></a>2662         id.hash
</span><span class="uncovered1"><a name="line2663"></a>2663       end
</span><span class="inferred0"><a name="line2664"></a>2664 
</span><span class="inferred1"><a name="line2665"></a>2665       # Freeze the attributes hash such that associations are still accessible, even on destroyed records.
</span><span class="marked0"><a name="line2666"></a>2666       def freeze
</span><span class="uncovered1"><a name="line2667"></a>2667         @attributes.freeze; self
</span><span class="uncovered0"><a name="line2668"></a>2668       end
</span><span class="inferred1"><a name="line2669"></a>2669 
</span><span class="inferred0"><a name="line2670"></a>2670       # Returns +true+ if the attributes hash has been frozen.
</span><span class="marked1"><a name="line2671"></a>2671       def frozen?
</span><span class="uncovered0"><a name="line2672"></a>2672         @attributes.frozen?
</span><span class="uncovered1"><a name="line2673"></a>2673       end
</span><span class="inferred0"><a name="line2674"></a>2674 
</span><span class="inferred1"><a name="line2675"></a>2675       # Returns +true+ if the record is read only. Records loaded through joins with piggy-back
</span><span class="inferred0"><a name="line2676"></a>2676       # attributes will be marked as read only since they cannot be saved.
</span><span class="marked1"><a name="line2677"></a>2677       def readonly?
</span><span class="marked0"><a name="line2678"></a>2678         defined?(@readonly) &amp;&amp; @readonly == true
</span><span class="marked1"><a name="line2679"></a>2679       end
</span><span class="inferred0"><a name="line2680"></a>2680 
</span><span class="inferred1"><a name="line2681"></a>2681       # Marks this record as read only.
</span><span class="marked0"><a name="line2682"></a>2682       def readonly!
</span><span class="uncovered1"><a name="line2683"></a>2683         @readonly = true
</span><span class="uncovered0"><a name="line2684"></a>2684       end
</span><span class="inferred1"><a name="line2685"></a>2685 
</span><span class="inferred0"><a name="line2686"></a>2686       # Returns the contents of the record as a nicely formatted string.
</span><span class="marked1"><a name="line2687"></a>2687       def inspect
</span><span class="uncovered0"><a name="line2688"></a>2688         attributes_as_nice_string = self.class.column_names.collect { |name|
</span><span class="uncovered1"><a name="line2689"></a>2689           if has_attribute?(name) || new_record?
</span><span class="uncovered0"><a name="line2690"></a>2690             &quot;#{name}: #{attribute_for_inspect(name)}&quot;
</span><span class="uncovered1"><a name="line2691"></a>2691           end
</span><span class="uncovered0"><a name="line2692"></a>2692         }.compact.join(&quot;, &quot;)
</span><span class="uncovered1"><a name="line2693"></a>2693         &quot;#&lt;#{self.class} #{attributes_as_nice_string}&gt;&quot;
</span><span class="uncovered0"><a name="line2694"></a>2694       end
</span><span class="inferred1"><a name="line2695"></a>2695 
</span><span class="marked0"><a name="line2696"></a>2696     private
</span><span class="marked1"><a name="line2697"></a>2697       def create_or_update
</span><span class="marked0"><a name="line2698"></a>2698         raise ReadOnlyRecord if readonly?
</span><span class="marked1"><a name="line2699"></a>2699         result = new_record? ? create : update
</span><span class="marked0"><a name="line2700"></a>2700         result != false
</span><span class="inferred1"><a name="line2701"></a>2701       end
</span><span class="inferred0"><a name="line2702"></a>2702 
</span><span class="inferred1"><a name="line2703"></a>2703       # Updates the associated record with values matching those of the instance attributes.
</span><span class="inferred0"><a name="line2704"></a>2704       # Returns the number of affected rows.
</span><span class="marked1"><a name="line2705"></a>2705       def update(attribute_names = @attributes.keys)
</span><span class="marked0"><a name="line2706"></a>2706         quoted_attributes = attributes_with_quotes(false, false, attribute_names)
</span><span class="marked1"><a name="line2707"></a>2707         return 0 if quoted_attributes.empty?
</span><span class="marked0"><a name="line2708"></a>2708         connection.update(
</span><span class="marked1"><a name="line2709"></a>2709           &quot;UPDATE #{self.class.quoted_table_name} &quot; +
</span><span class="marked0"><a name="line2710"></a>2710           &quot;SET #{quoted_comma_pair_list(connection, quoted_attributes)} &quot; +
</span><span class="marked1"><a name="line2711"></a>2711           &quot;WHERE #{connection.quote_column_name(self.class.primary_key)} = #{quote_value(id)}&quot;,
</span><span class="inferred0"><a name="line2712"></a>2712           &quot;#{self.class.name} Update&quot;
</span><span class="inferred1"><a name="line2713"></a>2713         )
</span><span class="inferred0"><a name="line2714"></a>2714       end
</span><span class="inferred1"><a name="line2715"></a>2715 
</span><span class="inferred0"><a name="line2716"></a>2716       # Creates a record with values matching those of the instance attributes
</span><span class="inferred1"><a name="line2717"></a>2717       # and returns its id.
</span><span class="marked0"><a name="line2718"></a>2718       def create
</span><span class="uncovered1"><a name="line2719"></a>2719         if self.id.nil? &amp;&amp; connection.prefetch_primary_key?(self.class.table_name)
</span><span class="uncovered0"><a name="line2720"></a>2720           self.id = connection.next_sequence_value(self.class.sequence_name)
</span><span class="uncovered1"><a name="line2721"></a>2721         end
</span><span class="uncovered0"><a name="line2722"></a>2722 
</span><span class="uncovered1"><a name="line2723"></a>2723         quoted_attributes = attributes_with_quotes
</span><span class="uncovered0"><a name="line2724"></a>2724 
</span><span class="uncovered1"><a name="line2725"></a>2725         statement = if quoted_attributes.empty?
</span><span class="uncovered0"><a name="line2726"></a>2726           connection.empty_insert_statement(self.class.table_name)
</span><span class="uncovered1"><a name="line2727"></a>2727         else
</span><span class="uncovered0"><a name="line2728"></a>2728           &quot;INSERT INTO #{self.class.quoted_table_name} &quot; +
</span><span class="uncovered1"><a name="line2729"></a>2729           &quot;(#{quoted_column_names.join(', ')}) &quot; +
</span><span class="uncovered0"><a name="line2730"></a>2730           &quot;VALUES(#{quoted_attributes.values.join(', ')})&quot;
</span><span class="uncovered1"><a name="line2731"></a>2731         end
</span><span class="uncovered0"><a name="line2732"></a>2732 
</span><span class="uncovered1"><a name="line2733"></a>2733         self.id = connection.insert(statement, &quot;#{self.class.name} Create&quot;,
</span><span class="uncovered0"><a name="line2734"></a>2734           self.class.primary_key, self.id, self.class.sequence_name)
</span><span class="uncovered1"><a name="line2735"></a>2735 
</span><span class="uncovered0"><a name="line2736"></a>2736         @new_record = false
</span><span class="uncovered1"><a name="line2737"></a>2737         id
</span><span class="uncovered0"><a name="line2738"></a>2738       end
</span><span class="inferred1"><a name="line2739"></a>2739 
</span><span class="inferred0"><a name="line2740"></a>2740       # Sets the attribute used for single table inheritance to this class name if this is not the ActiveRecord::Base descendent.
</span><span class="inferred1"><a name="line2741"></a>2741       # Considering the hierarchy Reply &lt; Message &lt; ActiveRecord::Base, this makes it possible to do Reply.new without having to
</span><span class="inferred0"><a name="line2742"></a>2742       # set &lt;tt&gt;Reply[Reply.inheritance_column] = &quot;Reply&quot;&lt;/tt&gt; yourself. No such attribute would be set for objects of the
</span><span class="inferred1"><a name="line2743"></a>2743       # Message class in that example.
</span><span class="marked0"><a name="line2744"></a>2744       def ensure_proper_type
</span><span class="marked1"><a name="line2745"></a>2745         unless self.class.descends_from_active_record?
</span><span class="uncovered0"><a name="line2746"></a>2746           write_attribute(self.class.inheritance_column, self.class.sti_name)
</span><span class="uncovered1"><a name="line2747"></a>2747         end
</span><span class="marked0"><a name="line2748"></a>2748       end
</span><span class="inferred1"><a name="line2749"></a>2749 
</span><span class="marked0"><a name="line2750"></a>2750       def convert_number_column_value(value)
</span><span class="marked1"><a name="line2751"></a>2751         if value == false
</span><span class="uncovered0"><a name="line2752"></a>2752           0
</span><span class="marked1"><a name="line2753"></a>2753         elsif value == true
</span><span class="uncovered0"><a name="line2754"></a>2754           1
</span><span class="marked1"><a name="line2755"></a>2755         elsif value.is_a?(String) &amp;&amp; value.blank?
</span><span class="uncovered0"><a name="line2756"></a>2756           nil
</span><span class="inferred1"><a name="line2757"></a>2757         else
</span><span class="marked0"><a name="line2758"></a>2758           value
</span><span class="inferred1"><a name="line2759"></a>2759         end
</span><span class="marked0"><a name="line2760"></a>2760       end
</span><span class="inferred1"><a name="line2761"></a>2761 
</span><span class="marked0"><a name="line2762"></a>2762       def remove_attributes_protected_from_mass_assignment(attributes)
</span><span class="marked1"><a name="line2763"></a>2763         safe_attributes =
</span><span class="marked0"><a name="line2764"></a>2764           if self.class.accessible_attributes.nil? &amp;&amp; self.class.protected_attributes.nil?
</span><span class="marked1"><a name="line2765"></a>2765             attributes.reject { |key, value| attributes_protected_by_default.include?(key.gsub(/\(.+/, &quot;&quot;)) }
</span><span class="inferred0"><a name="line2766"></a>2766           elsif self.class.protected_attributes.nil?
</span><span class="uncovered1"><a name="line2767"></a>2767             attributes.reject { |key, value| !self.class.accessible_attributes.include?(key.gsub(/\(.+/, &quot;&quot;)) || attributes_protected_by_default.include?(key.gsub(/\(.+/, &quot;&quot;)) }
</span><span class="uncovered0"><a name="line2768"></a>2768           elsif self.class.accessible_attributes.nil?
</span><span class="uncovered1"><a name="line2769"></a>2769             attributes.reject { |key, value| self.class.protected_attributes.include?(key.gsub(/\(.+/,&quot;&quot;)) || attributes_protected_by_default.include?(key.gsub(/\(.+/, &quot;&quot;)) }
</span><span class="uncovered0"><a name="line2770"></a>2770           else
</span><span class="uncovered1"><a name="line2771"></a>2771             raise &quot;Declare either attr_protected or attr_accessible for #{self.class}, but not both.&quot;
</span><span class="uncovered0"><a name="line2772"></a>2772           end
</span><span class="inferred1"><a name="line2773"></a>2773 
</span><span class="marked0"><a name="line2774"></a>2774         removed_attributes = attributes.keys - safe_attributes.keys
</span><span class="inferred1"><a name="line2775"></a>2775 
</span><span class="marked0"><a name="line2776"></a>2776         if removed_attributes.any?
</span><span class="marked1"><a name="line2777"></a>2777           log_protected_attribute_removal(removed_attributes)
</span><span class="inferred0"><a name="line2778"></a>2778         end
</span><span class="inferred1"><a name="line2779"></a>2779 
</span><span class="marked0"><a name="line2780"></a>2780         safe_attributes
</span><span class="inferred1"><a name="line2781"></a>2781       end
</span><span class="inferred0"><a name="line2782"></a>2782 
</span><span class="inferred1"><a name="line2783"></a>2783       # Removes attributes which have been marked as readonly.
</span><span class="marked0"><a name="line2784"></a>2784       def remove_readonly_attributes(attributes)
</span><span class="marked1"><a name="line2785"></a>2785         unless self.class.readonly_attributes.nil?
</span><span class="inferred0"><a name="line2786"></a>2786           attributes.delete_if { |key, value| self.class.readonly_attributes.include?(key.gsub(/\(.+/,&quot;&quot;)) }
</span><span class="inferred1"><a name="line2787"></a>2787         else
</span><span class="marked0"><a name="line2788"></a>2788           attributes
</span><span class="inferred1"><a name="line2789"></a>2789         end
</span><span class="marked0"><a name="line2790"></a>2790       end
</span><span class="inferred1"><a name="line2791"></a>2791 
</span><span class="marked0"><a name="line2792"></a>2792       def log_protected_attribute_removal(*attributes)
</span><span class="marked1"><a name="line2793"></a>2793         logger.debug &quot;WARNING: Can't mass-assign these protected attributes: #{attributes.join(', ')}&quot;
</span><span class="marked0"><a name="line2794"></a>2794       end
</span><span class="inferred1"><a name="line2795"></a>2795 
</span><span class="inferred0"><a name="line2796"></a>2796       # The primary key and inheritance column can never be set by mass-assignment for security reasons.
</span><span class="marked1"><a name="line2797"></a>2797       def attributes_protected_by_default
</span><span class="marked0"><a name="line2798"></a>2798         default = [ self.class.primary_key, self.class.inheritance_column ]
</span><span class="marked1"><a name="line2799"></a>2799         default &lt;&lt; 'id' unless self.class.primary_key.eql? 'id'
</span><span class="marked0"><a name="line2800"></a>2800         default
</span><span class="inferred1"><a name="line2801"></a>2801       end
</span><span class="inferred0"><a name="line2802"></a>2802 
</span><span class="inferred1"><a name="line2803"></a>2803       # Returns a copy of the attributes hash where all the values have been safely quoted for use in
</span><span class="inferred0"><a name="line2804"></a>2804       # an SQL statement.
</span><span class="marked1"><a name="line2805"></a>2805       def attributes_with_quotes(include_primary_key = true, include_readonly_attributes = true, attribute_names = @attributes.keys)
</span><span class="marked0"><a name="line2806"></a>2806         quoted = {}
</span><span class="marked1"><a name="line2807"></a>2807         connection = self.class.connection
</span><span class="marked0"><a name="line2808"></a>2808         attribute_names.each do |name|
</span><span class="marked1"><a name="line2809"></a>2809           if (column = column_for_attribute(name)) &amp;&amp; (include_primary_key || !column.primary)
</span><span class="marked0"><a name="line2810"></a>2810             value = read_attribute(name)
</span><span class="inferred1"><a name="line2811"></a>2811 
</span><span class="inferred0"><a name="line2812"></a>2812             # We need explicit to_yaml because quote() does not properly convert Time/Date fields to YAML.
</span><span class="marked1"><a name="line2813"></a>2813             if value &amp;&amp; self.class.serialized_attributes.has_key?(name) &amp;&amp; (value.acts_like?(:date) || value.acts_like?(:time))
</span><span class="uncovered0"><a name="line2814"></a>2814               value = value.to_yaml
</span><span class="uncovered1"><a name="line2815"></a>2815             end
</span><span class="inferred0"><a name="line2816"></a>2816 
</span><span class="marked1"><a name="line2817"></a>2817             quoted[name] = connection.quote(value, column)
</span><span class="inferred0"><a name="line2818"></a>2818           end
</span><span class="inferred1"><a name="line2819"></a>2819         end
</span><span class="marked0"><a name="line2820"></a>2820         include_readonly_attributes ? quoted : remove_readonly_attributes(quoted)
</span><span class="inferred1"><a name="line2821"></a>2821       end
</span><span class="inferred0"><a name="line2822"></a>2822 
</span><span class="inferred1"><a name="line2823"></a>2823       # Quote strings appropriately for SQL statements.
</span><span class="marked0"><a name="line2824"></a>2824       def quote_value(value, column = nil)
</span><span class="marked1"><a name="line2825"></a>2825         self.class.connection.quote(value, column)
</span><span class="marked0"><a name="line2826"></a>2826       end
</span><span class="inferred1"><a name="line2827"></a>2827 
</span><span class="inferred0"><a name="line2828"></a>2828       # Interpolate custom SQL string in instance context.
</span><span class="inferred1"><a name="line2829"></a>2829       # Optional record argument is meant for custom insert_sql.
</span><span class="marked0"><a name="line2830"></a>2830       def interpolate_sql(sql, record = nil)
</span><span class="uncovered1"><a name="line2831"></a>2831         instance_eval(&quot;%@#{sql.gsub('@', '\@')}@&quot;)
</span><span class="uncovered0"><a name="line2832"></a>2832       end
</span><span class="inferred1"><a name="line2833"></a>2833 
</span><span class="inferred0"><a name="line2834"></a>2834       # Initializes the attributes array with keys matching the columns from the linked table and
</span><span class="inferred1"><a name="line2835"></a>2835       # the values matching the corresponding default value of that column, so
</span><span class="inferred0"><a name="line2836"></a>2836       # that a new instance, or one populated from a passed-in Hash, still has all the attributes
</span><span class="inferred1"><a name="line2837"></a>2837       # that instances loaded from the database would.
</span><span class="marked0"><a name="line2838"></a>2838       def attributes_from_column_definition
</span><span class="marked1"><a name="line2839"></a>2839         self.class.columns.inject({}) do |attributes, column|
</span><span class="marked0"><a name="line2840"></a>2840           attributes[column.name] = column.default unless column.name == self.class.primary_key
</span><span class="marked1"><a name="line2841"></a>2841           attributes
</span><span class="inferred0"><a name="line2842"></a>2842         end
</span><span class="marked1"><a name="line2843"></a>2843       end
</span><span class="inferred0"><a name="line2844"></a>2844 
</span><span class="inferred1"><a name="line2845"></a>2845       # Instantiates objects for all attribute classes that needs more than one constructor parameter. This is done
</span><span class="inferred0"><a name="line2846"></a>2846       # by calling new on the column type or aggregation type (through composed_of) object with these parameters.
</span><span class="inferred1"><a name="line2847"></a>2847       # So having the pairs written_on(1) = &quot;2004&quot;, written_on(2) = &quot;6&quot;, written_on(3) = &quot;24&quot;, will instantiate
</span><span class="inferred0"><a name="line2848"></a>2848       # written_on (a date type) with Date.new(&quot;2004&quot;, &quot;6&quot;, &quot;24&quot;). You can also specify a typecast character in the
</span><span class="inferred1"><a name="line2849"></a>2849       # parentheses to have the parameters typecasted before they're used in the constructor. Use i for Fixnum, f for Float,
</span><span class="inferred0"><a name="line2850"></a>2850       # s for String, and a for Array. If all the values for a given attribute are empty, the attribute will be set to nil.
</span><span class="marked1"><a name="line2851"></a>2851       def assign_multiparameter_attributes(pairs)
</span><span class="inferred0"><a name="line2852"></a>2852         execute_callstack_for_multiparameter_attributes(
</span><span class="marked1"><a name="line2853"></a>2853           extract_callstack_for_multiparameter_attributes(pairs)
</span><span class="inferred0"><a name="line2854"></a>2854         )
</span><span class="marked1"><a name="line2855"></a>2855       end
</span><span class="inferred0"><a name="line2856"></a>2856 
</span><span class="marked1"><a name="line2857"></a>2857       def instantiate_time_object(name, values)
</span><span class="uncovered0"><a name="line2858"></a>2858         if self.class.send(:create_time_zone_conversion_attribute?, name, column_for_attribute(name))
</span><span class="uncovered1"><a name="line2859"></a>2859           Time.zone.local(*values)
</span><span class="uncovered0"><a name="line2860"></a>2860         else
</span><span class="uncovered1"><a name="line2861"></a>2861           Time.time_with_datetime_fallback(@@default_timezone, *values)
</span><span class="uncovered0"><a name="line2862"></a>2862         end
</span><span class="uncovered1"><a name="line2863"></a>2863       end
</span><span class="inferred0"><a name="line2864"></a>2864 
</span><span class="marked1"><a name="line2865"></a>2865       def execute_callstack_for_multiparameter_attributes(callstack)
</span><span class="marked0"><a name="line2866"></a>2866         errors = []
</span><span class="marked1"><a name="line2867"></a>2867         callstack.each do |name, values|
</span><span class="uncovered0"><a name="line2868"></a>2868           klass = (self.class.reflect_on_aggregation(name.to_sym) || column_for_attribute(name)).klass
</span><span class="uncovered1"><a name="line2869"></a>2869           if values.empty?
</span><span class="uncovered0"><a name="line2870"></a>2870             send(name + &quot;=&quot;, nil)
</span><span class="uncovered1"><a name="line2871"></a>2871           else
</span><span class="uncovered0"><a name="line2872"></a>2872             begin
</span><span class="uncovered1"><a name="line2873"></a>2873               value = if Time == klass
</span><span class="uncovered0"><a name="line2874"></a>2874                 instantiate_time_object(name, values)
</span><span class="uncovered1"><a name="line2875"></a>2875               elsif Date == klass
</span><span class="uncovered0"><a name="line2876"></a>2876                 begin
</span><span class="uncovered1"><a name="line2877"></a>2877                   Date.new(*values)
</span><span class="uncovered0"><a name="line2878"></a>2878                 rescue ArgumentError =&gt; ex # if Date.new raises an exception on an invalid date
</span><span class="uncovered1"><a name="line2879"></a>2879                   instantiate_time_object(name, values).to_date # we instantiate Time object and convert it back to a date thus using Time's logic in handling invalid dates
</span><span class="uncovered0"><a name="line2880"></a>2880                 end
</span><span class="uncovered1"><a name="line2881"></a>2881               else
</span><span class="uncovered0"><a name="line2882"></a>2882                 klass.new(*values)
</span><span class="uncovered1"><a name="line2883"></a>2883               end
</span><span class="uncovered0"><a name="line2884"></a>2884 
</span><span class="uncovered1"><a name="line2885"></a>2885               send(name + &quot;=&quot;, value)
</span><span class="uncovered0"><a name="line2886"></a>2886             rescue =&gt; ex
</span><span class="uncovered1"><a name="line2887"></a>2887               errors &lt;&lt; AttributeAssignmentError.new(&quot;error on assignment #{values.inspect} to #{name}&quot;, ex, name)
</span><span class="uncovered0"><a name="line2888"></a>2888             end
</span><span class="uncovered1"><a name="line2889"></a>2889           end
</span><span class="uncovered0"><a name="line2890"></a>2890         end
</span><span class="marked1"><a name="line2891"></a>2891         unless errors.empty?
</span><span class="uncovered0"><a name="line2892"></a>2892           raise MultiparameterAssignmentErrors.new(errors), &quot;#{errors.size} error(s) on assignment of multiparameter attributes&quot;
</span><span class="uncovered1"><a name="line2893"></a>2893         end
</span><span class="uncovered0"><a name="line2894"></a>2894       end
</span><span class="inferred1"><a name="line2895"></a>2895 
</span><span class="marked0"><a name="line2896"></a>2896       def extract_callstack_for_multiparameter_attributes(pairs)
</span><span class="marked1"><a name="line2897"></a>2897         attributes = { }
</span><span class="inferred0"><a name="line2898"></a>2898 
</span><span class="marked1"><a name="line2899"></a>2899         for pair in pairs
</span><span class="uncovered0"><a name="line2900"></a>2900           multiparameter_name, value = pair
</span><span class="uncovered1"><a name="line2901"></a>2901           attribute_name = multiparameter_name.split(&quot;(&quot;).first
</span><span class="uncovered0"><a name="line2902"></a>2902           attributes[attribute_name] = [] unless attributes.include?(attribute_name)
</span><span class="uncovered1"><a name="line2903"></a>2903 
</span><span class="uncovered0"><a name="line2904"></a>2904           unless value.empty?
</span><span class="uncovered1"><a name="line2905"></a>2905             attributes[attribute_name] &lt;&lt;
</span><span class="uncovered0"><a name="line2906"></a>2906               [ find_parameter_position(multiparameter_name), type_cast_attribute_value(multiparameter_name, value) ]
</span><span class="uncovered1"><a name="line2907"></a>2907           end
</span><span class="uncovered0"><a name="line2908"></a>2908         end
</span><span class="inferred1"><a name="line2909"></a>2909 
</span><span class="marked0"><a name="line2910"></a>2910         attributes.each { |name, values| attributes[name] = values.sort_by{ |v| v.first }.collect { |v| v.last } }
</span><span class="inferred1"><a name="line2911"></a>2911       end
</span><span class="inferred0"><a name="line2912"></a>2912 
</span><span class="marked1"><a name="line2913"></a>2913       def type_cast_attribute_value(multiparameter_name, value)
</span><span class="uncovered0"><a name="line2914"></a>2914         multiparameter_name =~ /\([0-9]*([a-z])\)/ ? value.send(&quot;to_&quot; + $1) : value
</span><span class="uncovered1"><a name="line2915"></a>2915       end
</span><span class="inferred0"><a name="line2916"></a>2916 
</span><span class="marked1"><a name="line2917"></a>2917       def find_parameter_position(multiparameter_name)
</span><span class="uncovered0"><a name="line2918"></a>2918         multiparameter_name.scan(/\(([0-9]*).*\)/).first.first
</span><span class="uncovered1"><a name="line2919"></a>2919       end
</span><span class="inferred0"><a name="line2920"></a>2920 
</span><span class="inferred1"><a name="line2921"></a>2921       # Returns a comma-separated pair list, like &quot;key1 = val1, key2 = val2&quot;.
</span><span class="marked0"><a name="line2922"></a>2922       def comma_pair_list(hash)
</span><span class="marked1"><a name="line2923"></a>2923         hash.inject([]) { |list, pair| list &lt;&lt; &quot;#{pair.first} = #{pair.last}&quot; }.join(&quot;, &quot;)
</span><span class="marked0"><a name="line2924"></a>2924       end
</span><span class="inferred1"><a name="line2925"></a>2925 
</span><span class="marked0"><a name="line2926"></a>2926       def quoted_column_names(attributes = attributes_with_quotes)
</span><span class="uncovered1"><a name="line2927"></a>2927         connection = self.class.connection
</span><span class="uncovered0"><a name="line2928"></a>2928         attributes.keys.collect do |column_name|
</span><span class="uncovered1"><a name="line2929"></a>2929           connection.quote_column_name(column_name)
</span><span class="uncovered0"><a name="line2930"></a>2930         end
</span><span class="uncovered1"><a name="line2931"></a>2931       end
</span><span class="inferred0"><a name="line2932"></a>2932 
</span><span class="marked1"><a name="line2933"></a>2933       def self.quoted_table_name
</span><span class="marked0"><a name="line2934"></a>2934         self.connection.quote_table_name(self.table_name)
</span><span class="marked1"><a name="line2935"></a>2935       end
</span><span class="inferred0"><a name="line2936"></a>2936 
</span><span class="marked1"><a name="line2937"></a>2937       def quote_columns(quoter, hash)
</span><span class="marked0"><a name="line2938"></a>2938         hash.inject({}) do |quoted, (name, value)|
</span><span class="marked1"><a name="line2939"></a>2939           quoted[quoter.quote_column_name(name)] = value
</span><span class="marked0"><a name="line2940"></a>2940           quoted
</span><span class="inferred1"><a name="line2941"></a>2941         end
</span><span class="marked0"><a name="line2942"></a>2942       end
</span><span class="inferred1"><a name="line2943"></a>2943 
</span><span class="marked0"><a name="line2944"></a>2944       def quoted_comma_pair_list(quoter, hash)
</span><span class="marked1"><a name="line2945"></a>2945         comma_pair_list(quote_columns(quoter, hash))
</span><span class="marked0"><a name="line2946"></a>2946       end
</span><span class="inferred1"><a name="line2947"></a>2947 
</span><span class="marked0"><a name="line2948"></a>2948       def object_from_yaml(string)
</span><span class="uncovered1"><a name="line2949"></a>2949         return string unless string.is_a?(String) &amp;&amp; string =~ /^---/
</span><span class="uncovered0"><a name="line2950"></a>2950         YAML::load(string) rescue string
</span><span class="uncovered1"><a name="line2951"></a>2951       end
</span><span class="inferred0"><a name="line2952"></a>2952 
</span><span class="marked1"><a name="line2953"></a>2953       def clone_attributes(reader_method = :read_attribute, attributes = {})
</span><span class="uncovered0"><a name="line2954"></a>2954         self.attribute_names.inject(attributes) do |attrs, name|
</span><span class="uncovered1"><a name="line2955"></a>2955           attrs[name] = clone_attribute_value(reader_method, name)
</span><span class="uncovered0"><a name="line2956"></a>2956           attrs
</span><span class="uncovered1"><a name="line2957"></a>2957         end
</span><span class="uncovered0"><a name="line2958"></a>2958       end
</span><span class="inferred1"><a name="line2959"></a>2959 
</span><span class="marked0"><a name="line2960"></a>2960       def clone_attribute_value(reader_method, attribute_name)
</span><span class="marked1"><a name="line2961"></a>2961         value = send(reader_method, attribute_name)
</span><span class="marked0"><a name="line2962"></a>2962         value.duplicable? ? value.clone : value
</span><span class="uncovered1"><a name="line2963"></a>2963       rescue TypeError, NoMethodError
</span><span class="uncovered0"><a name="line2964"></a>2964         value
</span><span class="marked1"><a name="line2965"></a>2965       end
</span><span class="inferred0"><a name="line2966"></a>2966   end
</span><span class="inferred1"><a name="line2967"></a>2967 end
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
