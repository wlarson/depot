<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>/Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Wed Feb 11 19:51:24 -0800 2009 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='-Library-Ruby-Gems-1_8-gems-activerecord-2_2_2-lib-active_record-associations_rb.html'>/Library/Ruby/Gems/1.8/gems/activerecord-2.2.2/lib/active_record/associations.rb</a>
        </td>
      <td class='lines_total'><tt>2227</tt>
        </td>
      <td class='lines_code'><tt>1013</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>62.2%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='62'/>
                  <td class='uncovered' width='38'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>25.1%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='25'/>
                  <td class='uncovered' width='75'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="marked1"><a name="line1"></a>   1 require 'active_record/associations/association_proxy'
</span><span class="marked0"><a name="line2"></a>   2 require 'active_record/associations/association_collection'
</span><span class="marked1"><a name="line3"></a>   3 require 'active_record/associations/belongs_to_association'
</span><span class="marked0"><a name="line4"></a>   4 require 'active_record/associations/belongs_to_polymorphic_association'
</span><span class="marked1"><a name="line5"></a>   5 require 'active_record/associations/has_one_association'
</span><span class="marked0"><a name="line6"></a>   6 require 'active_record/associations/has_many_association'
</span><span class="marked1"><a name="line7"></a>   7 require 'active_record/associations/has_many_through_association'
</span><span class="marked0"><a name="line8"></a>   8 require 'active_record/associations/has_and_belongs_to_many_association'
</span><span class="marked1"><a name="line9"></a>   9 require 'active_record/associations/has_one_through_association'
</span><span class="inferred0"><a name="line10"></a>  10 
</span><span class="marked1"><a name="line11"></a>  11 module ActiveRecord
</span><span class="marked0"><a name="line12"></a>  12   class HasManyThroughAssociationNotFoundError &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line13"></a>  13     def initialize(owner_class_name, reflection)
</span><span class="uncovered0"><a name="line14"></a>  14       super(&quot;Could not find the association #{reflection.options[:through].inspect} in model #{owner_class_name}&quot;)
</span><span class="uncovered1"><a name="line15"></a>  15     end
</span><span class="uncovered0"><a name="line16"></a>  16   end
</span><span class="inferred1"><a name="line17"></a>  17 
</span><span class="marked0"><a name="line18"></a>  18   class HasManyThroughAssociationPolymorphicError &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line19"></a>  19     def initialize(owner_class_name, reflection, source_reflection)
</span><span class="uncovered0"><a name="line20"></a>  20       super(&quot;Cannot have a has_many :through association '#{owner_class_name}##{reflection.name}' on the polymorphic object '#{source_reflection.class_name}##{source_reflection.name}'.&quot;)
</span><span class="uncovered1"><a name="line21"></a>  21     end
</span><span class="uncovered0"><a name="line22"></a>  22   end
</span><span class="inferred1"><a name="line23"></a>  23 
</span><span class="marked0"><a name="line24"></a>  24   class HasManyThroughAssociationPointlessSourceTypeError &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line25"></a>  25     def initialize(owner_class_name, reflection, source_reflection)
</span><span class="uncovered0"><a name="line26"></a>  26       super(&quot;Cannot have a has_many :through association '#{owner_class_name}##{reflection.name}' with a :source_type option if the '#{reflection.through_reflection.class_name}##{source_reflection.name}' is not polymorphic.  Try removing :source_type on your association.&quot;)
</span><span class="uncovered1"><a name="line27"></a>  27     end
</span><span class="uncovered0"><a name="line28"></a>  28   end
</span><span class="inferred1"><a name="line29"></a>  29 
</span><span class="marked0"><a name="line30"></a>  30   class HasManyThroughSourceAssociationNotFoundError &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line31"></a>  31     def initialize(reflection)
</span><span class="uncovered0"><a name="line32"></a>  32       through_reflection      = reflection.through_reflection
</span><span class="uncovered1"><a name="line33"></a>  33       source_reflection_names = reflection.source_reflection_names
</span><span class="uncovered0"><a name="line34"></a>  34       source_associations     = reflection.through_reflection.klass.reflect_on_all_associations.collect { |a| a.name.inspect }
</span><span class="uncovered1"><a name="line35"></a>  35       super(&quot;Could not find the source association(s) #{source_reflection_names.collect(&amp;:inspect).to_sentence :connector =&gt; 'or'} in model #{through_reflection.klass}.  Try 'has_many #{reflection.name.inspect}, :through =&gt; #{through_reflection.name.inspect}, :source =&gt; &lt;name&gt;'.  Is it one of #{source_associations.to_sentence :connector =&gt; 'or'}?&quot;)
</span><span class="uncovered0"><a name="line36"></a>  36     end
</span><span class="uncovered1"><a name="line37"></a>  37   end
</span><span class="inferred0"><a name="line38"></a>  38 
</span><span class="marked1"><a name="line39"></a>  39   class HasManyThroughSourceAssociationMacroError &lt; ActiveRecordError #:nodoc:
</span><span class="marked0"><a name="line40"></a>  40     def initialize(reflection)
</span><span class="uncovered1"><a name="line41"></a>  41       through_reflection = reflection.through_reflection
</span><span class="uncovered0"><a name="line42"></a>  42       source_reflection  = reflection.source_reflection
</span><span class="uncovered1"><a name="line43"></a>  43       super(&quot;Invalid source reflection macro :#{source_reflection.macro}#{&quot; :through&quot; if source_reflection.options[:through]} for has_many #{reflection.name.inspect}, :through =&gt; #{through_reflection.name.inspect}.  Use :source to specify the source reflection.&quot;)
</span><span class="uncovered0"><a name="line44"></a>  44     end
</span><span class="uncovered1"><a name="line45"></a>  45   end
</span><span class="inferred0"><a name="line46"></a>  46 
</span><span class="marked1"><a name="line47"></a>  47   class HasManyThroughCantAssociateThroughHasManyReflection &lt; ActiveRecordError #:nodoc:
</span><span class="marked0"><a name="line48"></a>  48     def initialize(owner, reflection)
</span><span class="uncovered1"><a name="line49"></a>  49       super(&quot;Cannot modify association '#{owner.class.name}##{reflection.name}' because the source reflection class '#{reflection.source_reflection.class_name}' is associated to '#{reflection.through_reflection.class_name}' via :#{reflection.source_reflection.macro}.&quot;)
</span><span class="uncovered0"><a name="line50"></a>  50     end
</span><span class="uncovered1"><a name="line51"></a>  51   end
</span><span class="marked0"><a name="line52"></a>  52   class HasManyThroughCantAssociateNewRecords &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line53"></a>  53     def initialize(owner, reflection)
</span><span class="uncovered0"><a name="line54"></a>  54       super(&quot;Cannot associate new records through '#{owner.class.name}##{reflection.name}' on '#{reflection.source_reflection.class_name rescue nil}##{reflection.source_reflection.name rescue nil}'. Both records must have an id in order to create the has_many :through record associating them.&quot;)
</span><span class="uncovered1"><a name="line55"></a>  55     end
</span><span class="uncovered0"><a name="line56"></a>  56   end
</span><span class="inferred1"><a name="line57"></a>  57 
</span><span class="marked0"><a name="line58"></a>  58   class HasManyThroughCantDissociateNewRecords &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line59"></a>  59     def initialize(owner, reflection)
</span><span class="uncovered0"><a name="line60"></a>  60       super(&quot;Cannot dissociate new records through '#{owner.class.name}##{reflection.name}' on '#{reflection.source_reflection.class_name rescue nil}##{reflection.source_reflection.name rescue nil}'. Both records must have an id in order to delete the has_many :through record associating them.&quot;)
</span><span class="uncovered1"><a name="line61"></a>  61     end
</span><span class="uncovered0"><a name="line62"></a>  62   end
</span><span class="inferred1"><a name="line63"></a>  63 
</span><span class="marked0"><a name="line64"></a>  64   class EagerLoadPolymorphicError &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line65"></a>  65     def initialize(reflection)
</span><span class="uncovered0"><a name="line66"></a>  66       super(&quot;Can not eagerly load the polymorphic association #{reflection.name.inspect}&quot;)
</span><span class="uncovered1"><a name="line67"></a>  67     end
</span><span class="uncovered0"><a name="line68"></a>  68   end
</span><span class="inferred1"><a name="line69"></a>  69 
</span><span class="marked0"><a name="line70"></a>  70   class ReadOnlyAssociation &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line71"></a>  71     def initialize(reflection)
</span><span class="uncovered0"><a name="line72"></a>  72       super(&quot;Can not add to a has_many :through association.  Try adding to #{reflection.through_reflection.name.inspect}.&quot;)
</span><span class="uncovered1"><a name="line73"></a>  73     end
</span><span class="uncovered0"><a name="line74"></a>  74   end
</span><span class="inferred1"><a name="line75"></a>  75 
</span><span class="inferred0"><a name="line76"></a>  76   # See ActiveRecord::Associations::ClassMethods for documentation.
</span><span class="marked1"><a name="line77"></a>  77   module Associations # :nodoc:
</span><span class="marked0"><a name="line78"></a>  78     def self.included(base)
</span><span class="marked1"><a name="line79"></a>  79       base.extend(ClassMethods)
</span><span class="marked0"><a name="line80"></a>  80     end
</span><span class="inferred1"><a name="line81"></a>  81 
</span><span class="inferred0"><a name="line82"></a>  82     # Clears out the association cache
</span><span class="marked1"><a name="line83"></a>  83     def clear_association_cache #:nodoc:
</span><span class="uncovered0"><a name="line84"></a>  84       self.class.reflect_on_all_associations.to_a.each do |assoc|
</span><span class="uncovered1"><a name="line85"></a>  85         instance_variable_set &quot;@#{assoc.name}&quot;, nil
</span><span class="uncovered0"><a name="line86"></a>  86       end unless self.new_record?
</span><span class="uncovered1"><a name="line87"></a>  87     end
</span><span class="inferred0"><a name="line88"></a>  88 
</span><span class="inferred1"><a name="line89"></a>  89     # Associations are a set of macro-like class methods for tying objects together through foreign keys. They express relationships like
</span><span class="inferred0"><a name="line90"></a>  90     # &quot;Project has one Project Manager&quot; or &quot;Project belongs to a Portfolio&quot;. Each macro adds a number of methods to the class which are
</span><span class="inferred1"><a name="line91"></a>  91     # specialized according to the collection or association symbol and the options hash. It works much the same way as Ruby's own &lt;tt&gt;attr*&lt;/tt&gt;
</span><span class="inferred0"><a name="line92"></a>  92     # methods. Example:
</span><span class="inferred1"><a name="line93"></a>  93     #
</span><span class="inferred0"><a name="line94"></a>  94     #   class Project &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line95"></a>  95     #     belongs_to              :portfolio
</span><span class="inferred0"><a name="line96"></a>  96     #     has_one                 :project_manager
</span><span class="inferred1"><a name="line97"></a>  97     #     has_many                :milestones
</span><span class="inferred0"><a name="line98"></a>  98     #     has_and_belongs_to_many :categories
</span><span class="inferred1"><a name="line99"></a>  99     #   end
</span><span class="inferred0"><a name="line100"></a> 100     #
</span><span class="inferred1"><a name="line101"></a> 101     # The project class now has the following methods (and more) to ease the traversal and manipulation of its relationships:
</span><span class="inferred0"><a name="line102"></a> 102     # * &lt;tt&gt;Project#portfolio, Project#portfolio=(portfolio), Project#portfolio.nil?&lt;/tt&gt;
</span><span class="inferred1"><a name="line103"></a> 103     # * &lt;tt&gt;Project#project_manager, Project#project_manager=(project_manager), Project#project_manager.nil?,&lt;/tt&gt;
</span><span class="inferred0"><a name="line104"></a> 104     # * &lt;tt&gt;Project#milestones.empty?, Project#milestones.size, Project#milestones, Project#milestones&lt;&lt;(milestone),&lt;/tt&gt;
</span><span class="inferred1"><a name="line105"></a> 105     #   &lt;tt&gt;Project#milestones.delete(milestone), Project#milestones.find(milestone_id), Project#milestones.find(:all, options),&lt;/tt&gt;
</span><span class="inferred0"><a name="line106"></a> 106     #   &lt;tt&gt;Project#milestones.build, Project#milestones.create&lt;/tt&gt;
</span><span class="inferred1"><a name="line107"></a> 107     # * &lt;tt&gt;Project#categories.empty?, Project#categories.size, Project#categories, Project#categories&lt;&lt;(category1),&lt;/tt&gt;
</span><span class="inferred0"><a name="line108"></a> 108     #   &lt;tt&gt;Project#categories.delete(category1)&lt;/tt&gt;
</span><span class="inferred1"><a name="line109"></a> 109     #
</span><span class="inferred0"><a name="line110"></a> 110     # === A word of warning
</span><span class="inferred1"><a name="line111"></a> 111     #
</span><span class="inferred0"><a name="line112"></a> 112     # Don't create associations that have the same name as instance methods of ActiveRecord::Base. Since the association
</span><span class="inferred1"><a name="line113"></a> 113     # adds a method with that name to its model, it will override the inherited method and break things.
</span><span class="inferred0"><a name="line114"></a> 114     # For instance, +attributes+ and +connection+ would be bad choices for association names.
</span><span class="inferred1"><a name="line115"></a> 115     #
</span><span class="inferred0"><a name="line116"></a> 116     # == Auto-generated methods
</span><span class="inferred1"><a name="line117"></a> 117     #
</span><span class="inferred0"><a name="line118"></a> 118     # === Singular associations (one-to-one)
</span><span class="inferred1"><a name="line119"></a> 119     #                                     |            |  belongs_to  |
</span><span class="inferred0"><a name="line120"></a> 120     #   generated methods                 | belongs_to | :polymorphic | has_one
</span><span class="inferred1"><a name="line121"></a> 121     #   ----------------------------------+------------+--------------+---------
</span><span class="inferred0"><a name="line122"></a> 122     #   #other                            |     X      |      X       |    X
</span><span class="inferred1"><a name="line123"></a> 123     #   #other=(other)                    |     X      |      X       |    X
</span><span class="inferred0"><a name="line124"></a> 124     #   #build_other(attributes={})       |     X      |              |    X
</span><span class="inferred1"><a name="line125"></a> 125     #   #create_other(attributes={})      |     X      |              |    X
</span><span class="inferred0"><a name="line126"></a> 126     #   #other.create!(attributes={})     |            |              |    X
</span><span class="inferred1"><a name="line127"></a> 127     #   #other.nil?                       |     X      |      X       |
</span><span class="inferred0"><a name="line128"></a> 128     #
</span><span class="inferred1"><a name="line129"></a> 129     # ===Collection associations (one-to-many / many-to-many)
</span><span class="inferred0"><a name="line130"></a> 130     #                                     |       |          | has_many
</span><span class="inferred1"><a name="line131"></a> 131     #   generated methods                 | habtm | has_many | :through
</span><span class="inferred0"><a name="line132"></a> 132     #   ----------------------------------+-------+----------+----------
</span><span class="inferred1"><a name="line133"></a> 133     #   #others                           |   X   |    X     |    X
</span><span class="inferred0"><a name="line134"></a> 134     #   #others=(other,other,...)         |   X   |    X     |    X
</span><span class="inferred1"><a name="line135"></a> 135     #   #other_ids                        |   X   |    X     |    X
</span><span class="inferred0"><a name="line136"></a> 136     #   #other_ids=(id,id,...)            |   X   |    X     |    X
</span><span class="inferred1"><a name="line137"></a> 137     #   #others&lt;&lt;                         |   X   |    X     |    X
</span><span class="inferred0"><a name="line138"></a> 138     #   #others.push                      |   X   |    X     |    X
</span><span class="inferred1"><a name="line139"></a> 139     #   #others.concat                    |   X   |    X     |    X
</span><span class="inferred0"><a name="line140"></a> 140     #   #others.build(attributes={})      |   X   |    X     |    X
</span><span class="inferred1"><a name="line141"></a> 141     #   #others.create(attributes={})     |   X   |    X     |    X
</span><span class="inferred0"><a name="line142"></a> 142     #   #others.create!(attributes={})    |   X   |    X     |    X
</span><span class="inferred1"><a name="line143"></a> 143     #   #others.size                      |   X   |    X     |    X
</span><span class="inferred0"><a name="line144"></a> 144     #   #others.length                    |   X   |    X     |    X
</span><span class="inferred1"><a name="line145"></a> 145     #   #others.count                     |   X   |    X     |    X
</span><span class="inferred0"><a name="line146"></a> 146     #   #others.sum(args*,&amp;block)         |   X   |    X     |    X
</span><span class="inferred1"><a name="line147"></a> 147     #   #others.empty?                    |   X   |    X     |    X
</span><span class="inferred0"><a name="line148"></a> 148     #   #others.clear                     |   X   |    X     |    X
</span><span class="inferred1"><a name="line149"></a> 149     #   #others.delete(other,other,...)   |   X   |    X     |    X
</span><span class="inferred0"><a name="line150"></a> 150     #   #others.delete_all                |   X   |    X     |
</span><span class="inferred1"><a name="line151"></a> 151     #   #others.destroy_all               |   X   |    X     |    X
</span><span class="inferred0"><a name="line152"></a> 152     #   #others.find(*args)               |   X   |    X     |    X
</span><span class="inferred1"><a name="line153"></a> 153     #   #others.find_first                |   X   |          |
</span><span class="inferred0"><a name="line154"></a> 154     #   #others.exist?                    |   X   |    X     |    X
</span><span class="inferred1"><a name="line155"></a> 155     #   #others.uniq                      |   X   |    X     |    X
</span><span class="inferred0"><a name="line156"></a> 156     #   #others.reset                     |   X   |    X     |    X
</span><span class="inferred1"><a name="line157"></a> 157     #
</span><span class="inferred0"><a name="line158"></a> 158     # == Cardinality and associations
</span><span class="inferred1"><a name="line159"></a> 159     #
</span><span class="inferred0"><a name="line160"></a> 160     # Active Record associations can be used to describe one-to-one, one-to-many and many-to-many
</span><span class="inferred1"><a name="line161"></a> 161     # relationships between models. Each model uses an association to describe its role in
</span><span class="inferred0"><a name="line162"></a> 162     # the relation. The +belongs_to+ association is always used in the model that has
</span><span class="inferred1"><a name="line163"></a> 163     # the foreign key.
</span><span class="inferred0"><a name="line164"></a> 164     #
</span><span class="inferred1"><a name="line165"></a> 165     # === One-to-one
</span><span class="inferred0"><a name="line166"></a> 166     #
</span><span class="inferred1"><a name="line167"></a> 167     # Use +has_one+ in the base, and +belongs_to+ in the associated model.
</span><span class="inferred0"><a name="line168"></a> 168     #
</span><span class="inferred1"><a name="line169"></a> 169     #   class Employee &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line170"></a> 170     #     has_one :office
</span><span class="inferred1"><a name="line171"></a> 171     #   end
</span><span class="inferred0"><a name="line172"></a> 172     #   class Office &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line173"></a> 173     #     belongs_to :employee    # foreign key - employee_id
</span><span class="inferred0"><a name="line174"></a> 174     #   end
</span><span class="inferred1"><a name="line175"></a> 175     #
</span><span class="inferred0"><a name="line176"></a> 176     # === One-to-many
</span><span class="inferred1"><a name="line177"></a> 177     #
</span><span class="inferred0"><a name="line178"></a> 178     # Use +has_many+ in the base, and +belongs_to+ in the associated model.
</span><span class="inferred1"><a name="line179"></a> 179     #
</span><span class="inferred0"><a name="line180"></a> 180     #   class Manager &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line181"></a> 181     #     has_many :employees
</span><span class="inferred0"><a name="line182"></a> 182     #   end
</span><span class="inferred1"><a name="line183"></a> 183     #   class Employee &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line184"></a> 184     #     belongs_to :manager     # foreign key - manager_id
</span><span class="inferred1"><a name="line185"></a> 185     #   end
</span><span class="inferred0"><a name="line186"></a> 186     #
</span><span class="inferred1"><a name="line187"></a> 187     # === Many-to-many
</span><span class="inferred0"><a name="line188"></a> 188     #
</span><span class="inferred1"><a name="line189"></a> 189     # There are two ways to build a many-to-many relationship.
</span><span class="inferred0"><a name="line190"></a> 190     #
</span><span class="inferred1"><a name="line191"></a> 191     # The first way uses a +has_many+ association with the &lt;tt&gt;:through&lt;/tt&gt; option and a join model, so
</span><span class="inferred0"><a name="line192"></a> 192     # there are two stages of associations.
</span><span class="inferred1"><a name="line193"></a> 193     #
</span><span class="inferred0"><a name="line194"></a> 194     #   class Assignment &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line195"></a> 195     #     belongs_to :programmer  # foreign key - programmer_id
</span><span class="inferred0"><a name="line196"></a> 196     #     belongs_to :project     # foreign key - project_id
</span><span class="inferred1"><a name="line197"></a> 197     #   end
</span><span class="inferred0"><a name="line198"></a> 198     #   class Programmer &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line199"></a> 199     #     has_many :assignments
</span><span class="inferred0"><a name="line200"></a> 200     #     has_many :projects, :through =&gt; :assignments
</span><span class="inferred1"><a name="line201"></a> 201     #   end
</span><span class="inferred0"><a name="line202"></a> 202     #   class Project &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line203"></a> 203     #     has_many :assignments
</span><span class="inferred0"><a name="line204"></a> 204     #     has_many :programmers, :through =&gt; :assignments
</span><span class="inferred1"><a name="line205"></a> 205     #   end
</span><span class="inferred0"><a name="line206"></a> 206     #
</span><span class="inferred1"><a name="line207"></a> 207     # For the second way, use +has_and_belongs_to_many+ in both models. This requires a join table
</span><span class="inferred0"><a name="line208"></a> 208     # that has no corresponding model or primary key.
</span><span class="inferred1"><a name="line209"></a> 209     #
</span><span class="inferred0"><a name="line210"></a> 210     #   class Programmer &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line211"></a> 211     #     has_and_belongs_to_many :projects       # foreign keys in the join table
</span><span class="inferred0"><a name="line212"></a> 212     #   end
</span><span class="inferred1"><a name="line213"></a> 213     #   class Project &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line214"></a> 214     #     has_and_belongs_to_many :programmers    # foreign keys in the join table
</span><span class="inferred1"><a name="line215"></a> 215     #   end
</span><span class="inferred0"><a name="line216"></a> 216     #
</span><span class="inferred1"><a name="line217"></a> 217     # Choosing which way to build a many-to-many relationship is not always simple.
</span><span class="inferred0"><a name="line218"></a> 218     # If you need to work with the relationship model as its own entity,
</span><span class="inferred1"><a name="line219"></a> 219     # use &lt;tt&gt;has_many :through&lt;/tt&gt;. Use +has_and_belongs_to_many+ when working with legacy schemas or when
</span><span class="inferred0"><a name="line220"></a> 220     # you never work directly with the relationship itself.
</span><span class="inferred1"><a name="line221"></a> 221     #
</span><span class="inferred0"><a name="line222"></a> 222     # == Is it a +belongs_to+ or +has_one+ association?
</span><span class="inferred1"><a name="line223"></a> 223     #
</span><span class="inferred0"><a name="line224"></a> 224     # Both express a 1-1 relationship. The difference is mostly where to place the foreign key, which goes on the table for the class
</span><span class="inferred1"><a name="line225"></a> 225     # declaring the +belongs_to+ relationship. Example:
</span><span class="inferred0"><a name="line226"></a> 226     #
</span><span class="inferred1"><a name="line227"></a> 227     #   class User &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line228"></a> 228     #     # I reference an account.
</span><span class="inferred1"><a name="line229"></a> 229     #     belongs_to :account
</span><span class="inferred0"><a name="line230"></a> 230     #   end
</span><span class="inferred1"><a name="line231"></a> 231     #
</span><span class="inferred0"><a name="line232"></a> 232     #   class Account &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line233"></a> 233     #     # One user references me.
</span><span class="inferred0"><a name="line234"></a> 234     #     has_one :user
</span><span class="inferred1"><a name="line235"></a> 235     #   end
</span><span class="inferred0"><a name="line236"></a> 236     #
</span><span class="inferred1"><a name="line237"></a> 237     # The tables for these classes could look something like:
</span><span class="inferred0"><a name="line238"></a> 238     #
</span><span class="inferred1"><a name="line239"></a> 239     #   CREATE TABLE users (
</span><span class="inferred0"><a name="line240"></a> 240     #     id int(11) NOT NULL auto_increment,
</span><span class="inferred1"><a name="line241"></a> 241     #     account_id int(11) default NULL,
</span><span class="inferred0"><a name="line242"></a> 242     #     name varchar default NULL,
</span><span class="inferred1"><a name="line243"></a> 243     #     PRIMARY KEY  (id)
</span><span class="inferred0"><a name="line244"></a> 244     #   )
</span><span class="inferred1"><a name="line245"></a> 245     #
</span><span class="inferred0"><a name="line246"></a> 246     #   CREATE TABLE accounts (
</span><span class="inferred1"><a name="line247"></a> 247     #     id int(11) NOT NULL auto_increment,
</span><span class="inferred0"><a name="line248"></a> 248     #     name varchar default NULL,
</span><span class="inferred1"><a name="line249"></a> 249     #     PRIMARY KEY  (id)
</span><span class="inferred0"><a name="line250"></a> 250     #   )
</span><span class="inferred1"><a name="line251"></a> 251     #
</span><span class="inferred0"><a name="line252"></a> 252     # == Unsaved objects and associations
</span><span class="inferred1"><a name="line253"></a> 253     #
</span><span class="inferred0"><a name="line254"></a> 254     # You can manipulate objects and associations before they are saved to the database, but there is some special behavior you should be
</span><span class="inferred1"><a name="line255"></a> 255     # aware of, mostly involving the saving of associated objects.
</span><span class="inferred0"><a name="line256"></a> 256     #
</span><span class="inferred1"><a name="line257"></a> 257     # === One-to-one associations
</span><span class="inferred0"><a name="line258"></a> 258     #
</span><span class="inferred1"><a name="line259"></a> 259     # * Assigning an object to a +has_one+ association automatically saves that object and the object being replaced (if there is one), in
</span><span class="inferred0"><a name="line260"></a> 260     #   order to update their primary keys - except if the parent object is unsaved (&lt;tt&gt;new_record? == true&lt;/tt&gt;).
</span><span class="inferred1"><a name="line261"></a> 261     # * If either of these saves fail (due to one of the objects being invalid) the assignment statement returns +false+ and the assignment
</span><span class="inferred0"><a name="line262"></a> 262     #   is cancelled.
</span><span class="inferred1"><a name="line263"></a> 263     # * If you wish to assign an object to a +has_one+ association without saving it, use the &lt;tt&gt;association.build&lt;/tt&gt; method (documented below).
</span><span class="inferred0"><a name="line264"></a> 264     # * Assigning an object to a +belongs_to+ association does not save the object, since the foreign key field belongs on the parent. It
</span><span class="inferred1"><a name="line265"></a> 265     #   does not save the parent either.
</span><span class="inferred0"><a name="line266"></a> 266     #
</span><span class="inferred1"><a name="line267"></a> 267     # === Collections
</span><span class="inferred0"><a name="line268"></a> 268     #
</span><span class="inferred1"><a name="line269"></a> 269     # * Adding an object to a collection (+has_many+ or +has_and_belongs_to_many+) automatically saves that object, except if the parent object
</span><span class="inferred0"><a name="line270"></a> 270     #   (the owner of the collection) is not yet stored in the database.
</span><span class="inferred1"><a name="line271"></a> 271     # * If saving any of the objects being added to a collection (via &lt;tt&gt;push&lt;/tt&gt; or similar) fails, then &lt;tt&gt;push&lt;/tt&gt; returns +false+.
</span><span class="inferred0"><a name="line272"></a> 272     # * You can add an object to a collection without automatically saving it by using the &lt;tt&gt;collection.build&lt;/tt&gt; method (documented below).
</span><span class="inferred1"><a name="line273"></a> 273     # * All unsaved (&lt;tt&gt;new_record? == true&lt;/tt&gt;) members of the collection are automatically saved when the parent is saved.
</span><span class="inferred0"><a name="line274"></a> 274     #
</span><span class="inferred1"><a name="line275"></a> 275     # === Association callbacks
</span><span class="inferred0"><a name="line276"></a> 276     #
</span><span class="inferred1"><a name="line277"></a> 277     # Similar to the normal callbacks that hook into the lifecycle of an Active Record object, you can also define callbacks that get
</span><span class="inferred0"><a name="line278"></a> 278     # triggered when you add an object to or remove an object from an association collection. Example:
</span><span class="inferred1"><a name="line279"></a> 279     #
</span><span class="inferred0"><a name="line280"></a> 280     #   class Project
</span><span class="inferred1"><a name="line281"></a> 281     #     has_and_belongs_to_many :developers, :after_add =&gt; :evaluate_velocity
</span><span class="inferred0"><a name="line282"></a> 282     #
</span><span class="inferred1"><a name="line283"></a> 283     #     def evaluate_velocity(developer)
</span><span class="inferred0"><a name="line284"></a> 284     #       ...
</span><span class="inferred1"><a name="line285"></a> 285     #     end
</span><span class="inferred0"><a name="line286"></a> 286     #   end
</span><span class="inferred1"><a name="line287"></a> 287     #
</span><span class="inferred0"><a name="line288"></a> 288     # It's possible to stack callbacks by passing them as an array. Example:
</span><span class="inferred1"><a name="line289"></a> 289     #
</span><span class="inferred0"><a name="line290"></a> 290     #   class Project
</span><span class="inferred1"><a name="line291"></a> 291     #     has_and_belongs_to_many :developers, :after_add =&gt; [:evaluate_velocity, Proc.new { |p, d| p.shipping_date = Time.now}]
</span><span class="inferred0"><a name="line292"></a> 292     #   end
</span><span class="inferred1"><a name="line293"></a> 293     #
</span><span class="inferred0"><a name="line294"></a> 294     # Possible callbacks are: +before_add+, +after_add+, +before_remove+ and +after_remove+.
</span><span class="inferred1"><a name="line295"></a> 295     #
</span><span class="inferred0"><a name="line296"></a> 296     # Should any of the +before_add+ callbacks throw an exception, the object does not get added to the collection. Same with
</span><span class="inferred1"><a name="line297"></a> 297     # the +before_remove+ callbacks; if an exception is thrown the object doesn't get removed.
</span><span class="inferred0"><a name="line298"></a> 298     #
</span><span class="inferred1"><a name="line299"></a> 299     # === Association extensions
</span><span class="inferred0"><a name="line300"></a> 300     #
</span><span class="inferred1"><a name="line301"></a> 301     # The proxy objects that control the access to associations can be extended through anonymous modules. This is especially
</span><span class="inferred0"><a name="line302"></a> 302     # beneficial for adding new finders, creators, and other factory-type methods that are only used as part of this association.
</span><span class="inferred1"><a name="line303"></a> 303     # Example:
</span><span class="inferred0"><a name="line304"></a> 304     #
</span><span class="inferred1"><a name="line305"></a> 305     #   class Account &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line306"></a> 306     #     has_many :people do
</span><span class="inferred1"><a name="line307"></a> 307     #       def find_or_create_by_name(name)
</span><span class="inferred0"><a name="line308"></a> 308     #         first_name, last_name = name.split(&quot; &quot;, 2)
</span><span class="inferred1"><a name="line309"></a> 309     #         find_or_create_by_first_name_and_last_name(first_name, last_name)
</span><span class="inferred0"><a name="line310"></a> 310     #       end
</span><span class="inferred1"><a name="line311"></a> 311     #     end
</span><span class="inferred0"><a name="line312"></a> 312     #   end
</span><span class="inferred1"><a name="line313"></a> 313     #
</span><span class="inferred0"><a name="line314"></a> 314     #   person = Account.find(:first).people.find_or_create_by_name(&quot;David Heinemeier Hansson&quot;)
</span><span class="inferred1"><a name="line315"></a> 315     #   person.first_name # =&gt; &quot;David&quot;
</span><span class="inferred0"><a name="line316"></a> 316     #   person.last_name  # =&gt; &quot;Heinemeier Hansson&quot;
</span><span class="inferred1"><a name="line317"></a> 317     #
</span><span class="inferred0"><a name="line318"></a> 318     # If you need to share the same extensions between many associations, you can use a named extension module. Example:
</span><span class="inferred1"><a name="line319"></a> 319     #
</span><span class="inferred0"><a name="line320"></a> 320     #   module FindOrCreateByNameExtension
</span><span class="inferred1"><a name="line321"></a> 321     #     def find_or_create_by_name(name)
</span><span class="inferred0"><a name="line322"></a> 322     #       first_name, last_name = name.split(&quot; &quot;, 2)
</span><span class="inferred1"><a name="line323"></a> 323     #       find_or_create_by_first_name_and_last_name(first_name, last_name)
</span><span class="inferred0"><a name="line324"></a> 324     #     end
</span><span class="inferred1"><a name="line325"></a> 325     #   end
</span><span class="inferred0"><a name="line326"></a> 326     #
</span><span class="inferred1"><a name="line327"></a> 327     #   class Account &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line328"></a> 328     #     has_many :people, :extend =&gt; FindOrCreateByNameExtension
</span><span class="inferred1"><a name="line329"></a> 329     #   end
</span><span class="inferred0"><a name="line330"></a> 330     #
</span><span class="inferred1"><a name="line331"></a> 331     #   class Company &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line332"></a> 332     #     has_many :people, :extend =&gt; FindOrCreateByNameExtension
</span><span class="inferred1"><a name="line333"></a> 333     #   end
</span><span class="inferred0"><a name="line334"></a> 334     #
</span><span class="inferred1"><a name="line335"></a> 335     # If you need to use multiple named extension modules, you can specify an array of modules with the &lt;tt&gt;:extend&lt;/tt&gt; option.
</span><span class="inferred0"><a name="line336"></a> 336     # In the case of name conflicts between methods in the modules, methods in modules later in the array supercede
</span><span class="inferred1"><a name="line337"></a> 337     # those earlier in the array. Example:
</span><span class="inferred0"><a name="line338"></a> 338     #
</span><span class="inferred1"><a name="line339"></a> 339     #   class Account &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line340"></a> 340     #     has_many :people, :extend =&gt; [FindOrCreateByNameExtension, FindRecentExtension]
</span><span class="inferred1"><a name="line341"></a> 341     #   end
</span><span class="inferred0"><a name="line342"></a> 342     #
</span><span class="inferred1"><a name="line343"></a> 343     # Some extensions can only be made to work with knowledge of the association proxy's internals.
</span><span class="inferred0"><a name="line344"></a> 344     # Extensions can access relevant state using accessors on the association proxy:
</span><span class="inferred1"><a name="line345"></a> 345     #
</span><span class="inferred0"><a name="line346"></a> 346     # * +proxy_owner+ - Returns the object the association is part of.
</span><span class="inferred1"><a name="line347"></a> 347     # * +proxy_reflection+ - Returns the reflection object that describes the association.
</span><span class="inferred0"><a name="line348"></a> 348     # * +proxy_target+ - Returns the associated object for +belongs_to+ and +has_one+, or the collection of associated objects for +has_many+ and +has_and_belongs_to_many+.
</span><span class="inferred1"><a name="line349"></a> 349     #
</span><span class="inferred0"><a name="line350"></a> 350     # === Association Join Models
</span><span class="inferred1"><a name="line351"></a> 351     #
</span><span class="inferred0"><a name="line352"></a> 352     # Has Many associations can be configured with the &lt;tt&gt;:through&lt;/tt&gt; option to use an explicit join model to retrieve the data.  This
</span><span class="inferred1"><a name="line353"></a> 353     # operates similarly to a +has_and_belongs_to_many+ association.  The advantage is that you're able to add validations,
</span><span class="inferred0"><a name="line354"></a> 354     # callbacks, and extra attributes on the join model.  Consider the following schema:
</span><span class="inferred1"><a name="line355"></a> 355     #
</span><span class="inferred0"><a name="line356"></a> 356     #   class Author &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line357"></a> 357     #     has_many :authorships
</span><span class="inferred0"><a name="line358"></a> 358     #     has_many :books, :through =&gt; :authorships
</span><span class="inferred1"><a name="line359"></a> 359     #   end
</span><span class="inferred0"><a name="line360"></a> 360     #
</span><span class="inferred1"><a name="line361"></a> 361     #   class Authorship &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line362"></a> 362     #     belongs_to :author
</span><span class="inferred1"><a name="line363"></a> 363     #     belongs_to :book
</span><span class="inferred0"><a name="line364"></a> 364     #   end
</span><span class="inferred1"><a name="line365"></a> 365     #
</span><span class="inferred0"><a name="line366"></a> 366     #   @author = Author.find :first
</span><span class="inferred1"><a name="line367"></a> 367     #   @author.authorships.collect { |a| a.book } # selects all books that the author's authorships belong to.
</span><span class="inferred0"><a name="line368"></a> 368     #   @author.books                              # selects all books by using the Authorship join model
</span><span class="inferred1"><a name="line369"></a> 369     #
</span><span class="inferred0"><a name="line370"></a> 370     # You can also go through a +has_many+ association on the join model:
</span><span class="inferred1"><a name="line371"></a> 371     #
</span><span class="inferred0"><a name="line372"></a> 372     #   class Firm &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line373"></a> 373     #     has_many   :clients
</span><span class="inferred0"><a name="line374"></a> 374     #     has_many   :invoices, :through =&gt; :clients
</span><span class="inferred1"><a name="line375"></a> 375     #   end
</span><span class="inferred0"><a name="line376"></a> 376     #
</span><span class="inferred1"><a name="line377"></a> 377     #   class Client &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line378"></a> 378     #     belongs_to :firm
</span><span class="inferred1"><a name="line379"></a> 379     #     has_many   :invoices
</span><span class="inferred0"><a name="line380"></a> 380     #   end
</span><span class="inferred1"><a name="line381"></a> 381     #
</span><span class="inferred0"><a name="line382"></a> 382     #   class Invoice &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line383"></a> 383     #     belongs_to :client
</span><span class="inferred0"><a name="line384"></a> 384     #   end
</span><span class="inferred1"><a name="line385"></a> 385     #
</span><span class="inferred0"><a name="line386"></a> 386     #   @firm = Firm.find :first
</span><span class="inferred1"><a name="line387"></a> 387     #   @firm.clients.collect { |c| c.invoices }.flatten # select all invoices for all clients of the firm
</span><span class="inferred0"><a name="line388"></a> 388     #   @firm.invoices                                   # selects all invoices by going through the Client join model.
</span><span class="inferred1"><a name="line389"></a> 389     #
</span><span class="inferred0"><a name="line390"></a> 390     # === Polymorphic Associations
</span><span class="inferred1"><a name="line391"></a> 391     #
</span><span class="inferred0"><a name="line392"></a> 392     # Polymorphic associations on models are not restricted on what types of models they can be associated with.  Rather, they
</span><span class="inferred1"><a name="line393"></a> 393     # specify an interface that a +has_many+ association must adhere to.
</span><span class="inferred0"><a name="line394"></a> 394     #
</span><span class="inferred1"><a name="line395"></a> 395     #   class Asset &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line396"></a> 396     #     belongs_to :attachable, :polymorphic =&gt; true
</span><span class="inferred1"><a name="line397"></a> 397     #   end
</span><span class="inferred0"><a name="line398"></a> 398     #
</span><span class="inferred1"><a name="line399"></a> 399     #   class Post &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line400"></a> 400     #     has_many :assets, :as =&gt; :attachable         # The :as option specifies the polymorphic interface to use.
</span><span class="inferred1"><a name="line401"></a> 401     #   end
</span><span class="inferred0"><a name="line402"></a> 402     #
</span><span class="inferred1"><a name="line403"></a> 403     #   @asset.attachable = @post
</span><span class="inferred0"><a name="line404"></a> 404     #
</span><span class="inferred1"><a name="line405"></a> 405     # This works by using a type column in addition to a foreign key to specify the associated record.  In the Asset example, you'd need
</span><span class="inferred0"><a name="line406"></a> 406     # an +attachable_id+ integer column and an +attachable_type+ string column.
</span><span class="inferred1"><a name="line407"></a> 407     #
</span><span class="inferred0"><a name="line408"></a> 408     # Using polymorphic associations in combination with single table inheritance (STI) is a little tricky. In order
</span><span class="inferred1"><a name="line409"></a> 409     # for the associations to work as expected, ensure that you store the base model for the STI models in the
</span><span class="inferred0"><a name="line410"></a> 410     # type column of the polymorphic association. To continue with the asset example above, suppose there are guest posts
</span><span class="inferred1"><a name="line411"></a> 411     # and member posts that use the posts table for STI. In this case, there must be a +type+ column in the posts table.
</span><span class="inferred0"><a name="line412"></a> 412     #
</span><span class="inferred1"><a name="line413"></a> 413     #   class Asset &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line414"></a> 414     #     belongs_to :attachable, :polymorphic =&gt; true
</span><span class="inferred1"><a name="line415"></a> 415     #
</span><span class="inferred0"><a name="line416"></a> 416     #     def attachable_type=(sType)
</span><span class="inferred1"><a name="line417"></a> 417     #        super(sType.to_s.classify.constantize.base_class.to_s)
</span><span class="inferred0"><a name="line418"></a> 418     #     end
</span><span class="inferred1"><a name="line419"></a> 419     #   end
</span><span class="inferred0"><a name="line420"></a> 420     #
</span><span class="inferred1"><a name="line421"></a> 421     #   class Post &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line422"></a> 422     #     # because we store &quot;Post&quot; in attachable_type now :dependent =&gt; :destroy will work
</span><span class="inferred1"><a name="line423"></a> 423     #     has_many :assets, :as =&gt; :attachable, :dependent =&gt; :destroy
</span><span class="inferred0"><a name="line424"></a> 424     #   end
</span><span class="inferred1"><a name="line425"></a> 425     #
</span><span class="inferred0"><a name="line426"></a> 426     #   class GuestPost &lt; Post
</span><span class="inferred1"><a name="line427"></a> 427     #   end
</span><span class="inferred0"><a name="line428"></a> 428     #
</span><span class="inferred1"><a name="line429"></a> 429     #   class MemberPost &lt; Post
</span><span class="inferred0"><a name="line430"></a> 430     #   end
</span><span class="inferred1"><a name="line431"></a> 431     #
</span><span class="inferred0"><a name="line432"></a> 432     # == Caching
</span><span class="inferred1"><a name="line433"></a> 433     #
</span><span class="inferred0"><a name="line434"></a> 434     # All of the methods are built on a simple caching principle that will keep the result of the last query around unless specifically
</span><span class="inferred1"><a name="line435"></a> 435     # instructed not to. The cache is even shared across methods to make it even cheaper to use the macro-added methods without
</span><span class="inferred0"><a name="line436"></a> 436     # worrying too much about performance at the first go. Example:
</span><span class="inferred1"><a name="line437"></a> 437     #
</span><span class="inferred0"><a name="line438"></a> 438     #   project.milestones             # fetches milestones from the database
</span><span class="inferred1"><a name="line439"></a> 439     #   project.milestones.size        # uses the milestone cache
</span><span class="inferred0"><a name="line440"></a> 440     #   project.milestones.empty?      # uses the milestone cache
</span><span class="inferred1"><a name="line441"></a> 441     #   project.milestones(true).size  # fetches milestones from the database
</span><span class="inferred0"><a name="line442"></a> 442     #   project.milestones             # uses the milestone cache
</span><span class="inferred1"><a name="line443"></a> 443     #
</span><span class="inferred0"><a name="line444"></a> 444     # == Eager loading of associations
</span><span class="inferred1"><a name="line445"></a> 445     #
</span><span class="inferred0"><a name="line446"></a> 446     # Eager loading is a way to find objects of a certain class and a number of named associations. This is
</span><span class="inferred1"><a name="line447"></a> 447     # one of the easiest ways of to prevent the dreaded 1+N problem in which fetching 100 posts that each need to display their author
</span><span class="inferred0"><a name="line448"></a> 448     # triggers 101 database queries. Through the use of eager loading, the 101 queries can be reduced to 2. Example:
</span><span class="inferred1"><a name="line449"></a> 449     #
</span><span class="inferred0"><a name="line450"></a> 450     #   class Post &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line451"></a> 451     #     belongs_to :author
</span><span class="inferred0"><a name="line452"></a> 452     #     has_many   :comments
</span><span class="inferred1"><a name="line453"></a> 453     #   end
</span><span class="inferred0"><a name="line454"></a> 454     #
</span><span class="inferred1"><a name="line455"></a> 455     # Consider the following loop using the class above:
</span><span class="inferred0"><a name="line456"></a> 456     #
</span><span class="inferred1"><a name="line457"></a> 457     #   for post in Post.all
</span><span class="inferred0"><a name="line458"></a> 458     #     puts &quot;Post:            &quot; + post.title
</span><span class="inferred1"><a name="line459"></a> 459     #     puts &quot;Written by:      &quot; + post.author.name
</span><span class="inferred0"><a name="line460"></a> 460     #     puts &quot;Last comment on: &quot; + post.comments.first.created_on
</span><span class="inferred1"><a name="line461"></a> 461     #   end
</span><span class="inferred0"><a name="line462"></a> 462     #
</span><span class="inferred1"><a name="line463"></a> 463     # To iterate over these one hundred posts, we'll generate 201 database queries. Let's first just optimize it for retrieving the author:
</span><span class="inferred0"><a name="line464"></a> 464     #
</span><span class="inferred1"><a name="line465"></a> 465     #   for post in Post.find(:all, :include =&gt; :author)
</span><span class="inferred0"><a name="line466"></a> 466     #
</span><span class="inferred1"><a name="line467"></a> 467     # This references the name of the +belongs_to+ association that also used the &lt;tt&gt;:author&lt;/tt&gt; symbol. After loading the posts, find
</span><span class="inferred0"><a name="line468"></a> 468     # will collect the +author_id+ from each one and load all the referenced authors with one query. Doing so will cut down the number of queries from 201 to 102.
</span><span class="inferred1"><a name="line469"></a> 469     #
</span><span class="inferred0"><a name="line470"></a> 470     # We can improve upon the situation further by referencing both associations in the finder with:
</span><span class="inferred1"><a name="line471"></a> 471     #
</span><span class="inferred0"><a name="line472"></a> 472     #   for post in Post.find(:all, :include =&gt; [ :author, :comments ])
</span><span class="inferred1"><a name="line473"></a> 473     #
</span><span class="inferred0"><a name="line474"></a> 474     # This will load all comments with a single query. This reduces the total number of queries to 3. More generally the number of queries
</span><span class="inferred1"><a name="line475"></a> 475     # will be 1 plus the number of associations named (except if some of the associations are polymorphic +belongs_to+ - see below).
</span><span class="inferred0"><a name="line476"></a> 476     #
</span><span class="inferred1"><a name="line477"></a> 477     # To include a deep hierarchy of associations, use a hash:
</span><span class="inferred0"><a name="line478"></a> 478     #
</span><span class="inferred1"><a name="line479"></a> 479     #   for post in Post.find(:all, :include =&gt; [ :author, { :comments =&gt; { :author =&gt; :gravatar } } ])
</span><span class="inferred0"><a name="line480"></a> 480     #
</span><span class="inferred1"><a name="line481"></a> 481     # That'll grab not only all the comments but all their authors and gravatar pictures.  You can mix and match
</span><span class="inferred0"><a name="line482"></a> 482     # symbols, arrays and hashes in any combination to describe the associations you want to load.
</span><span class="inferred1"><a name="line483"></a> 483     #
</span><span class="inferred0"><a name="line484"></a> 484     # All of this power shouldn't fool you into thinking that you can pull out huge amounts of data with no performance penalty just because you've reduced
</span><span class="inferred1"><a name="line485"></a> 485     # the number of queries. The database still needs to send all the data to Active Record and it still needs to be processed. So it's no
</span><span class="inferred0"><a name="line486"></a> 486     # catch-all for performance problems, but it's a great way to cut down on the number of queries in a situation as the one described above.
</span><span class="inferred1"><a name="line487"></a> 487     #
</span><span class="inferred0"><a name="line488"></a> 488     # Since only one table is loaded at a time, conditions or orders cannot reference tables other than the main one. If this is the case
</span><span class="inferred1"><a name="line489"></a> 489     # Active Record falls back to the previously used LEFT OUTER JOIN based strategy. For example
</span><span class="inferred0"><a name="line490"></a> 490     #  
</span><span class="inferred1"><a name="line491"></a> 491     #   Post.find(:all, :include =&gt; [ :author, :comments ], :conditions =&gt; ['comments.approved = ?', true])
</span><span class="inferred0"><a name="line492"></a> 492     #
</span><span class="inferred1"><a name="line493"></a> 493     # will result in a single SQL query with joins along the lines of: &lt;tt&gt;LEFT OUTER JOIN comments ON comments.post_id = posts.id&lt;/tt&gt; and
</span><span class="inferred0"><a name="line494"></a> 494     # &lt;tt&gt;LEFT OUTER JOIN authors ON authors.id = posts.author_id&lt;/tt&gt;. Note that using conditions like this can have unintended consequences.
</span><span class="inferred1"><a name="line495"></a> 495     # In the above example posts with no approved comments are not returned at all, because the conditions apply to the SQL statement as a whole
</span><span class="inferred0"><a name="line496"></a> 496     # and not just to the association. You must disambiguate column references for this fallback to happen, for example
</span><span class="inferred1"><a name="line497"></a> 497     # &lt;tt&gt;:order =&gt; &quot;author.name DESC&quot;&lt;/tt&gt; will work but &lt;tt&gt;:order =&gt; &quot;name DESC&quot;&lt;/tt&gt; will not. 
</span><span class="inferred0"><a name="line498"></a> 498     #
</span><span class="inferred1"><a name="line499"></a> 499     # If you do want eagerload only some members of an association it is usually more natural to &lt;tt&gt;:include&lt;/tt&gt; an association
</span><span class="inferred0"><a name="line500"></a> 500     # which has conditions defined on it:
</span><span class="inferred1"><a name="line501"></a> 501     #
</span><span class="inferred0"><a name="line502"></a> 502     #   class Post &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line503"></a> 503     #     has_many :approved_comments, :class_name =&gt; 'Comment', :conditions =&gt; ['approved = ?', true]
</span><span class="inferred0"><a name="line504"></a> 504     #   end
</span><span class="inferred1"><a name="line505"></a> 505     #
</span><span class="inferred0"><a name="line506"></a> 506     #   Post.find(:all, :include =&gt; :approved_comments)
</span><span class="inferred1"><a name="line507"></a> 507     #
</span><span class="inferred0"><a name="line508"></a> 508     # will load posts and eager load the +approved_comments+ association, which contains only those comments that have been approved.
</span><span class="inferred1"><a name="line509"></a> 509     #
</span><span class="inferred0"><a name="line510"></a> 510     # If you eager load an association with a specified &lt;tt&gt;:limit&lt;/tt&gt; option, it will be ignored, returning all the associated objects:
</span><span class="inferred1"><a name="line511"></a> 511     #
</span><span class="inferred0"><a name="line512"></a> 512     #   class Picture &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line513"></a> 513     #     has_many :most_recent_comments, :class_name =&gt; 'Comment', :order =&gt; 'id DESC', :limit =&gt; 10
</span><span class="inferred0"><a name="line514"></a> 514     #   end
</span><span class="inferred1"><a name="line515"></a> 515     #
</span><span class="inferred0"><a name="line516"></a> 516     #   Picture.find(:first, :include =&gt; :most_recent_comments).most_recent_comments # =&gt; returns all associated comments.
</span><span class="inferred1"><a name="line517"></a> 517     #
</span><span class="inferred0"><a name="line518"></a> 518     # When eager loaded, conditions are interpolated in the context of the model class, not the model instance.  Conditions are lazily interpolated
</span><span class="inferred1"><a name="line519"></a> 519     # before the actual model exists.
</span><span class="inferred0"><a name="line520"></a> 520     #
</span><span class="inferred1"><a name="line521"></a> 521     # Eager loading is supported with polymorphic associations.
</span><span class="inferred0"><a name="line522"></a> 522     #
</span><span class="inferred1"><a name="line523"></a> 523     #   class Address &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line524"></a> 524     #     belongs_to :addressable, :polymorphic =&gt; true
</span><span class="inferred1"><a name="line525"></a> 525     #   end
</span><span class="inferred0"><a name="line526"></a> 526     #
</span><span class="inferred1"><a name="line527"></a> 527     # A call that tries to eager load the addressable model
</span><span class="inferred0"><a name="line528"></a> 528     #
</span><span class="inferred1"><a name="line529"></a> 529     #   Address.find(:all, :include =&gt; :addressable)
</span><span class="inferred0"><a name="line530"></a> 530     #
</span><span class="inferred1"><a name="line531"></a> 531     # will execute one query to load the addresses and load the addressables with one query per addressable type. 
</span><span class="inferred0"><a name="line532"></a> 532     # For example if all the addressables are either of class Person or Company then a total of 3 queries will be executed. The list of
</span><span class="inferred1"><a name="line533"></a> 533     # addressable types to load is determined on the back of the addresses loaded. This is not supported if Active Record has to fallback
</span><span class="inferred0"><a name="line534"></a> 534     # to the previous implementation of eager loading and will raise ActiveRecord::EagerLoadPolymorphicError. The reason is that the parent 
</span><span class="inferred1"><a name="line535"></a> 535     # model's type is a column value so its corresponding table name cannot be put in the +FROM+/+JOIN+ clauses of that query.
</span><span class="inferred0"><a name="line536"></a> 536     #
</span><span class="inferred1"><a name="line537"></a> 537     # == Table Aliasing
</span><span class="inferred0"><a name="line538"></a> 538     #
</span><span class="inferred1"><a name="line539"></a> 539     # Active Record uses table aliasing in the case that a table is referenced multiple times in a join.  If a table is referenced only once,
</span><span class="inferred0"><a name="line540"></a> 540     # the standard table name is used.  The second time, the table is aliased as &lt;tt&gt;#{reflection_name}_#{parent_table_name}&lt;/tt&gt;.  Indexes are appended
</span><span class="inferred1"><a name="line541"></a> 541     # for any more successive uses of the table name.
</span><span class="inferred0"><a name="line542"></a> 542     #
</span><span class="inferred1"><a name="line543"></a> 543     #   Post.find :all, :joins =&gt; :comments
</span><span class="inferred0"><a name="line544"></a> 544     #   # =&gt; SELECT ... FROM posts INNER JOIN comments ON ...
</span><span class="inferred1"><a name="line545"></a> 545     #   Post.find :all, :joins =&gt; :special_comments # STI
</span><span class="inferred0"><a name="line546"></a> 546     #   # =&gt; SELECT ... FROM posts INNER JOIN comments ON ... AND comments.type = 'SpecialComment'
</span><span class="inferred1"><a name="line547"></a> 547     #   Post.find :all, :joins =&gt; [:comments, :special_comments] # special_comments is the reflection name, posts is the parent table name
</span><span class="inferred0"><a name="line548"></a> 548     #   # =&gt; SELECT ... FROM posts INNER JOIN comments ON ... INNER JOIN comments special_comments_posts
</span><span class="inferred1"><a name="line549"></a> 549     #
</span><span class="inferred0"><a name="line550"></a> 550     # Acts as tree example:
</span><span class="inferred1"><a name="line551"></a> 551     #
</span><span class="inferred0"><a name="line552"></a> 552     #   TreeMixin.find :all, :joins =&gt; :children
</span><span class="inferred1"><a name="line553"></a> 553     #   # =&gt; SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
</span><span class="inferred0"><a name="line554"></a> 554     #   TreeMixin.find :all, :joins =&gt; {:children =&gt; :parent}
</span><span class="inferred1"><a name="line555"></a> 555     #   # =&gt; SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
</span><span class="inferred0"><a name="line556"></a> 556     #                               INNER JOIN parents_mixins ...
</span><span class="inferred1"><a name="line557"></a> 557     #   TreeMixin.find :all, :joins =&gt; {:children =&gt; {:parent =&gt; :children}}
</span><span class="inferred0"><a name="line558"></a> 558     #   # =&gt; SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
</span><span class="inferred1"><a name="line559"></a> 559     #                               INNER JOIN parents_mixins ...
</span><span class="inferred0"><a name="line560"></a> 560     #                               INNER JOIN mixins childrens_mixins_2
</span><span class="inferred1"><a name="line561"></a> 561     #
</span><span class="inferred0"><a name="line562"></a> 562     # Has and Belongs to Many join tables use the same idea, but add a &lt;tt&gt;_join&lt;/tt&gt; suffix:
</span><span class="inferred1"><a name="line563"></a> 563     #
</span><span class="inferred0"><a name="line564"></a> 564     #   Post.find :all, :joins =&gt; :categories
</span><span class="inferred1"><a name="line565"></a> 565     #   # =&gt; SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
</span><span class="inferred0"><a name="line566"></a> 566     #   Post.find :all, :joins =&gt; {:categories =&gt; :posts}
</span><span class="inferred1"><a name="line567"></a> 567     #   # =&gt; SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
</span><span class="inferred0"><a name="line568"></a> 568     #                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
</span><span class="inferred1"><a name="line569"></a> 569     #   Post.find :all, :joins =&gt; {:categories =&gt; {:posts =&gt; :categories}}
</span><span class="inferred0"><a name="line570"></a> 570     #   # =&gt; SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
</span><span class="inferred1"><a name="line571"></a> 571     #                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
</span><span class="inferred0"><a name="line572"></a> 572     #                              INNER JOIN categories_posts categories_posts_join INNER JOIN categories categories_posts_2
</span><span class="inferred1"><a name="line573"></a> 573     #
</span><span class="inferred0"><a name="line574"></a> 574     # If you wish to specify your own custom joins using a &lt;tt&gt;:joins&lt;/tt&gt; option, those table names will take precedence over the eager associations:
</span><span class="inferred1"><a name="line575"></a> 575     #
</span><span class="inferred0"><a name="line576"></a> 576     #   Post.find :all, :joins =&gt; :comments, :joins =&gt; &quot;inner join comments ...&quot;
</span><span class="inferred1"><a name="line577"></a> 577     #   # =&gt; SELECT ... FROM posts INNER JOIN comments_posts ON ... INNER JOIN comments ...
</span><span class="inferred0"><a name="line578"></a> 578     #   Post.find :all, :joins =&gt; [:comments, :special_comments], :joins =&gt; &quot;inner join comments ...&quot;
</span><span class="inferred1"><a name="line579"></a> 579     #   # =&gt; SELECT ... FROM posts INNER JOIN comments comments_posts ON ...
</span><span class="inferred0"><a name="line580"></a> 580     #                              INNER JOIN comments special_comments_posts ...
</span><span class="inferred1"><a name="line581"></a> 581     #                              INNER JOIN comments ...
</span><span class="inferred0"><a name="line582"></a> 582     #
</span><span class="inferred1"><a name="line583"></a> 583     # Table aliases are automatically truncated according to the maximum length of table identifiers according to the specific database.
</span><span class="inferred0"><a name="line584"></a> 584     #
</span><span class="inferred1"><a name="line585"></a> 585     # == Modules
</span><span class="inferred0"><a name="line586"></a> 586     #
</span><span class="inferred1"><a name="line587"></a> 587     # By default, associations will look for objects within the current module scope. Consider:
</span><span class="inferred0"><a name="line588"></a> 588     #
</span><span class="inferred1"><a name="line589"></a> 589     #   module MyApplication
</span><span class="inferred0"><a name="line590"></a> 590     #     module Business
</span><span class="inferred1"><a name="line591"></a> 591     #       class Firm &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line592"></a> 592     #          has_many :clients
</span><span class="inferred1"><a name="line593"></a> 593     #        end
</span><span class="inferred0"><a name="line594"></a> 594     #
</span><span class="inferred1"><a name="line595"></a> 595     #       class Client &lt; ActiveRecord::Base; end
</span><span class="inferred0"><a name="line596"></a> 596     #     end
</span><span class="inferred1"><a name="line597"></a> 597     #   end
</span><span class="inferred0"><a name="line598"></a> 598     #
</span><span class="inferred1"><a name="line599"></a> 599     # When &lt;tt&gt;Firm#clients&lt;/tt&gt; is called, it will in turn call &lt;tt&gt;MyApplication::Business::Client.find_all_by_firm_id(firm.id)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line600"></a> 600     # If you want to associate with a class in another module scope, this can be done by specifying the complete class name.
</span><span class="inferred1"><a name="line601"></a> 601     # Example:
</span><span class="inferred0"><a name="line602"></a> 602     #
</span><span class="inferred1"><a name="line603"></a> 603     #   module MyApplication
</span><span class="inferred0"><a name="line604"></a> 604     #     module Business
</span><span class="inferred1"><a name="line605"></a> 605     #       class Firm &lt; ActiveRecord::Base; end
</span><span class="inferred0"><a name="line606"></a> 606     #     end
</span><span class="inferred1"><a name="line607"></a> 607     #
</span><span class="inferred0"><a name="line608"></a> 608     #     module Billing
</span><span class="inferred1"><a name="line609"></a> 609     #       class Account &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line610"></a> 610     #         belongs_to :firm, :class_name =&gt; &quot;MyApplication::Business::Firm&quot;
</span><span class="inferred1"><a name="line611"></a> 611     #       end
</span><span class="inferred0"><a name="line612"></a> 612     #     end
</span><span class="inferred1"><a name="line613"></a> 613     #   end
</span><span class="inferred0"><a name="line614"></a> 614     #
</span><span class="inferred1"><a name="line615"></a> 615     # == Type safety with &lt;tt&gt;ActiveRecord::AssociationTypeMismatch&lt;/tt&gt;
</span><span class="inferred0"><a name="line616"></a> 616     #
</span><span class="inferred1"><a name="line617"></a> 617     # If you attempt to assign an object to an association that doesn't match the inferred or specified &lt;tt&gt;:class_name&lt;/tt&gt;, you'll
</span><span class="inferred0"><a name="line618"></a> 618     # get an &lt;tt&gt;ActiveRecord::AssociationTypeMismatch&lt;/tt&gt;.
</span><span class="inferred1"><a name="line619"></a> 619     #
</span><span class="inferred0"><a name="line620"></a> 620     # == Options
</span><span class="inferred1"><a name="line621"></a> 621     #
</span><span class="inferred0"><a name="line622"></a> 622     # All of the association macros can be specialized through options. This makes cases more complex than the simple and guessable ones
</span><span class="inferred1"><a name="line623"></a> 623     # possible.
</span><span class="marked0"><a name="line624"></a> 624     module ClassMethods
</span><span class="inferred1"><a name="line625"></a> 625       # Specifies a one-to-many association. The following methods for retrieval and query of
</span><span class="inferred0"><a name="line626"></a> 626       # collections of associated objects will be added:
</span><span class="inferred1"><a name="line627"></a> 627       #
</span><span class="inferred0"><a name="line628"></a> 628       # [collection(force_reload = false)]
</span><span class="inferred1"><a name="line629"></a> 629       #   Returns an array of all the associated objects.
</span><span class="inferred0"><a name="line630"></a> 630       #   An empty array is returned if none are found.
</span><span class="inferred1"><a name="line631"></a> 631       # [collection&lt;&lt;(object, ...)]
</span><span class="inferred0"><a name="line632"></a> 632       #   Adds one or more objects to the collection by setting their foreign keys to the collection's primary key.
</span><span class="inferred1"><a name="line633"></a> 633       # [collection.delete(object, ...)]
</span><span class="inferred0"><a name="line634"></a> 634       #   Removes one or more objects from the collection by setting their foreign keys to +NULL+.
</span><span class="inferred1"><a name="line635"></a> 635       #   Objects will be in addition destroyed if they're associated with &lt;tt&gt;:dependent =&gt; :destroy&lt;/tt&gt;,
</span><span class="inferred0"><a name="line636"></a> 636       #   and deleted if they're associated with &lt;tt&gt;:dependent =&gt; :delete_all&lt;/tt&gt;.
</span><span class="inferred1"><a name="line637"></a> 637       # [collection=objects]
</span><span class="inferred0"><a name="line638"></a> 638       #   Replaces the collections content by deleting and adding objects as appropriate.
</span><span class="inferred1"><a name="line639"></a> 639       # [collection_singular_ids]
</span><span class="inferred0"><a name="line640"></a> 640       #   Returns an array of the associated objects' ids
</span><span class="inferred1"><a name="line641"></a> 641       # [collection_singular_ids=ids]
</span><span class="inferred0"><a name="line642"></a> 642       #   Replace the collection with the objects identified by the primary keys in +ids+
</span><span class="inferred1"><a name="line643"></a> 643       # [collection.clear]
</span><span class="inferred0"><a name="line644"></a> 644       #   Removes every object from the collection. This destroys the associated objects if they
</span><span class="inferred1"><a name="line645"></a> 645       #   are associated with &lt;tt&gt;:dependent =&gt; :destroy&lt;/tt&gt;, deletes them directly from the
</span><span class="inferred0"><a name="line646"></a> 646       #   database if &lt;tt&gt;:dependent =&gt; :delete_all&lt;/tt&gt;, otherwise sets their foreign keys to +NULL+.
</span><span class="inferred1"><a name="line647"></a> 647       # [collection.empty?]
</span><span class="inferred0"><a name="line648"></a> 648       #   Returns +true+ if there are no associated objects.
</span><span class="inferred1"><a name="line649"></a> 649       # [collection.size]
</span><span class="inferred0"><a name="line650"></a> 650       #   Returns the number of associated objects.
</span><span class="inferred1"><a name="line651"></a> 651       # [collection.find(...)]
</span><span class="inferred0"><a name="line652"></a> 652       #   Finds an associated object according to the same rules as ActiveRecord::Base.find.
</span><span class="inferred1"><a name="line653"></a> 653       # [collection.exist?(...)]
</span><span class="inferred0"><a name="line654"></a> 654       #   Checks whether an associated object with the given conditions exists.
</span><span class="inferred1"><a name="line655"></a> 655       #   Uses the same rules as ActiveRecord::Base.exists?.
</span><span class="inferred0"><a name="line656"></a> 656       # [collection.build(attributes = {}, ...)]
</span><span class="inferred1"><a name="line657"></a> 657       #   Returns one or more new objects of the collection type that have been instantiated
</span><span class="inferred0"><a name="line658"></a> 658       #   with +attributes+ and linked to this object through a foreign key, but have not yet
</span><span class="inferred1"><a name="line659"></a> 659       #   been saved. &lt;b&gt;Note:&lt;/b&gt; This only works if an associated object already exists, not if
</span><span class="inferred0"><a name="line660"></a> 660       #   it's +nil+!
</span><span class="inferred1"><a name="line661"></a> 661       # [collection.create(attributes = {})]
</span><span class="inferred0"><a name="line662"></a> 662       #   Returns a new object of the collection type that has been instantiated
</span><span class="inferred1"><a name="line663"></a> 663       #   with +attributes+, linked to this object through a foreign key, and that has already
</span><span class="inferred0"><a name="line664"></a> 664       #   been saved (if it passed the validation). &lt;b&gt;Note:&lt;/b&gt; This only works if an associated
</span><span class="inferred1"><a name="line665"></a> 665       #   object already exists, not if it's +nil+!
</span><span class="inferred0"><a name="line666"></a> 666       #
</span><span class="inferred1"><a name="line667"></a> 667       # (*Note*: +collection+ is replaced with the symbol passed as the first argument, so
</span><span class="inferred0"><a name="line668"></a> 668       # &lt;tt&gt;has_many :clients&lt;/tt&gt; would add among others &lt;tt&gt;clients.empty?&lt;/tt&gt;.)
</span><span class="inferred1"><a name="line669"></a> 669       #
</span><span class="inferred0"><a name="line670"></a> 670       # === Example
</span><span class="inferred1"><a name="line671"></a> 671       #
</span><span class="inferred0"><a name="line672"></a> 672       # Example: A Firm class declares &lt;tt&gt;has_many :clients&lt;/tt&gt;, which will add:
</span><span class="inferred1"><a name="line673"></a> 673       # * &lt;tt&gt;Firm#clients&lt;/tt&gt; (similar to &lt;tt&gt;Clients.find :all, :conditions =&gt; [&quot;firm_id = ?&quot;, id]&lt;/tt&gt;)
</span><span class="inferred0"><a name="line674"></a> 674       # * &lt;tt&gt;Firm#clients&lt;&lt;&lt;/tt&gt;
</span><span class="inferred1"><a name="line675"></a> 675       # * &lt;tt&gt;Firm#clients.delete&lt;/tt&gt;
</span><span class="inferred0"><a name="line676"></a> 676       # * &lt;tt&gt;Firm#clients=&lt;/tt&gt;
</span><span class="inferred1"><a name="line677"></a> 677       # * &lt;tt&gt;Firm#client_ids&lt;/tt&gt;
</span><span class="inferred0"><a name="line678"></a> 678       # * &lt;tt&gt;Firm#client_ids=&lt;/tt&gt;
</span><span class="inferred1"><a name="line679"></a> 679       # * &lt;tt&gt;Firm#clients.clear&lt;/tt&gt;
</span><span class="inferred0"><a name="line680"></a> 680       # * &lt;tt&gt;Firm#clients.empty?&lt;/tt&gt; (similar to &lt;tt&gt;firm.clients.size == 0&lt;/tt&gt;)
</span><span class="inferred1"><a name="line681"></a> 681       # * &lt;tt&gt;Firm#clients.size&lt;/tt&gt; (similar to &lt;tt&gt;Client.count &quot;firm_id = #{id}&quot;&lt;/tt&gt;)
</span><span class="inferred0"><a name="line682"></a> 682       # * &lt;tt&gt;Firm#clients.find&lt;/tt&gt; (similar to &lt;tt&gt;Client.find(id, :conditions =&gt; &quot;firm_id = #{id}&quot;)&lt;/tt&gt;)
</span><span class="inferred1"><a name="line683"></a> 683       # * &lt;tt&gt;Firm#clients.exist?(:name =&gt; 'ACME')&lt;/tt&gt; (similar to &lt;tt&gt;Client.exist?(:name =&gt; 'ACME', :firm_id =&gt; firm.id)&lt;/tt&gt;)
</span><span class="inferred0"><a name="line684"></a> 684       # * &lt;tt&gt;Firm#clients.build&lt;/tt&gt; (similar to &lt;tt&gt;Client.new(&quot;firm_id&quot; =&gt; id)&lt;/tt&gt;)
</span><span class="inferred1"><a name="line685"></a> 685       # * &lt;tt&gt;Firm#clients.create&lt;/tt&gt; (similar to &lt;tt&gt;c = Client.new(&quot;firm_id&quot; =&gt; id); c.save; c&lt;/tt&gt;)
</span><span class="inferred0"><a name="line686"></a> 686       # The declaration can also include an options hash to specialize the behavior of the association.
</span><span class="inferred1"><a name="line687"></a> 687       #
</span><span class="inferred0"><a name="line688"></a> 688       # === Supported options
</span><span class="inferred1"><a name="line689"></a> 689       # [:class_name]
</span><span class="inferred0"><a name="line690"></a> 690       #   Specify the class name of the association. Use it only if that name can't be inferred
</span><span class="inferred1"><a name="line691"></a> 691       #   from the association name. So &lt;tt&gt;has_many :products&lt;/tt&gt; will by default be linked to the Product class, but
</span><span class="inferred0"><a name="line692"></a> 692       #   if the real class name is SpecialProduct, you'll have to specify it with this option.
</span><span class="inferred1"><a name="line693"></a> 693       # [:conditions]
</span><span class="inferred0"><a name="line694"></a> 694       #   Specify the conditions that the associated objects must meet in order to be included as a +WHERE+
</span><span class="inferred1"><a name="line695"></a> 695       #   SQL fragment, such as &lt;tt&gt;price &gt; 5 AND name LIKE 'B%'&lt;/tt&gt;.  Record creations from the association are scoped if a hash
</span><span class="inferred0"><a name="line696"></a> 696       #   is used.  &lt;tt&gt;has_many :posts, :conditions =&gt; {:published =&gt; true}&lt;/tt&gt; will create published posts with &lt;tt&gt;@blog.posts.create&lt;/tt&gt;
</span><span class="inferred1"><a name="line697"></a> 697       #   or &lt;tt&gt;@blog.posts.build&lt;/tt&gt;.
</span><span class="inferred0"><a name="line698"></a> 698       # [:order]
</span><span class="inferred1"><a name="line699"></a> 699       #   Specify the order in which the associated objects are returned as an &lt;tt&gt;ORDER BY&lt;/tt&gt; SQL fragment,
</span><span class="inferred0"><a name="line700"></a> 700       #   such as &lt;tt&gt;last_name, first_name DESC&lt;/tt&gt;.
</span><span class="inferred1"><a name="line701"></a> 701       # [:foreign_key]
</span><span class="inferred0"><a name="line702"></a> 702       #   Specify the foreign key used for the association. By default this is guessed to be the name
</span><span class="inferred1"><a name="line703"></a> 703       #   of this class in lower-case and &quot;_id&quot; suffixed. So a Person class that makes a +has_many+ association will use &quot;person_id&quot;
</span><span class="inferred0"><a name="line704"></a> 704       #   as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;.
</span><span class="inferred1"><a name="line705"></a> 705       # [:primary_key]
</span><span class="inferred0"><a name="line706"></a> 706       #   Specify the method that returns the primary key used for the association. By default this is +id+.
</span><span class="inferred1"><a name="line707"></a> 707       # [:dependent]
</span><span class="inferred0"><a name="line708"></a> 708       #   If set to &lt;tt&gt;:destroy&lt;/tt&gt; all the associated objects are destroyed
</span><span class="inferred1"><a name="line709"></a> 709       #   alongside this object by calling their +destroy+ method.  If set to &lt;tt&gt;:delete_all&lt;/tt&gt; all associated
</span><span class="inferred0"><a name="line710"></a> 710       #   objects are deleted *without* calling their +destroy+ method.  If set to &lt;tt&gt;:nullify&lt;/tt&gt; all associated
</span><span class="inferred1"><a name="line711"></a> 711       #   objects' foreign keys are set to +NULL+ *without* calling their +save+ callbacks. *Warning:* This option is ignored when also using
</span><span class="inferred0"><a name="line712"></a> 712       #   the &lt;tt&gt;:through&lt;/tt&gt; option.
</span><span class="inferred1"><a name="line713"></a> 713       # [:finder_sql]
</span><span class="inferred0"><a name="line714"></a> 714       #   Specify a complete SQL statement to fetch the association. This is a good way to go for complex
</span><span class="inferred1"><a name="line715"></a> 715       #   associations that depend on multiple tables. Note: When this option is used, +find_in_collection+ is _not_ added.
</span><span class="inferred0"><a name="line716"></a> 716       # [:counter_sql]
</span><span class="inferred1"><a name="line717"></a> 717       #   Specify a complete SQL statement to fetch the size of the association. If &lt;tt&gt;:finder_sql&lt;/tt&gt; is
</span><span class="inferred0"><a name="line718"></a> 718       #   specified but not &lt;tt&gt;:counter_sql&lt;/tt&gt;, &lt;tt&gt;:counter_sql&lt;/tt&gt; will be generated by replacing &lt;tt&gt;SELECT ... FROM&lt;/tt&gt; with &lt;tt&gt;SELECT COUNT(*) FROM&lt;/tt&gt;.
</span><span class="inferred1"><a name="line719"></a> 719       # [:extend]
</span><span class="inferred0"><a name="line720"></a> 720       #   Specify a named module for extending the proxy. See &quot;Association extensions&quot;.
</span><span class="inferred1"><a name="line721"></a> 721       # [:include]
</span><span class="inferred0"><a name="line722"></a> 722       #   Specify second-order associations that should be eager loaded when the collection is loaded.
</span><span class="inferred1"><a name="line723"></a> 723       # [:group]
</span><span class="inferred0"><a name="line724"></a> 724       #   An attribute name by which the result should be grouped. Uses the &lt;tt&gt;GROUP BY&lt;/tt&gt; SQL-clause.
</span><span class="inferred1"><a name="line725"></a> 725       # [:limit]
</span><span class="inferred0"><a name="line726"></a> 726       #   An integer determining the limit on the number of rows that should be returned.
</span><span class="inferred1"><a name="line727"></a> 727       # [:offset]
</span><span class="inferred0"><a name="line728"></a> 728       #   An integer determining the offset from where the rows should be fetched. So at 5, it would skip the first 4 rows.
</span><span class="inferred1"><a name="line729"></a> 729       # [:select]
</span><span class="inferred0"><a name="line730"></a> 730       #   By default, this is &lt;tt&gt;*&lt;/tt&gt; as in &lt;tt&gt;SELECT * FROM&lt;/tt&gt;, but can be changed if you, for example, want to do a join
</span><span class="inferred1"><a name="line731"></a> 731       #   but not include the joined columns. Do not forget to include the primary and foreign keys, otherwise it will raise an error.
</span><span class="inferred0"><a name="line732"></a> 732       # [:as]
</span><span class="inferred1"><a name="line733"></a> 733       #   Specifies a polymorphic interface (See &lt;tt&gt;belongs_to&lt;/tt&gt;).
</span><span class="inferred0"><a name="line734"></a> 734       # [:through]
</span><span class="inferred1"><a name="line735"></a> 735       #   Specifies a Join Model through which to perform the query.  Options for &lt;tt&gt;:class_name&lt;/tt&gt; and &lt;tt&gt;:foreign_key&lt;/tt&gt;
</span><span class="inferred0"><a name="line736"></a> 736       #   are ignored, as the association uses the source reflection. You can only use a &lt;tt&gt;:through&lt;/tt&gt; query through a &lt;tt&gt;belongs_to&lt;/tt&gt;
</span><span class="inferred1"><a name="line737"></a> 737       #   or &lt;tt&gt;has_many&lt;/tt&gt; association on the join model.
</span><span class="inferred0"><a name="line738"></a> 738       # [:source]
</span><span class="inferred1"><a name="line739"></a> 739       #   Specifies the source association name used by &lt;tt&gt;has_many :through&lt;/tt&gt; queries.  Only use it if the name cannot be
</span><span class="inferred0"><a name="line740"></a> 740       #   inferred from the association.  &lt;tt&gt;has_many :subscribers, :through =&gt; :subscriptions&lt;/tt&gt; will look for either &lt;tt&gt;:subscribers&lt;/tt&gt; or
</span><span class="inferred1"><a name="line741"></a> 741       #   &lt;tt&gt;:subscriber&lt;/tt&gt; on Subscription, unless a &lt;tt&gt;:source&lt;/tt&gt; is given.
</span><span class="inferred0"><a name="line742"></a> 742       # [:source_type]
</span><span class="inferred1"><a name="line743"></a> 743       #   Specifies type of the source association used by &lt;tt&gt;has_many :through&lt;/tt&gt; queries where the source
</span><span class="inferred0"><a name="line744"></a> 744       #   association is a polymorphic +belongs_to+.
</span><span class="inferred1"><a name="line745"></a> 745       # [:uniq]
</span><span class="inferred0"><a name="line746"></a> 746       #   If true, duplicates will be omitted from the collection. Useful in conjunction with &lt;tt&gt;:through&lt;/tt&gt;.
</span><span class="inferred1"><a name="line747"></a> 747       # [:readonly]
</span><span class="inferred0"><a name="line748"></a> 748       #   If true, all the associated objects are readonly through the association.
</span><span class="inferred1"><a name="line749"></a> 749       # [:validate]
</span><span class="inferred0"><a name="line750"></a> 750       #   If false, don't validate the associated objects when saving the parent object. true by default.
</span><span class="inferred1"><a name="line751"></a> 751       # Option examples:
</span><span class="inferred0"><a name="line752"></a> 752       #   has_many :comments, :order =&gt; &quot;posted_on&quot;
</span><span class="inferred1"><a name="line753"></a> 753       #   has_many :comments, :include =&gt; :author
</span><span class="inferred0"><a name="line754"></a> 754       #   has_many :people, :class_name =&gt; &quot;Person&quot;, :conditions =&gt; &quot;deleted = 0&quot;, :order =&gt; &quot;name&quot;
</span><span class="inferred1"><a name="line755"></a> 755       #   has_many :tracks, :order =&gt; &quot;position&quot;, :dependent =&gt; :destroy
</span><span class="inferred0"><a name="line756"></a> 756       #   has_many :comments, :dependent =&gt; :nullify
</span><span class="inferred1"><a name="line757"></a> 757       #   has_many :tags, :as =&gt; :taggable
</span><span class="inferred0"><a name="line758"></a> 758       #   has_many :reports, :readonly =&gt; true
</span><span class="inferred1"><a name="line759"></a> 759       #   has_many :subscribers, :through =&gt; :subscriptions, :source =&gt; :user
</span><span class="inferred0"><a name="line760"></a> 760       #   has_many :subscribers, :class_name =&gt; &quot;Person&quot;, :finder_sql =&gt;
</span><span class="inferred1"><a name="line761"></a> 761       #       'SELECT DISTINCT people.* ' +
</span><span class="inferred0"><a name="line762"></a> 762       #       'FROM people p, post_subscriptions ps ' +
</span><span class="inferred1"><a name="line763"></a> 763       #       'WHERE ps.post_id = #{id} AND ps.person_id = p.id ' +
</span><span class="inferred0"><a name="line764"></a> 764       #       'ORDER BY p.first_name'
</span><span class="marked1"><a name="line765"></a> 765       def has_many(association_id, options = {}, &amp;extension)
</span><span class="marked0"><a name="line766"></a> 766         reflection = create_has_many_reflection(association_id, options, &amp;extension)
</span><span class="inferred1"><a name="line767"></a> 767 
</span><span class="marked0"><a name="line768"></a> 768         configure_dependency_for_has_many(reflection)
</span><span class="inferred1"><a name="line769"></a> 769 
</span><span class="marked0"><a name="line770"></a> 770         add_multiple_associated_validation_callbacks(reflection.name) unless options[:validate] == false
</span><span class="marked1"><a name="line771"></a> 771         add_multiple_associated_save_callbacks(reflection.name)
</span><span class="marked0"><a name="line772"></a> 772         add_association_callbacks(reflection.name, reflection.options)
</span><span class="inferred1"><a name="line773"></a> 773 
</span><span class="marked0"><a name="line774"></a> 774         if options[:through]
</span><span class="uncovered1"><a name="line775"></a> 775           collection_accessor_methods(reflection, HasManyThroughAssociation)
</span><span class="inferred0"><a name="line776"></a> 776         else
</span><span class="marked1"><a name="line777"></a> 777           collection_accessor_methods(reflection, HasManyAssociation)
</span><span class="inferred0"><a name="line778"></a> 778         end
</span><span class="inferred1"><a name="line779"></a> 779       end
</span><span class="inferred0"><a name="line780"></a> 780 
</span><span class="inferred1"><a name="line781"></a> 781       # Specifies a one-to-one association with another class. This method should only be used
</span><span class="inferred0"><a name="line782"></a> 782       # if the other class contains the foreign key. If the current class contains the foreign key,
</span><span class="inferred1"><a name="line783"></a> 783       # then you should use +belongs_to+ instead. See also ActiveRecord::Associations::ClassMethods's overview
</span><span class="inferred0"><a name="line784"></a> 784       # on when to use has_one and when to use belongs_to.
</span><span class="inferred1"><a name="line785"></a> 785       #
</span><span class="inferred0"><a name="line786"></a> 786       # The following methods for retrieval and query of a single associated object will be added:
</span><span class="inferred1"><a name="line787"></a> 787       #
</span><span class="inferred0"><a name="line788"></a> 788       # [association(force_reload = false)]
</span><span class="inferred1"><a name="line789"></a> 789       #   Returns the associated object. +nil+ is returned if none is found.
</span><span class="inferred0"><a name="line790"></a> 790       # [association=(associate)]
</span><span class="inferred1"><a name="line791"></a> 791       #   Assigns the associate object, extracts the primary key, sets it as the foreign key,
</span><span class="inferred0"><a name="line792"></a> 792       #   and saves the associate object.
</span><span class="inferred1"><a name="line793"></a> 793       # [association.nil?]
</span><span class="inferred0"><a name="line794"></a> 794       #   Returns +true+ if there is no associated object.
</span><span class="inferred1"><a name="line795"></a> 795       # [build_association(attributes = {})]
</span><span class="inferred0"><a name="line796"></a> 796       #   Returns a new object of the associated type that has been instantiated
</span><span class="inferred1"><a name="line797"></a> 797       #   with +attributes+ and linked to this object through a foreign key, but has not
</span><span class="inferred0"><a name="line798"></a> 798       #   yet been saved. &lt;b&gt;Note:&lt;/b&gt; This ONLY works if an association already exists.
</span><span class="inferred1"><a name="line799"></a> 799       #   It will NOT work if the association is +nil+.
</span><span class="inferred0"><a name="line800"></a> 800       # [create_association(attributes = {})]
</span><span class="inferred1"><a name="line801"></a> 801       #   Returns a new object of the associated type that has been instantiated
</span><span class="inferred0"><a name="line802"></a> 802       #   with +attributes+, linked to this object through a foreign key, and that
</span><span class="inferred1"><a name="line803"></a> 803       #   has already been saved (if it passed the validation).
</span><span class="inferred0"><a name="line804"></a> 804       #
</span><span class="inferred1"><a name="line805"></a> 805       # (+association+ is replaced with the symbol passed as the first argument, so
</span><span class="inferred0"><a name="line806"></a> 806       # &lt;tt&gt;has_one :manager&lt;/tt&gt; would add among others &lt;tt&gt;manager.nil?&lt;/tt&gt;.)
</span><span class="inferred1"><a name="line807"></a> 807       #
</span><span class="inferred0"><a name="line808"></a> 808       # === Example
</span><span class="inferred1"><a name="line809"></a> 809       #
</span><span class="inferred0"><a name="line810"></a> 810       # An Account class declares &lt;tt&gt;has_one :beneficiary&lt;/tt&gt;, which will add:
</span><span class="inferred1"><a name="line811"></a> 811       # * &lt;tt&gt;Account#beneficiary&lt;/tt&gt; (similar to &lt;tt&gt;Beneficiary.find(:first, :conditions =&gt; &quot;account_id = #{id}&quot;)&lt;/tt&gt;)
</span><span class="inferred0"><a name="line812"></a> 812       # * &lt;tt&gt;Account#beneficiary=(beneficiary)&lt;/tt&gt; (similar to &lt;tt&gt;beneficiary.account_id = account.id; beneficiary.save&lt;/tt&gt;)
</span><span class="inferred1"><a name="line813"></a> 813       # * &lt;tt&gt;Account#beneficiary.nil?&lt;/tt&gt;
</span><span class="inferred0"><a name="line814"></a> 814       # * &lt;tt&gt;Account#build_beneficiary&lt;/tt&gt; (similar to &lt;tt&gt;Beneficiary.new(&quot;account_id&quot; =&gt; id)&lt;/tt&gt;)
</span><span class="inferred1"><a name="line815"></a> 815       # * &lt;tt&gt;Account#create_beneficiary&lt;/tt&gt; (similar to &lt;tt&gt;b = Beneficiary.new(&quot;account_id&quot; =&gt; id); b.save; b&lt;/tt&gt;)
</span><span class="inferred0"><a name="line816"></a> 816       #
</span><span class="inferred1"><a name="line817"></a> 817       # === Options
</span><span class="inferred0"><a name="line818"></a> 818       #
</span><span class="inferred1"><a name="line819"></a> 819       # The declaration can also include an options hash to specialize the behavior of the association.
</span><span class="inferred0"><a name="line820"></a> 820       #
</span><span class="inferred1"><a name="line821"></a> 821       # Options are:
</span><span class="inferred0"><a name="line822"></a> 822       # [:class_name]
</span><span class="inferred1"><a name="line823"></a> 823       #   Specify the class name of the association. Use it only if that name can't be inferred
</span><span class="inferred0"><a name="line824"></a> 824       #   from the association name. So &lt;tt&gt;has_one :manager&lt;/tt&gt; will by default be linked to the Manager class, but
</span><span class="inferred1"><a name="line825"></a> 825       #   if the real class name is Person, you'll have to specify it with this option.
</span><span class="inferred0"><a name="line826"></a> 826       # [:conditions]
</span><span class="inferred1"><a name="line827"></a> 827       #   Specify the conditions that the associated object must meet in order to be included as a +WHERE+
</span><span class="inferred0"><a name="line828"></a> 828       #   SQL fragment, such as &lt;tt&gt;rank = 5&lt;/tt&gt;.
</span><span class="inferred1"><a name="line829"></a> 829       # [:order]
</span><span class="inferred0"><a name="line830"></a> 830       #   Specify the order in which the associated objects are returned as an &lt;tt&gt;ORDER BY&lt;/tt&gt; SQL fragment,
</span><span class="inferred1"><a name="line831"></a> 831       #   such as &lt;tt&gt;last_name, first_name DESC&lt;/tt&gt;.
</span><span class="inferred0"><a name="line832"></a> 832       # [:dependent]
</span><span class="inferred1"><a name="line833"></a> 833       #   If set to &lt;tt&gt;:destroy&lt;/tt&gt;, the associated object is destroyed when this object is. If set to
</span><span class="inferred0"><a name="line834"></a> 834       #   &lt;tt&gt;:delete&lt;/tt&gt;, the associated object is deleted *without* calling its destroy method. If set to &lt;tt&gt;:nullify&lt;/tt&gt;, the associated
</span><span class="inferred1"><a name="line835"></a> 835       #   object's foreign key is set to +NULL+. Also, association is assigned.
</span><span class="inferred0"><a name="line836"></a> 836       # [:foreign_key]
</span><span class="inferred1"><a name="line837"></a> 837       #   Specify the foreign key used for the association. By default this is guessed to be the name
</span><span class="inferred0"><a name="line838"></a> 838       #   of this class in lower-case and &quot;_id&quot; suffixed. So a Person class that makes a +has_one+ association will use &quot;person_id&quot;
</span><span class="inferred1"><a name="line839"></a> 839       #   as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;.
</span><span class="inferred0"><a name="line840"></a> 840       # [:primary_key]
</span><span class="inferred1"><a name="line841"></a> 841       #   Specify the method that returns the primary key used for the association. By default this is +id+.
</span><span class="inferred0"><a name="line842"></a> 842       # [:include]
</span><span class="inferred1"><a name="line843"></a> 843       #   Specify second-order associations that should be eager loaded when this object is loaded.
</span><span class="inferred0"><a name="line844"></a> 844       # [:as]
</span><span class="inferred1"><a name="line845"></a> 845       #   Specifies a polymorphic interface (See &lt;tt&gt;belongs_to&lt;/tt&gt;).
</span><span class="inferred0"><a name="line846"></a> 846       # [:select]
</span><span class="inferred1"><a name="line847"></a> 847       #   By default, this is &lt;tt&gt;*&lt;/tt&gt; as in &lt;tt&gt;SELECT * FROM&lt;/tt&gt;, but can be changed if, for example, you want to do a join
</span><span class="inferred0"><a name="line848"></a> 848       #   but not include the joined columns. Do not forget to include the primary and foreign keys, otherwise it will raise an error.
</span><span class="inferred1"><a name="line849"></a> 849       # [:through]
</span><span class="inferred0"><a name="line850"></a> 850       #   Specifies a Join Model through which to perform the query.  Options for &lt;tt&gt;:class_name&lt;/tt&gt; and &lt;tt&gt;:foreign_key&lt;/tt&gt;
</span><span class="inferred1"><a name="line851"></a> 851       #   are ignored, as the association uses the source reflection. You can only use a &lt;tt&gt;:through&lt;/tt&gt; query through a 
</span><span class="inferred0"><a name="line852"></a> 852       #   &lt;tt&gt;has_one&lt;/tt&gt; or &lt;tt&gt;belongs_to&lt;/tt&gt; association on the join model.
</span><span class="inferred1"><a name="line853"></a> 853       # [:source]
</span><span class="inferred0"><a name="line854"></a> 854       #   Specifies the source association name used by &lt;tt&gt;has_one :through&lt;/tt&gt; queries.  Only use it if the name cannot be
</span><span class="inferred1"><a name="line855"></a> 855       #   inferred from the association.  &lt;tt&gt;has_one :favorite, :through =&gt; :favorites&lt;/tt&gt; will look for a
</span><span class="inferred0"><a name="line856"></a> 856       #   &lt;tt&gt;:favorite&lt;/tt&gt; on Favorite, unless a &lt;tt&gt;:source&lt;/tt&gt; is given.      
</span><span class="inferred1"><a name="line857"></a> 857       # [:source_type]
</span><span class="inferred0"><a name="line858"></a> 858       #   Specifies type of the source association used by &lt;tt&gt;has_one :through&lt;/tt&gt; queries where the source
</span><span class="inferred1"><a name="line859"></a> 859       #   association is a polymorphic +belongs_to+.      
</span><span class="inferred0"><a name="line860"></a> 860       # [:readonly]
</span><span class="inferred1"><a name="line861"></a> 861       #   If true, the associated object is readonly through the association.
</span><span class="inferred0"><a name="line862"></a> 862       # [:validate]
</span><span class="inferred1"><a name="line863"></a> 863       #   If false, don't validate the associated object when saving the parent object. +false+ by default.
</span><span class="inferred0"><a name="line864"></a> 864       #
</span><span class="inferred1"><a name="line865"></a> 865       # Option examples:
</span><span class="inferred0"><a name="line866"></a> 866       #   has_one :credit_card, :dependent =&gt; :destroy  # destroys the associated credit card
</span><span class="inferred1"><a name="line867"></a> 867       #   has_one :credit_card, :dependent =&gt; :nullify  # updates the associated records foreign key value to NULL rather than destroying it
</span><span class="inferred0"><a name="line868"></a> 868       #   has_one :last_comment, :class_name =&gt; &quot;Comment&quot;, :order =&gt; &quot;posted_on&quot;
</span><span class="inferred1"><a name="line869"></a> 869       #   has_one :project_manager, :class_name =&gt; &quot;Person&quot;, :conditions =&gt; &quot;role = 'project_manager'&quot;
</span><span class="inferred0"><a name="line870"></a> 870       #   has_one :attachment, :as =&gt; :attachable
</span><span class="inferred1"><a name="line871"></a> 871       #   has_one :boss, :readonly =&gt; :true
</span><span class="inferred0"><a name="line872"></a> 872       #   has_one :club, :through =&gt; :membership
</span><span class="inferred1"><a name="line873"></a> 873       #   has_one :primary_address, :through =&gt; :addressables, :conditions =&gt; [&quot;addressable.primary = ?&quot;, true], :source =&gt; :addressable
</span><span class="marked0"><a name="line874"></a> 874       def has_one(association_id, options = {})
</span><span class="uncovered1"><a name="line875"></a> 875         if options[:through]
</span><span class="uncovered0"><a name="line876"></a> 876           reflection = create_has_one_through_reflection(association_id, options)
</span><span class="uncovered1"><a name="line877"></a> 877           association_accessor_methods(reflection, ActiveRecord::Associations::HasOneThroughAssociation)
</span><span class="uncovered0"><a name="line878"></a> 878         else
</span><span class="uncovered1"><a name="line879"></a> 879           reflection = create_has_one_reflection(association_id, options)
</span><span class="uncovered0"><a name="line880"></a> 880 
</span><span class="uncovered1"><a name="line881"></a> 881           ivar = &quot;@#{reflection.name}&quot;
</span><span class="uncovered0"><a name="line882"></a> 882 
</span><span class="uncovered1"><a name="line883"></a> 883           method_name = &quot;has_one_after_save_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line884"></a> 884           define_method(method_name) do
</span><span class="uncovered1"><a name="line885"></a> 885             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered0"><a name="line886"></a> 886 
</span><span class="uncovered1"><a name="line887"></a> 887             if !association.nil? &amp;&amp; (new_record? || association.new_record? || association[reflection.primary_key_name] != id)
</span><span class="uncovered0"><a name="line888"></a> 888               association[reflection.primary_key_name] = id
</span><span class="uncovered1"><a name="line889"></a> 889               association.save(true)
</span><span class="uncovered0"><a name="line890"></a> 890             end
</span><span class="uncovered1"><a name="line891"></a> 891           end
</span><span class="uncovered0"><a name="line892"></a> 892           after_save method_name
</span><span class="uncovered1"><a name="line893"></a> 893 
</span><span class="uncovered0"><a name="line894"></a> 894           add_single_associated_validation_callbacks(reflection.name) if options[:validate] == true
</span><span class="uncovered1"><a name="line895"></a> 895           association_accessor_methods(reflection, HasOneAssociation)
</span><span class="uncovered0"><a name="line896"></a> 896           association_constructor_method(:build,  reflection, HasOneAssociation)
</span><span class="uncovered1"><a name="line897"></a> 897           association_constructor_method(:create, reflection, HasOneAssociation)
</span><span class="uncovered0"><a name="line898"></a> 898 
</span><span class="uncovered1"><a name="line899"></a> 899           configure_dependency_for_has_one(reflection)
</span><span class="uncovered0"><a name="line900"></a> 900         end
</span><span class="uncovered1"><a name="line901"></a> 901       end
</span><span class="inferred0"><a name="line902"></a> 902 
</span><span class="inferred1"><a name="line903"></a> 903       # Specifies a one-to-one association with another class. This method should only be used
</span><span class="inferred0"><a name="line904"></a> 904       # if this class contains the foreign key. If the other class contains the foreign key,
</span><span class="inferred1"><a name="line905"></a> 905       # then you should use +has_one+ instead. See also ActiveRecord::Associations::ClassMethods's overview
</span><span class="inferred0"><a name="line906"></a> 906       # on when to use +has_one+ and when to use +belongs_to+.
</span><span class="inferred1"><a name="line907"></a> 907       #
</span><span class="inferred0"><a name="line908"></a> 908       # Methods will be added for retrieval and query for a single associated object, for which
</span><span class="inferred1"><a name="line909"></a> 909       # this object holds an id:
</span><span class="inferred0"><a name="line910"></a> 910       #
</span><span class="inferred1"><a name="line911"></a> 911       # [association(force_reload = false)]
</span><span class="inferred0"><a name="line912"></a> 912       #   Returns the associated object. +nil+ is returned if none is found.
</span><span class="inferred1"><a name="line913"></a> 913       # [association=(associate)]
</span><span class="inferred0"><a name="line914"></a> 914       #   Assigns the associate object, extracts the primary key, and sets it as the foreign key.
</span><span class="inferred1"><a name="line915"></a> 915       # [association.nil?]
</span><span class="inferred0"><a name="line916"></a> 916       #   Returns +true+ if there is no associated object.
</span><span class="inferred1"><a name="line917"></a> 917       # [build_association(attributes = {})]
</span><span class="inferred0"><a name="line918"></a> 918       #   Returns a new object of the associated type that has been instantiated
</span><span class="inferred1"><a name="line919"></a> 919       #   with +attributes+ and linked to this object through a foreign key, but has not yet been saved.
</span><span class="inferred0"><a name="line920"></a> 920       # [create_association(attributes = {})]
</span><span class="inferred1"><a name="line921"></a> 921       #   Returns a new object of the associated type that has been instantiated
</span><span class="inferred0"><a name="line922"></a> 922       #   with +attributes+, linked to this object through a foreign key, and that
</span><span class="inferred1"><a name="line923"></a> 923       #   has already been saved (if it passed the validation).
</span><span class="inferred0"><a name="line924"></a> 924       #
</span><span class="inferred1"><a name="line925"></a> 925       # (+association+ is replaced with the symbol passed as the first argument, so
</span><span class="inferred0"><a name="line926"></a> 926       # &lt;tt&gt;belongs_to :author&lt;/tt&gt; would add among others &lt;tt&gt;author.nil?&lt;/tt&gt;.)
</span><span class="inferred1"><a name="line927"></a> 927       #
</span><span class="inferred0"><a name="line928"></a> 928       # === Example
</span><span class="inferred1"><a name="line929"></a> 929       #
</span><span class="inferred0"><a name="line930"></a> 930       # A Post class declares &lt;tt&gt;belongs_to :author&lt;/tt&gt;, which will add:
</span><span class="inferred1"><a name="line931"></a> 931       # * &lt;tt&gt;Post#author&lt;/tt&gt; (similar to &lt;tt&gt;Author.find(author_id)&lt;/tt&gt;)
</span><span class="inferred0"><a name="line932"></a> 932       # * &lt;tt&gt;Post#author=(author)&lt;/tt&gt; (similar to &lt;tt&gt;post.author_id = author.id&lt;/tt&gt;)
</span><span class="inferred1"><a name="line933"></a> 933       # * &lt;tt&gt;Post#author?&lt;/tt&gt; (similar to &lt;tt&gt;post.author == some_author&lt;/tt&gt;)
</span><span class="inferred0"><a name="line934"></a> 934       # * &lt;tt&gt;Post#author.nil?&lt;/tt&gt;
</span><span class="inferred1"><a name="line935"></a> 935       # * &lt;tt&gt;Post#build_author&lt;/tt&gt; (similar to &lt;tt&gt;post.author = Author.new&lt;/tt&gt;)
</span><span class="inferred0"><a name="line936"></a> 936       # * &lt;tt&gt;Post#create_author&lt;/tt&gt; (similar to &lt;tt&gt;post.author = Author.new; post.author.save; post.author&lt;/tt&gt;)
</span><span class="inferred1"><a name="line937"></a> 937       # The declaration can also include an options hash to specialize the behavior of the association.
</span><span class="inferred0"><a name="line938"></a> 938       #
</span><span class="inferred1"><a name="line939"></a> 939       # === Options
</span><span class="inferred0"><a name="line940"></a> 940       #
</span><span class="inferred1"><a name="line941"></a> 941       # [:class_name]
</span><span class="inferred0"><a name="line942"></a> 942       #   Specify the class name of the association. Use it only if that name can't be inferred
</span><span class="inferred1"><a name="line943"></a> 943       #   from the association name. So &lt;tt&gt;has_one :author&lt;/tt&gt; will by default be linked to the Author class, but
</span><span class="inferred0"><a name="line944"></a> 944       #   if the real class name is Person, you'll have to specify it with this option.
</span><span class="inferred1"><a name="line945"></a> 945       # [:conditions]
</span><span class="inferred0"><a name="line946"></a> 946       #   Specify the conditions that the associated object must meet in order to be included as a +WHERE+
</span><span class="inferred1"><a name="line947"></a> 947       #   SQL fragment, such as &lt;tt&gt;authorized = 1&lt;/tt&gt;.
</span><span class="inferred0"><a name="line948"></a> 948       # [:select]
</span><span class="inferred1"><a name="line949"></a> 949       #   By default, this is &lt;tt&gt;*&lt;/tt&gt; as in &lt;tt&gt;SELECT * FROM&lt;/tt&gt;, but can be changed if, for example, you want to do a join
</span><span class="inferred0"><a name="line950"></a> 950       #   but not include the joined columns. Do not forget to include the primary and foreign keys, otherwise it will raise an error.
</span><span class="inferred1"><a name="line951"></a> 951       # [:foreign_key]
</span><span class="inferred0"><a name="line952"></a> 952       #   Specify the foreign key used for the association. By default this is guessed to be the name
</span><span class="inferred1"><a name="line953"></a> 953       #   of the association with an &quot;_id&quot; suffix. So a class that defines a &lt;tt&gt;belongs_to :person&lt;/tt&gt; association will use
</span><span class="inferred0"><a name="line954"></a> 954       #   &quot;person_id&quot; as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;. Similarly, &lt;tt&gt;belongs_to :favorite_person, :class_name =&gt; &quot;Person&quot;&lt;/tt&gt;
</span><span class="inferred1"><a name="line955"></a> 955       #   will use a foreign key of &quot;favorite_person_id&quot;.
</span><span class="inferred0"><a name="line956"></a> 956       # [:dependent]
</span><span class="inferred1"><a name="line957"></a> 957       #   If set to &lt;tt&gt;:destroy&lt;/tt&gt;, the associated object is destroyed when this object is. If set to
</span><span class="inferred0"><a name="line958"></a> 958       #   &lt;tt&gt;:delete&lt;/tt&gt;, the associated object is deleted *without* calling its destroy method. This option should not be specified when
</span><span class="inferred1"><a name="line959"></a> 959       #   &lt;tt&gt;belongs_to&lt;/tt&gt; is used in conjunction with a &lt;tt&gt;has_many&lt;/tt&gt; relationship on another class because of the potential to leave
</span><span class="inferred0"><a name="line960"></a> 960       #   orphaned records behind.
</span><span class="inferred1"><a name="line961"></a> 961       # [:counter_cache]
</span><span class="inferred0"><a name="line962"></a> 962       #   Caches the number of belonging objects on the associate class through the use of +increment_counter+
</span><span class="inferred1"><a name="line963"></a> 963       #   and +decrement_counter+. The counter cache is incremented when an object of this class is created and decremented when it's
</span><span class="inferred0"><a name="line964"></a> 964       #   destroyed. This requires that a column named &lt;tt&gt;#{table_name}_count&lt;/tt&gt; (such as +comments_count+ for a belonging Comment class)
</span><span class="inferred1"><a name="line965"></a> 965       #   is used on the associate class (such as a Post class). You can also specify a custom counter cache column by providing
</span><span class="inferred0"><a name="line966"></a> 966       #   a column name instead of a +true+/+false+ value to this option (e.g., &lt;tt&gt;:counter_cache =&gt; :my_custom_counter&lt;/tt&gt;.)
</span><span class="inferred1"><a name="line967"></a> 967       #   Note: Specifying a counter cache will add it to that model's list of readonly attributes using +attr_readonly+.
</span><span class="inferred0"><a name="line968"></a> 968       # [:include]
</span><span class="inferred1"><a name="line969"></a> 969       #   Specify second-order associations that should be eager loaded when this object is loaded.
</span><span class="inferred0"><a name="line970"></a> 970       # [:polymorphic]
</span><span class="inferred1"><a name="line971"></a> 971       #   Specify this association is a polymorphic association by passing +true+.
</span><span class="inferred0"><a name="line972"></a> 972       #   Note: If you've enabled the counter cache, then you may want to add the counter cache attribute
</span><span class="inferred1"><a name="line973"></a> 973       #   to the +attr_readonly+ list in the associated classes (e.g. &lt;tt&gt;class Post; attr_readonly :comments_count; end&lt;/tt&gt;).
</span><span class="inferred0"><a name="line974"></a> 974       # [:readonly]
</span><span class="inferred1"><a name="line975"></a> 975       #   If true, the associated object is readonly through the association.
</span><span class="inferred0"><a name="line976"></a> 976       # [:validate]
</span><span class="inferred1"><a name="line977"></a> 977       #   If false, don't validate the associated objects when saving the parent object. +false+ by default.
</span><span class="inferred0"><a name="line978"></a> 978       #
</span><span class="inferred1"><a name="line979"></a> 979       # Option examples:
</span><span class="inferred0"><a name="line980"></a> 980       #   belongs_to :firm, :foreign_key =&gt; &quot;client_of&quot;
</span><span class="inferred1"><a name="line981"></a> 981       #   belongs_to :author, :class_name =&gt; &quot;Person&quot;, :foreign_key =&gt; &quot;author_id&quot;
</span><span class="inferred0"><a name="line982"></a> 982       #   belongs_to :valid_coupon, :class_name =&gt; &quot;Coupon&quot;, :foreign_key =&gt; &quot;coupon_id&quot;,
</span><span class="inferred1"><a name="line983"></a> 983       #              :conditions =&gt; 'discounts &gt; #{payments_count}'
</span><span class="inferred0"><a name="line984"></a> 984       #   belongs_to :attachable, :polymorphic =&gt; true
</span><span class="inferred1"><a name="line985"></a> 985       #   belongs_to :project, :readonly =&gt; true
</span><span class="inferred0"><a name="line986"></a> 986       #   belongs_to :post, :counter_cache =&gt; true
</span><span class="marked1"><a name="line987"></a> 987       def belongs_to(association_id, options = {})
</span><span class="marked0"><a name="line988"></a> 988         reflection = create_belongs_to_reflection(association_id, options)
</span><span class="inferred1"><a name="line989"></a> 989 
</span><span class="marked0"><a name="line990"></a> 990         ivar = &quot;@#{reflection.name}&quot;
</span><span class="inferred1"><a name="line991"></a> 991 
</span><span class="marked0"><a name="line992"></a> 992         if reflection.options[:polymorphic]
</span><span class="uncovered1"><a name="line993"></a> 993           association_accessor_methods(reflection, BelongsToPolymorphicAssociation)
</span><span class="uncovered0"><a name="line994"></a> 994 
</span><span class="uncovered1"><a name="line995"></a> 995           method_name = &quot;polymorphic_belongs_to_before_save_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line996"></a> 996           define_method(method_name) do
</span><span class="uncovered1"><a name="line997"></a> 997             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered0"><a name="line998"></a> 998 
</span><span class="uncovered1"><a name="line999"></a> 999             if association &amp;&amp; association.target
</span><span class="uncovered0"><a name="line1000"></a>1000               if association.new_record?
</span><span class="uncovered1"><a name="line1001"></a>1001                 association.save(true)
</span><span class="uncovered0"><a name="line1002"></a>1002               end
</span><span class="uncovered1"><a name="line1003"></a>1003 
</span><span class="uncovered0"><a name="line1004"></a>1004               if association.updated?
</span><span class="uncovered1"><a name="line1005"></a>1005                 self[reflection.primary_key_name] = association.id
</span><span class="uncovered0"><a name="line1006"></a>1006                 self[reflection.options[:foreign_type]] = association.class.base_class.name.to_s
</span><span class="uncovered1"><a name="line1007"></a>1007               end
</span><span class="uncovered0"><a name="line1008"></a>1008             end
</span><span class="uncovered1"><a name="line1009"></a>1009           end
</span><span class="uncovered0"><a name="line1010"></a>1010           before_save method_name
</span><span class="inferred1"><a name="line1011"></a>1011         else
</span><span class="marked0"><a name="line1012"></a>1012           association_accessor_methods(reflection, BelongsToAssociation)
</span><span class="marked1"><a name="line1013"></a>1013           association_constructor_method(:build,  reflection, BelongsToAssociation)
</span><span class="marked0"><a name="line1014"></a>1014           association_constructor_method(:create, reflection, BelongsToAssociation)
</span><span class="inferred1"><a name="line1015"></a>1015 
</span><span class="marked0"><a name="line1016"></a>1016           method_name = &quot;belongs_to_before_save_for_#{reflection.name}&quot;.to_sym
</span><span class="marked1"><a name="line1017"></a>1017           define_method(method_name) do
</span><span class="uncovered0"><a name="line1018"></a>1018             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered1"><a name="line1019"></a>1019 
</span><span class="uncovered0"><a name="line1020"></a>1020             if !association.nil?
</span><span class="uncovered1"><a name="line1021"></a>1021               if association.new_record?
</span><span class="uncovered0"><a name="line1022"></a>1022                 association.save(true)
</span><span class="uncovered1"><a name="line1023"></a>1023               end
</span><span class="uncovered0"><a name="line1024"></a>1024 
</span><span class="uncovered1"><a name="line1025"></a>1025               if association.updated?
</span><span class="uncovered0"><a name="line1026"></a>1026                 self[reflection.primary_key_name] = association.id
</span><span class="uncovered1"><a name="line1027"></a>1027               end
</span><span class="uncovered0"><a name="line1028"></a>1028             end
</span><span class="uncovered1"><a name="line1029"></a>1029           end
</span><span class="marked0"><a name="line1030"></a>1030           before_save method_name
</span><span class="inferred1"><a name="line1031"></a>1031         end
</span><span class="inferred0"><a name="line1032"></a>1032 
</span><span class="inferred1"><a name="line1033"></a>1033         # Create the callbacks to update counter cache
</span><span class="marked0"><a name="line1034"></a>1034         if options[:counter_cache]
</span><span class="uncovered1"><a name="line1035"></a>1035           cache_column = options[:counter_cache] == true ?
</span><span class="uncovered0"><a name="line1036"></a>1036             &quot;#{self.to_s.demodulize.underscore.pluralize}_count&quot; :
</span><span class="uncovered1"><a name="line1037"></a>1037             options[:counter_cache]
</span><span class="uncovered0"><a name="line1038"></a>1038 
</span><span class="uncovered1"><a name="line1039"></a>1039           method_name = &quot;belongs_to_counter_cache_after_create_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line1040"></a>1040           define_method(method_name) do
</span><span class="uncovered1"><a name="line1041"></a>1041             association = send(reflection.name)
</span><span class="uncovered0"><a name="line1042"></a>1042             association.class.increment_counter(cache_column, send(reflection.primary_key_name)) unless association.nil?
</span><span class="uncovered1"><a name="line1043"></a>1043           end
</span><span class="uncovered0"><a name="line1044"></a>1044           after_create method_name
</span><span class="uncovered1"><a name="line1045"></a>1045 
</span><span class="uncovered0"><a name="line1046"></a>1046           method_name = &quot;belongs_to_counter_cache_before_destroy_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line1047"></a>1047           define_method(method_name) do
</span><span class="uncovered0"><a name="line1048"></a>1048             association = send(reflection.name)
</span><span class="uncovered1"><a name="line1049"></a>1049             association.class.decrement_counter(cache_column, send(reflection.primary_key_name)) unless association.nil?
</span><span class="uncovered0"><a name="line1050"></a>1050           end
</span><span class="uncovered1"><a name="line1051"></a>1051           before_destroy method_name
</span><span class="uncovered0"><a name="line1052"></a>1052 
</span><span class="uncovered1"><a name="line1053"></a>1053           module_eval(
</span><span class="uncovered0"><a name="line1054"></a>1054             &quot;#{reflection.class_name}.send(:attr_readonly,\&quot;#{cache_column}\&quot;.intern) if defined?(#{reflection.class_name}) &amp;&amp; #{reflection.class_name}.respond_to?(:attr_readonly)&quot;
</span><span class="uncovered1"><a name="line1055"></a>1055           )
</span><span class="uncovered0"><a name="line1056"></a>1056         end
</span><span class="inferred1"><a name="line1057"></a>1057 
</span><span class="marked0"><a name="line1058"></a>1058         add_single_associated_validation_callbacks(reflection.name) if options[:validate] == true
</span><span class="inferred1"><a name="line1059"></a>1059 
</span><span class="marked0"><a name="line1060"></a>1060         configure_dependency_for_belongs_to(reflection)
</span><span class="inferred1"><a name="line1061"></a>1061       end
</span><span class="inferred0"><a name="line1062"></a>1062 
</span><span class="inferred1"><a name="line1063"></a>1063       # Specifies a many-to-many relationship with another class. This associates two classes via an
</span><span class="inferred0"><a name="line1064"></a>1064       # intermediate join table.  Unless the join table is explicitly specified as an option, it is
</span><span class="inferred1"><a name="line1065"></a>1065       # guessed using the lexical order of the class names. So a join between Developer and Project
</span><span class="inferred0"><a name="line1066"></a>1066       # will give the default join table name of &quot;developers_projects&quot; because &quot;D&quot; outranks &quot;P&quot;.  Note that this precedence
</span><span class="inferred1"><a name="line1067"></a>1067       # is calculated using the &lt;tt&gt;&lt;&lt;/tt&gt; operator for String.  This means that if the strings are of different lengths,
</span><span class="inferred0"><a name="line1068"></a>1068       # and the strings are equal when compared up to the shortest length, then the longer string is considered of higher
</span><span class="inferred1"><a name="line1069"></a>1069       # lexical precedence than the shorter one.  For example, one would expect the tables &quot;paper_boxes&quot; and &quot;papers&quot;
</span><span class="inferred0"><a name="line1070"></a>1070       # to generate a join table name of &quot;papers_paper_boxes&quot; because of the length of the name &quot;paper_boxes&quot;,
</span><span class="inferred1"><a name="line1071"></a>1071       # but it in fact generates a join table name of &quot;paper_boxes_papers&quot;.  Be aware of this caveat, and use the
</span><span class="inferred0"><a name="line1072"></a>1072       # custom &lt;tt&gt;:join_table&lt;/tt&gt; option if you need to.
</span><span class="inferred1"><a name="line1073"></a>1073       #
</span><span class="inferred0"><a name="line1074"></a>1074       # Deprecated: Any additional fields added to the join table will be placed as attributes when pulling records out through
</span><span class="inferred1"><a name="line1075"></a>1075       # +has_and_belongs_to_many+ associations. Records returned from join tables with additional attributes will be marked as
</span><span class="inferred0"><a name="line1076"></a>1076       # readonly (because we can't save changes to the additional attributes). It's strongly recommended that you upgrade any
</span><span class="inferred1"><a name="line1077"></a>1077       # associations with attributes to a real join model (see introduction).
</span><span class="inferred0"><a name="line1078"></a>1078       #
</span><span class="inferred1"><a name="line1079"></a>1079       # Adds the following methods for retrieval and query:
</span><span class="inferred0"><a name="line1080"></a>1080       #
</span><span class="inferred1"><a name="line1081"></a>1081       # [collection(force_reload = false)]
</span><span class="inferred0"><a name="line1082"></a>1082       #   Returns an array of all the associated objects.
</span><span class="inferred1"><a name="line1083"></a>1083       #   An empty array is returned if none are found.
</span><span class="inferred0"><a name="line1084"></a>1084       # [collection&lt;&lt;(object, ...)]
</span><span class="inferred1"><a name="line1085"></a>1085       #   Adds one or more objects to the collection by creating associations in the join table
</span><span class="inferred0"><a name="line1086"></a>1086       #   (&lt;tt&gt;collection.push&lt;/tt&gt; and &lt;tt&gt;collection.concat&lt;/tt&gt; are aliases to this method).
</span><span class="inferred1"><a name="line1087"></a>1087       # [collection.delete(object, ...)]
</span><span class="inferred0"><a name="line1088"></a>1088       #   Removes one or more objects from the collection by removing their associations from the join table.
</span><span class="inferred1"><a name="line1089"></a>1089       #   This does not destroy the objects.
</span><span class="inferred0"><a name="line1090"></a>1090       # [collection=objects]
</span><span class="inferred1"><a name="line1091"></a>1091       #   Replaces the collection's content by deleting and adding objects as appropriate.
</span><span class="inferred0"><a name="line1092"></a>1092       # [collection_singular_ids]
</span><span class="inferred1"><a name="line1093"></a>1093       #   Returns an array of the associated objects' ids.
</span><span class="inferred0"><a name="line1094"></a>1094       # [collection_singular_ids=ids]
</span><span class="inferred1"><a name="line1095"></a>1095       #   Replace the collection by the objects identified by the primary keys in +ids+.
</span><span class="inferred0"><a name="line1096"></a>1096       # [collection.clear]
</span><span class="inferred1"><a name="line1097"></a>1097       #   Removes every object from the collection. This does not destroy the objects.
</span><span class="inferred0"><a name="line1098"></a>1098       # [collection.empty?]
</span><span class="inferred1"><a name="line1099"></a>1099       #   Returns +true+ if there are no associated objects.
</span><span class="inferred0"><a name="line1100"></a>1100       # [collection.size]
</span><span class="inferred1"><a name="line1101"></a>1101       #   Returns the number of associated objects.
</span><span class="inferred0"><a name="line1102"></a>1102       # [collection.find(id)]
</span><span class="inferred1"><a name="line1103"></a>1103       #   Finds an associated object responding to the +id+ and that
</span><span class="inferred0"><a name="line1104"></a>1104       #   meets the condition that it has to be associated with this object.
</span><span class="inferred1"><a name="line1105"></a>1105       #   Uses the same rules as ActiveRecord::Base.find.
</span><span class="inferred0"><a name="line1106"></a>1106       # [collection.exist?(...)]
</span><span class="inferred1"><a name="line1107"></a>1107       #   Checks whether an associated object with the given conditions exists.
</span><span class="inferred0"><a name="line1108"></a>1108       #   Uses the same rules as ActiveRecord::Base.exists?.
</span><span class="inferred1"><a name="line1109"></a>1109       # [collection.build(attributes = {})]
</span><span class="inferred0"><a name="line1110"></a>1110       #   Returns a new object of the collection type that has been instantiated
</span><span class="inferred1"><a name="line1111"></a>1111       #   with +attributes+ and linked to this object through the join table, but has not yet been saved.
</span><span class="inferred0"><a name="line1112"></a>1112       # [collection.create(attributes = {})]
</span><span class="inferred1"><a name="line1113"></a>1113       #   Returns a new object of the collection type that has been instantiated
</span><span class="inferred0"><a name="line1114"></a>1114       #   with +attributes+, linked to this object through the join table, and that has already been saved (if it passed the validation).
</span><span class="inferred1"><a name="line1115"></a>1115       #
</span><span class="inferred0"><a name="line1116"></a>1116       # (+collection+ is replaced with the symbol passed as the first argument, so
</span><span class="inferred1"><a name="line1117"></a>1117       # &lt;tt&gt;has_and_belongs_to_many :categories&lt;/tt&gt; would add among others &lt;tt&gt;categories.empty?&lt;/tt&gt;.)
</span><span class="inferred0"><a name="line1118"></a>1118       #
</span><span class="inferred1"><a name="line1119"></a>1119       # === Example
</span><span class="inferred0"><a name="line1120"></a>1120       #
</span><span class="inferred1"><a name="line1121"></a>1121       # A Developer class declares &lt;tt&gt;has_and_belongs_to_many :projects&lt;/tt&gt;, which will add:
</span><span class="inferred0"><a name="line1122"></a>1122       # * &lt;tt&gt;Developer#projects&lt;/tt&gt;
</span><span class="inferred1"><a name="line1123"></a>1123       # * &lt;tt&gt;Developer#projects&lt;&lt;&lt;/tt&gt;
</span><span class="inferred0"><a name="line1124"></a>1124       # * &lt;tt&gt;Developer#projects.delete&lt;/tt&gt;
</span><span class="inferred1"><a name="line1125"></a>1125       # * &lt;tt&gt;Developer#projects=&lt;/tt&gt;
</span><span class="inferred0"><a name="line1126"></a>1126       # * &lt;tt&gt;Developer#project_ids&lt;/tt&gt;
</span><span class="inferred1"><a name="line1127"></a>1127       # * &lt;tt&gt;Developer#project_ids=&lt;/tt&gt;
</span><span class="inferred0"><a name="line1128"></a>1128       # * &lt;tt&gt;Developer#projects.clear&lt;/tt&gt;
</span><span class="inferred1"><a name="line1129"></a>1129       # * &lt;tt&gt;Developer#projects.empty?&lt;/tt&gt;
</span><span class="inferred0"><a name="line1130"></a>1130       # * &lt;tt&gt;Developer#projects.size&lt;/tt&gt;
</span><span class="inferred1"><a name="line1131"></a>1131       # * &lt;tt&gt;Developer#projects.find(id)&lt;/tt&gt;
</span><span class="inferred0"><a name="line1132"></a>1132       # * &lt;tt&gt;Developer#clients.exist?(...)&lt;/tt&gt;
</span><span class="inferred1"><a name="line1133"></a>1133       # * &lt;tt&gt;Developer#projects.build&lt;/tt&gt; (similar to &lt;tt&gt;Project.new(&quot;project_id&quot; =&gt; id)&lt;/tt&gt;)
</span><span class="inferred0"><a name="line1134"></a>1134       # * &lt;tt&gt;Developer#projects.create&lt;/tt&gt; (similar to &lt;tt&gt;c = Project.new(&quot;project_id&quot; =&gt; id); c.save; c&lt;/tt&gt;)
</span><span class="inferred1"><a name="line1135"></a>1135       # The declaration may include an options hash to specialize the behavior of the association.
</span><span class="inferred0"><a name="line1136"></a>1136       #
</span><span class="inferred1"><a name="line1137"></a>1137       # === Options
</span><span class="inferred0"><a name="line1138"></a>1138       #
</span><span class="inferred1"><a name="line1139"></a>1139       # [:class_name]
</span><span class="inferred0"><a name="line1140"></a>1140       #   Specify the class name of the association. Use it only if that name can't be inferred
</span><span class="inferred1"><a name="line1141"></a>1141       #   from the association name. So &lt;tt&gt;has_and_belongs_to_many :projects&lt;/tt&gt; will by default be linked to the
</span><span class="inferred0"><a name="line1142"></a>1142       #   Project class, but if the real class name is SuperProject, you'll have to specify it with this option.
</span><span class="inferred1"><a name="line1143"></a>1143       # [:join_table]
</span><span class="inferred0"><a name="line1144"></a>1144       #   Specify the name of the join table if the default based on lexical order isn't what you want.
</span><span class="inferred1"><a name="line1145"></a>1145       #   &lt;b&gt;WARNING:&lt;/b&gt; If you're overwriting the table name of either class, the +table_name+ method
</span><span class="inferred0"><a name="line1146"></a>1146       #   MUST be declared underneath any +has_and_belongs_to_many+ declaration in order to work.
</span><span class="inferred1"><a name="line1147"></a>1147       # [:foreign_key]
</span><span class="inferred0"><a name="line1148"></a>1148       #   Specify the foreign key used for the association. By default this is guessed to be the name
</span><span class="inferred1"><a name="line1149"></a>1149       #   of this class in lower-case and &quot;_id&quot; suffixed. So a Person class that makes a +has_and_belongs_to_many+ association
</span><span class="inferred0"><a name="line1150"></a>1150       #   will use &quot;person_id&quot; as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;.
</span><span class="inferred1"><a name="line1151"></a>1151       # [:association_foreign_key]
</span><span class="inferred0"><a name="line1152"></a>1152       #   Specify the association foreign key used for the association. By default this is
</span><span class="inferred1"><a name="line1153"></a>1153       #   guessed to be the name of the associated class in lower-case and &quot;_id&quot; suffixed. So if the associated class is Project,
</span><span class="inferred0"><a name="line1154"></a>1154       #   the +has_and_belongs_to_many+ association will use &quot;project_id&quot; as the default &lt;tt&gt;:association_foreign_key&lt;/tt&gt;.
</span><span class="inferred1"><a name="line1155"></a>1155       # [:conditions]
</span><span class="inferred0"><a name="line1156"></a>1156       #   Specify the conditions that the associated object must meet in order to be included as a +WHERE+
</span><span class="inferred1"><a name="line1157"></a>1157       #   SQL fragment, such as &lt;tt&gt;authorized = 1&lt;/tt&gt;.  Record creations from the association are scoped if a hash is used.  
</span><span class="inferred0"><a name="line1158"></a>1158       #   &lt;tt&gt;has_many :posts, :conditions =&gt; {:published =&gt; true}&lt;/tt&gt; will create published posts with &lt;tt&gt;@blog.posts.create&lt;/tt&gt; 
</span><span class="inferred1"><a name="line1159"></a>1159       #   or &lt;tt&gt;@blog.posts.build&lt;/tt&gt;.
</span><span class="inferred0"><a name="line1160"></a>1160       # [:order]
</span><span class="inferred1"><a name="line1161"></a>1161       #   Specify the order in which the associated objects are returned as an &lt;tt&gt;ORDER BY&lt;/tt&gt; SQL fragment,
</span><span class="inferred0"><a name="line1162"></a>1162       #   such as &lt;tt&gt;last_name, first_name DESC&lt;/tt&gt;
</span><span class="inferred1"><a name="line1163"></a>1163       # [:uniq]
</span><span class="inferred0"><a name="line1164"></a>1164       #   If true, duplicate associated objects will be ignored by accessors and query methods.
</span><span class="inferred1"><a name="line1165"></a>1165       # [:finder_sql]
</span><span class="inferred0"><a name="line1166"></a>1166       #   Overwrite the default generated SQL statement used to fetch the association with a manual statement
</span><span class="inferred1"><a name="line1167"></a>1167       # [:counter_sql]
</span><span class="inferred0"><a name="line1168"></a>1168       #   Specify a complete SQL statement to fetch the size of the association. If &lt;tt&gt;:finder_sql&lt;/tt&gt; is
</span><span class="inferred1"><a name="line1169"></a>1169       #   specified but not &lt;tt&gt;:counter_sql&lt;/tt&gt;, &lt;tt&gt;:counter_sql&lt;/tt&gt; will be generated by replacing &lt;tt&gt;SELECT ... FROM&lt;/tt&gt; with &lt;tt&gt;SELECT COUNT(*) FROM&lt;/tt&gt;.
</span><span class="inferred0"><a name="line1170"></a>1170       # [:delete_sql]
</span><span class="inferred1"><a name="line1171"></a>1171       #   Overwrite the default generated SQL statement used to remove links between the associated
</span><span class="inferred0"><a name="line1172"></a>1172       #   classes with a manual statement.
</span><span class="inferred1"><a name="line1173"></a>1173       # [:insert_sql]
</span><span class="inferred0"><a name="line1174"></a>1174       #   Overwrite the default generated SQL statement used to add links between the associated classes
</span><span class="inferred1"><a name="line1175"></a>1175       #   with a manual statement.
</span><span class="inferred0"><a name="line1176"></a>1176       # [:extend]
</span><span class="inferred1"><a name="line1177"></a>1177       #   Anonymous module for extending the proxy, see &quot;Association extensions&quot;.
</span><span class="inferred0"><a name="line1178"></a>1178       # [:include]
</span><span class="inferred1"><a name="line1179"></a>1179       #   Specify second-order associations that should be eager loaded when the collection is loaded.
</span><span class="inferred0"><a name="line1180"></a>1180       # [:group]
</span><span class="inferred1"><a name="line1181"></a>1181       #   An attribute name by which the result should be grouped. Uses the &lt;tt&gt;GROUP BY&lt;/tt&gt; SQL-clause.
</span><span class="inferred0"><a name="line1182"></a>1182       # [:limit]
</span><span class="inferred1"><a name="line1183"></a>1183       #   An integer determining the limit on the number of rows that should be returned.
</span><span class="inferred0"><a name="line1184"></a>1184       # [:offset]
</span><span class="inferred1"><a name="line1185"></a>1185       #   An integer determining the offset from where the rows should be fetched. So at 5, it would skip the first 4 rows.
</span><span class="inferred0"><a name="line1186"></a>1186       # [:select]
</span><span class="inferred1"><a name="line1187"></a>1187       #   By default, this is &lt;tt&gt;*&lt;/tt&gt; as in &lt;tt&gt;SELECT * FROM&lt;/tt&gt;, but can be changed if, for example, you want to do a join
</span><span class="inferred0"><a name="line1188"></a>1188       #   but not include the joined columns. Do not forget to include the primary and foreign keys, otherwise it will raise an error.
</span><span class="inferred1"><a name="line1189"></a>1189       # [:readonly]
</span><span class="inferred0"><a name="line1190"></a>1190       #   If true, all the associated objects are readonly through the association.
</span><span class="inferred1"><a name="line1191"></a>1191       # [:validate]
</span><span class="inferred0"><a name="line1192"></a>1192       #   If false, don't validate the associated objects when saving the parent object. +true+ by default.
</span><span class="inferred1"><a name="line1193"></a>1193       #
</span><span class="inferred0"><a name="line1194"></a>1194       # Option examples:
</span><span class="inferred1"><a name="line1195"></a>1195       #   has_and_belongs_to_many :projects
</span><span class="inferred0"><a name="line1196"></a>1196       #   has_and_belongs_to_many :projects, :include =&gt; [ :milestones, :manager ]
</span><span class="inferred1"><a name="line1197"></a>1197       #   has_and_belongs_to_many :nations, :class_name =&gt; &quot;Country&quot;
</span><span class="inferred0"><a name="line1198"></a>1198       #   has_and_belongs_to_many :categories, :join_table =&gt; &quot;prods_cats&quot;
</span><span class="inferred1"><a name="line1199"></a>1199       #   has_and_belongs_to_many :categories, :readonly =&gt; true
</span><span class="inferred0"><a name="line1200"></a>1200       #   has_and_belongs_to_many :active_projects, :join_table =&gt; 'developers_projects', :delete_sql =&gt;
</span><span class="inferred1"><a name="line1201"></a>1201       #   'DELETE FROM developers_projects WHERE active=1 AND developer_id = #{id} AND project_id = #{record.id}'
</span><span class="marked0"><a name="line1202"></a>1202       def has_and_belongs_to_many(association_id, options = {}, &amp;extension)
</span><span class="uncovered1"><a name="line1203"></a>1203         reflection = create_has_and_belongs_to_many_reflection(association_id, options, &amp;extension)
</span><span class="uncovered0"><a name="line1204"></a>1204 
</span><span class="uncovered1"><a name="line1205"></a>1205         add_multiple_associated_validation_callbacks(reflection.name) unless options[:validate] == false
</span><span class="uncovered0"><a name="line1206"></a>1206         add_multiple_associated_save_callbacks(reflection.name)
</span><span class="uncovered1"><a name="line1207"></a>1207         collection_accessor_methods(reflection, HasAndBelongsToManyAssociation)
</span><span class="uncovered0"><a name="line1208"></a>1208 
</span><span class="uncovered1"><a name="line1209"></a>1209         # Don't use a before_destroy callback since users' before_destroy
</span><span class="uncovered0"><a name="line1210"></a>1210         # callbacks will be executed after the association is wiped out.
</span><span class="uncovered1"><a name="line1211"></a>1211         old_method = &quot;destroy_without_habtm_shim_for_#{reflection.name}&quot;
</span><span class="uncovered0"><a name="line1212"></a>1212         class_eval &lt;&lt;-end_eval unless method_defined?(old_method)
</span><span class="uncovered1"><a name="line1213"></a>1213           alias_method :#{old_method}, :destroy_without_callbacks
</span><span class="uncovered0"><a name="line1214"></a>1214           def destroy_without_callbacks
</span><span class="uncovered1"><a name="line1215"></a>1215             #{reflection.name}.clear
</span><span class="uncovered0"><a name="line1216"></a>1216             #{old_method}
</span><span class="uncovered1"><a name="line1217"></a>1217           end
</span><span class="uncovered0"><a name="line1218"></a>1218         end_eval
</span><span class="uncovered1"><a name="line1219"></a>1219 
</span><span class="uncovered0"><a name="line1220"></a>1220         add_association_callbacks(reflection.name, options)
</span><span class="uncovered1"><a name="line1221"></a>1221       end
</span><span class="inferred0"><a name="line1222"></a>1222 
</span><span class="marked1"><a name="line1223"></a>1223       private
</span><span class="inferred0"><a name="line1224"></a>1224         # Generates a join table name from two provided table names.
</span><span class="inferred1"><a name="line1225"></a>1225         # The names in the join table namesme end up in lexicographic order.
</span><span class="inferred0"><a name="line1226"></a>1226         #
</span><span class="inferred1"><a name="line1227"></a>1227         #   join_table_name(&quot;members&quot;, &quot;clubs&quot;)         # =&gt; &quot;clubs_members&quot;
</span><span class="inferred0"><a name="line1228"></a>1228         #   join_table_name(&quot;members&quot;, &quot;special_clubs&quot;) # =&gt; &quot;members_special_clubs&quot;
</span><span class="marked1"><a name="line1229"></a>1229         def join_table_name(first_table_name, second_table_name)
</span><span class="uncovered0"><a name="line1230"></a>1230           if first_table_name &lt; second_table_name
</span><span class="uncovered1"><a name="line1231"></a>1231             join_table = &quot;#{first_table_name}_#{second_table_name}&quot;
</span><span class="uncovered0"><a name="line1232"></a>1232           else
</span><span class="uncovered1"><a name="line1233"></a>1233             join_table = &quot;#{second_table_name}_#{first_table_name}&quot;
</span><span class="uncovered0"><a name="line1234"></a>1234           end
</span><span class="uncovered1"><a name="line1235"></a>1235 
</span><span class="uncovered0"><a name="line1236"></a>1236           table_name_prefix + join_table + table_name_suffix
</span><span class="uncovered1"><a name="line1237"></a>1237         end
</span><span class="inferred0"><a name="line1238"></a>1238 
</span><span class="marked1"><a name="line1239"></a>1239         def association_accessor_methods(reflection, association_proxy_class)
</span><span class="marked0"><a name="line1240"></a>1240           ivar = &quot;@#{reflection.name}&quot;
</span><span class="inferred1"><a name="line1241"></a>1241 
</span><span class="marked0"><a name="line1242"></a>1242           define_method(reflection.name) do |*params|
</span><span class="uncovered1"><a name="line1243"></a>1243             force_reload = params.first unless params.empty?
</span><span class="uncovered0"><a name="line1244"></a>1244 
</span><span class="uncovered1"><a name="line1245"></a>1245             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered0"><a name="line1246"></a>1246 
</span><span class="uncovered1"><a name="line1247"></a>1247             if association.nil? || force_reload
</span><span class="uncovered0"><a name="line1248"></a>1248               association = association_proxy_class.new(self, reflection)
</span><span class="uncovered1"><a name="line1249"></a>1249               retval = association.reload
</span><span class="uncovered0"><a name="line1250"></a>1250               if retval.nil? and association_proxy_class == BelongsToAssociation
</span><span class="uncovered1"><a name="line1251"></a>1251                 instance_variable_set(ivar, nil)
</span><span class="uncovered0"><a name="line1252"></a>1252                 return nil
</span><span class="uncovered1"><a name="line1253"></a>1253               end
</span><span class="uncovered0"><a name="line1254"></a>1254               instance_variable_set(ivar, association)
</span><span class="uncovered1"><a name="line1255"></a>1255             end
</span><span class="uncovered0"><a name="line1256"></a>1256 
</span><span class="uncovered1"><a name="line1257"></a>1257             association.target.nil? ? nil : association
</span><span class="uncovered0"><a name="line1258"></a>1258           end
</span><span class="inferred1"><a name="line1259"></a>1259 
</span><span class="marked0"><a name="line1260"></a>1260           define_method(&quot;loaded_#{reflection.name}?&quot;) do
</span><span class="uncovered1"><a name="line1261"></a>1261             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered0"><a name="line1262"></a>1262             association &amp;&amp; association.loaded?
</span><span class="uncovered1"><a name="line1263"></a>1263           end
</span><span class="inferred0"><a name="line1264"></a>1264 
</span><span class="marked1"><a name="line1265"></a>1265           define_method(&quot;#{reflection.name}=&quot;) do |new_value|
</span><span class="uncovered0"><a name="line1266"></a>1266             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered1"><a name="line1267"></a>1267 
</span><span class="uncovered0"><a name="line1268"></a>1268             if association.nil? || association.target != new_value
</span><span class="uncovered1"><a name="line1269"></a>1269               association = association_proxy_class.new(self, reflection)
</span><span class="uncovered0"><a name="line1270"></a>1270             end
</span><span class="uncovered1"><a name="line1271"></a>1271 
</span><span class="uncovered0"><a name="line1272"></a>1272             if association_proxy_class == HasOneThroughAssociation
</span><span class="uncovered1"><a name="line1273"></a>1273               association.create_through_record(new_value)
</span><span class="uncovered0"><a name="line1274"></a>1274               self.send(reflection.name, new_value)
</span><span class="uncovered1"><a name="line1275"></a>1275             else
</span><span class="uncovered0"><a name="line1276"></a>1276               association.replace(new_value)
</span><span class="uncovered1"><a name="line1277"></a>1277               instance_variable_set(ivar, new_value.nil? ? nil : association)
</span><span class="uncovered0"><a name="line1278"></a>1278             end
</span><span class="uncovered1"><a name="line1279"></a>1279           end
</span><span class="inferred0"><a name="line1280"></a>1280 
</span><span class="marked1"><a name="line1281"></a>1281           define_method(&quot;set_#{reflection.name}_target&quot;) do |target|
</span><span class="uncovered0"><a name="line1282"></a>1282             return if target.nil? and association_proxy_class == BelongsToAssociation
</span><span class="uncovered1"><a name="line1283"></a>1283             association = association_proxy_class.new(self, reflection)
</span><span class="uncovered0"><a name="line1284"></a>1284             association.target = target
</span><span class="uncovered1"><a name="line1285"></a>1285             instance_variable_set(ivar, association)
</span><span class="uncovered0"><a name="line1286"></a>1286           end
</span><span class="uncovered1"><a name="line1287"></a>1287         end
</span><span class="inferred0"><a name="line1288"></a>1288 
</span><span class="marked1"><a name="line1289"></a>1289         def collection_reader_method(reflection, association_proxy_class)
</span><span class="marked0"><a name="line1290"></a>1290           define_method(reflection.name) do |*params|
</span><span class="uncovered1"><a name="line1291"></a>1291             ivar = &quot;@#{reflection.name}&quot;
</span><span class="uncovered0"><a name="line1292"></a>1292 
</span><span class="uncovered1"><a name="line1293"></a>1293             force_reload = params.first unless params.empty?
</span><span class="uncovered0"><a name="line1294"></a>1294             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered1"><a name="line1295"></a>1295 
</span><span class="uncovered0"><a name="line1296"></a>1296             unless association.respond_to?(:loaded?)
</span><span class="uncovered1"><a name="line1297"></a>1297               association = association_proxy_class.new(self, reflection)
</span><span class="uncovered0"><a name="line1298"></a>1298               instance_variable_set(ivar, association)
</span><span class="uncovered1"><a name="line1299"></a>1299             end
</span><span class="uncovered0"><a name="line1300"></a>1300 
</span><span class="uncovered1"><a name="line1301"></a>1301             association.reload if force_reload
</span><span class="uncovered0"><a name="line1302"></a>1302 
</span><span class="uncovered1"><a name="line1303"></a>1303             association
</span><span class="uncovered0"><a name="line1304"></a>1304           end
</span><span class="inferred1"><a name="line1305"></a>1305 
</span><span class="marked0"><a name="line1306"></a>1306           define_method(&quot;#{reflection.name.to_s.singularize}_ids&quot;) do
</span><span class="uncovered1"><a name="line1307"></a>1307             if send(reflection.name).loaded? || reflection.options[:finder_sql]
</span><span class="uncovered0"><a name="line1308"></a>1308               send(reflection.name).map(&amp;:id)
</span><span class="uncovered1"><a name="line1309"></a>1309             else
</span><span class="uncovered0"><a name="line1310"></a>1310               send(reflection.name).all(:select =&gt; &quot;#{reflection.quoted_table_name}.#{reflection.klass.primary_key}&quot;).map(&amp;:id)
</span><span class="uncovered1"><a name="line1311"></a>1311             end
</span><span class="uncovered0"><a name="line1312"></a>1312           end
</span><span class="uncovered1"><a name="line1313"></a>1313         end
</span><span class="inferred0"><a name="line1314"></a>1314 
</span><span class="marked1"><a name="line1315"></a>1315         def collection_accessor_methods(reflection, association_proxy_class, writer = true)
</span><span class="marked0"><a name="line1316"></a>1316           collection_reader_method(reflection, association_proxy_class)
</span><span class="inferred1"><a name="line1317"></a>1317 
</span><span class="marked0"><a name="line1318"></a>1318           if writer
</span><span class="marked1"><a name="line1319"></a>1319             define_method(&quot;#{reflection.name}=&quot;) do |new_value|
</span><span class="uncovered0"><a name="line1320"></a>1320               # Loads proxy class instance (defined in collection_reader_method) if not already loaded
</span><span class="uncovered1"><a name="line1321"></a>1321               association = send(reflection.name)
</span><span class="uncovered0"><a name="line1322"></a>1322               association.replace(new_value)
</span><span class="uncovered1"><a name="line1323"></a>1323               association
</span><span class="uncovered0"><a name="line1324"></a>1324             end
</span><span class="inferred1"><a name="line1325"></a>1325 
</span><span class="marked0"><a name="line1326"></a>1326             define_method(&quot;#{reflection.name.to_s.singularize}_ids=&quot;) do |new_value|
</span><span class="uncovered1"><a name="line1327"></a>1327               ids = (new_value || []).reject { |nid| nid.blank? }
</span><span class="uncovered0"><a name="line1328"></a>1328               send(&quot;#{reflection.name}=&quot;, reflection.class_name.constantize.find(ids))
</span><span class="uncovered1"><a name="line1329"></a>1329             end
</span><span class="uncovered0"><a name="line1330"></a>1330           end
</span><span class="uncovered1"><a name="line1331"></a>1331         end
</span><span class="inferred0"><a name="line1332"></a>1332 
</span><span class="marked1"><a name="line1333"></a>1333         def add_single_associated_validation_callbacks(association_name)
</span><span class="uncovered0"><a name="line1334"></a>1334           method_name = &quot;validate_associated_records_for_#{association_name}&quot;.to_sym
</span><span class="uncovered1"><a name="line1335"></a>1335           define_method(method_name) do
</span><span class="uncovered0"><a name="line1336"></a>1336             association = instance_variable_get(&quot;@#{association_name}&quot;)
</span><span class="uncovered1"><a name="line1337"></a>1337             if !association.nil?
</span><span class="uncovered0"><a name="line1338"></a>1338               errors.add association_name unless association.target.nil? || association.valid?
</span><span class="uncovered1"><a name="line1339"></a>1339             end
</span><span class="uncovered0"><a name="line1340"></a>1340           end
</span><span class="uncovered1"><a name="line1341"></a>1341 
</span><span class="uncovered0"><a name="line1342"></a>1342           validate method_name
</span><span class="uncovered1"><a name="line1343"></a>1343         end
</span><span class="inferred0"><a name="line1344"></a>1344 
</span><span class="marked1"><a name="line1345"></a>1345         def add_multiple_associated_validation_callbacks(association_name)
</span><span class="marked0"><a name="line1346"></a>1346           method_name = &quot;validate_associated_records_for_#{association_name}&quot;.to_sym
</span><span class="marked1"><a name="line1347"></a>1347           ivar = &quot;@#{association_name}&quot;
</span><span class="inferred0"><a name="line1348"></a>1348 
</span><span class="marked1"><a name="line1349"></a>1349           define_method(method_name) do
</span><span class="marked0"><a name="line1350"></a>1350             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="inferred1"><a name="line1351"></a>1351 
</span><span class="marked0"><a name="line1352"></a>1352             if association.respond_to?(:loaded?)
</span><span class="uncovered1"><a name="line1353"></a>1353               if new_record?
</span><span class="uncovered0"><a name="line1354"></a>1354                 association
</span><span class="uncovered1"><a name="line1355"></a>1355               elsif association.loaded?
</span><span class="uncovered0"><a name="line1356"></a>1356                 association.select { |record| record.new_record? }
</span><span class="uncovered1"><a name="line1357"></a>1357               else
</span><span class="uncovered0"><a name="line1358"></a>1358                 association.target.select { |record| record.new_record? }
</span><span class="uncovered1"><a name="line1359"></a>1359               end.each do |record|
</span><span class="uncovered0"><a name="line1360"></a>1360                 errors.add association_name unless record.valid?
</span><span class="uncovered1"><a name="line1361"></a>1361               end
</span><span class="uncovered0"><a name="line1362"></a>1362             end
</span><span class="uncovered1"><a name="line1363"></a>1363           end
</span><span class="inferred0"><a name="line1364"></a>1364 
</span><span class="marked1"><a name="line1365"></a>1365           validate method_name
</span><span class="inferred0"><a name="line1366"></a>1366         end
</span><span class="inferred1"><a name="line1367"></a>1367 
</span><span class="marked0"><a name="line1368"></a>1368         def add_multiple_associated_save_callbacks(association_name)
</span><span class="marked1"><a name="line1369"></a>1369           ivar = &quot;@#{association_name}&quot;
</span><span class="inferred0"><a name="line1370"></a>1370 
</span><span class="marked1"><a name="line1371"></a>1371           method_name = &quot;before_save_associated_records_for_#{association_name}&quot;.to_sym
</span><span class="marked0"><a name="line1372"></a>1372           define_method(method_name) do
</span><span class="marked1"><a name="line1373"></a>1373             @new_record_before_save = new_record?
</span><span class="marked0"><a name="line1374"></a>1374             true
</span><span class="inferred1"><a name="line1375"></a>1375           end
</span><span class="marked0"><a name="line1376"></a>1376           before_save method_name
</span><span class="inferred1"><a name="line1377"></a>1377 
</span><span class="marked0"><a name="line1378"></a>1378           method_name = &quot;after_create_or_update_associated_records_for_#{association_name}&quot;.to_sym
</span><span class="marked1"><a name="line1379"></a>1379           define_method(method_name) do
</span><span class="marked0"><a name="line1380"></a>1380             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="inferred1"><a name="line1381"></a>1381 
</span><span class="marked0"><a name="line1382"></a>1382             records_to_save = if @new_record_before_save
</span><span class="uncovered1"><a name="line1383"></a>1383               association
</span><span class="marked0"><a name="line1384"></a>1384             elsif association.respond_to?(:loaded?) &amp;&amp; association.loaded?
</span><span class="uncovered1"><a name="line1385"></a>1385               association.select { |record| record.new_record? }
</span><span class="marked0"><a name="line1386"></a>1386             elsif association.respond_to?(:loaded?) &amp;&amp; !association.loaded?
</span><span class="uncovered1"><a name="line1387"></a>1387               association.target.select { |record| record.new_record? }
</span><span class="inferred0"><a name="line1388"></a>1388             else
</span><span class="marked1"><a name="line1389"></a>1389               []
</span><span class="inferred0"><a name="line1390"></a>1390             end
</span><span class="marked1"><a name="line1391"></a>1391             records_to_save.each { |record| association.send(:insert_record, record) } unless records_to_save.blank?
</span><span class="inferred0"><a name="line1392"></a>1392 
</span><span class="inferred1"><a name="line1393"></a>1393             # reconstruct the SQL queries now that we know the owner's id
</span><span class="marked0"><a name="line1394"></a>1394             association.send(:construct_sql) if association.respond_to?(:construct_sql)
</span><span class="inferred1"><a name="line1395"></a>1395           end
</span><span class="inferred0"><a name="line1396"></a>1396 
</span><span class="inferred1"><a name="line1397"></a>1397           # Doesn't use after_save as that would save associations added in after_create/after_update twice
</span><span class="marked0"><a name="line1398"></a>1398           after_create method_name
</span><span class="marked1"><a name="line1399"></a>1399           after_update method_name
</span><span class="inferred0"><a name="line1400"></a>1400         end
</span><span class="inferred1"><a name="line1401"></a>1401 
</span><span class="marked0"><a name="line1402"></a>1402         def association_constructor_method(constructor, reflection, association_proxy_class)
</span><span class="marked1"><a name="line1403"></a>1403           define_method(&quot;#{constructor}_#{reflection.name}&quot;) do |*params|
</span><span class="uncovered0"><a name="line1404"></a>1404             ivar = &quot;@#{reflection.name}&quot;
</span><span class="uncovered1"><a name="line1405"></a>1405 
</span><span class="uncovered0"><a name="line1406"></a>1406             attributees      = params.first unless params.empty?
</span><span class="uncovered1"><a name="line1407"></a>1407             replace_existing = params[1].nil? ? true : params[1]
</span><span class="uncovered0"><a name="line1408"></a>1408             association      = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered1"><a name="line1409"></a>1409 
</span><span class="uncovered0"><a name="line1410"></a>1410             if association.nil?
</span><span class="uncovered1"><a name="line1411"></a>1411               association = association_proxy_class.new(self, reflection)
</span><span class="uncovered0"><a name="line1412"></a>1412               instance_variable_set(ivar, association)
</span><span class="uncovered1"><a name="line1413"></a>1413             end
</span><span class="uncovered0"><a name="line1414"></a>1414 
</span><span class="uncovered1"><a name="line1415"></a>1415             if association_proxy_class == HasOneAssociation
</span><span class="uncovered0"><a name="line1416"></a>1416               association.send(constructor, attributees, replace_existing)
</span><span class="uncovered1"><a name="line1417"></a>1417             else
</span><span class="uncovered0"><a name="line1418"></a>1418               association.send(constructor, attributees)
</span><span class="uncovered1"><a name="line1419"></a>1419             end
</span><span class="uncovered0"><a name="line1420"></a>1420           end
</span><span class="marked1"><a name="line1421"></a>1421         end
</span><span class="inferred0"><a name="line1422"></a>1422 
</span><span class="marked1"><a name="line1423"></a>1423         def find_with_associations(options = {})
</span><span class="uncovered0"><a name="line1424"></a>1424           catch :invalid_query do
</span><span class="uncovered1"><a name="line1425"></a>1425             join_dependency = JoinDependency.new(self, merge_includes(scope(:find, :include), options[:include]), options[:joins])
</span><span class="uncovered0"><a name="line1426"></a>1426             rows = select_all_rows(options, join_dependency)
</span><span class="uncovered1"><a name="line1427"></a>1427             return join_dependency.instantiate(rows)
</span><span class="uncovered0"><a name="line1428"></a>1428           end
</span><span class="uncovered1"><a name="line1429"></a>1429           []
</span><span class="uncovered0"><a name="line1430"></a>1430         end
</span><span class="inferred1"><a name="line1431"></a>1431 
</span><span class="inferred0"><a name="line1432"></a>1432         # Creates before_destroy callback methods that nullify, delete or destroy
</span><span class="inferred1"><a name="line1433"></a>1433         # has_many associated objects, according to the defined :dependent rule.
</span><span class="inferred0"><a name="line1434"></a>1434         #
</span><span class="inferred1"><a name="line1435"></a>1435         # See HasManyAssociation#delete_records.  Dependent associations
</span><span class="inferred0"><a name="line1436"></a>1436         # delete children, otherwise foreign key is set to NULL.
</span><span class="inferred1"><a name="line1437"></a>1437         #
</span><span class="inferred0"><a name="line1438"></a>1438         # The +extra_conditions+ parameter, which is not used within the main
</span><span class="inferred1"><a name="line1439"></a>1439         # Active Record codebase, is meant to allow plugins to define extra
</span><span class="inferred0"><a name="line1440"></a>1440         # finder conditions.
</span><span class="marked1"><a name="line1441"></a>1441         def configure_dependency_for_has_many(reflection, extra_conditions = nil)
</span><span class="marked0"><a name="line1442"></a>1442           if reflection.options.include?(:dependent)
</span><span class="uncovered1"><a name="line1443"></a>1443             # Add polymorphic type if the :as option is present
</span><span class="uncovered0"><a name="line1444"></a>1444             dependent_conditions = []
</span><span class="uncovered1"><a name="line1445"></a>1445             dependent_conditions &lt;&lt; &quot;#{reflection.primary_key_name} = \#{record.quoted_id}&quot;
</span><span class="uncovered0"><a name="line1446"></a>1446             dependent_conditions &lt;&lt; &quot;#{reflection.options[:as]}_type = '#{base_class.name}'&quot; if reflection.options[:as]
</span><span class="uncovered1"><a name="line1447"></a>1447             dependent_conditions &lt;&lt; sanitize_sql(reflection.options[:conditions]) if reflection.options[:conditions]
</span><span class="uncovered0"><a name="line1448"></a>1448             dependent_conditions &lt;&lt; extra_conditions if extra_conditions
</span><span class="uncovered1"><a name="line1449"></a>1449             dependent_conditions = dependent_conditions.collect {|where| &quot;(#{where})&quot; }.join(&quot; AND &quot;)
</span><span class="uncovered0"><a name="line1450"></a>1450 
</span><span class="uncovered1"><a name="line1451"></a>1451             case reflection.options[:dependent]
</span><span class="uncovered0"><a name="line1452"></a>1452               when :destroy
</span><span class="uncovered1"><a name="line1453"></a>1453                 method_name = &quot;has_many_dependent_destroy_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line1454"></a>1454                 define_method(method_name) do
</span><span class="uncovered1"><a name="line1455"></a>1455                   send(reflection.name).each { |o| o.destroy }
</span><span class="uncovered0"><a name="line1456"></a>1456                 end
</span><span class="uncovered1"><a name="line1457"></a>1457                 before_destroy method_name
</span><span class="uncovered0"><a name="line1458"></a>1458               when :delete_all
</span><span class="uncovered1"><a name="line1459"></a>1459                 module_eval %Q{
</span><span class="uncovered0"><a name="line1460"></a>1460                   before_destroy do |record|
</span><span class="uncovered1"><a name="line1461"></a>1461                     delete_all_has_many_dependencies(record,
</span><span class="uncovered0"><a name="line1462"></a>1462                       &quot;#{reflection.name}&quot;,
</span><span class="uncovered1"><a name="line1463"></a>1463                       #{reflection.class_name},
</span><span class="uncovered0"><a name="line1464"></a>1464                       &quot;#{dependent_conditions}&quot;)
</span><span class="uncovered1"><a name="line1465"></a>1465                   end
</span><span class="uncovered0"><a name="line1466"></a>1466                 }
</span><span class="uncovered1"><a name="line1467"></a>1467               when :nullify
</span><span class="uncovered0"><a name="line1468"></a>1468                 module_eval %Q{
</span><span class="uncovered1"><a name="line1469"></a>1469                   before_destroy do |record|
</span><span class="uncovered0"><a name="line1470"></a>1470                     nullify_has_many_dependencies(record,
</span><span class="uncovered1"><a name="line1471"></a>1471                       &quot;#{reflection.name}&quot;,
</span><span class="uncovered0"><a name="line1472"></a>1472                       #{reflection.class_name},
</span><span class="uncovered1"><a name="line1473"></a>1473                       &quot;#{reflection.primary_key_name}&quot;,
</span><span class="uncovered0"><a name="line1474"></a>1474                       &quot;#{dependent_conditions}&quot;)
</span><span class="uncovered1"><a name="line1475"></a>1475                   end
</span><span class="uncovered0"><a name="line1476"></a>1476                 }
</span><span class="uncovered1"><a name="line1477"></a>1477               else
</span><span class="uncovered0"><a name="line1478"></a>1478                 raise ArgumentError, &quot;The :dependent option expects either :destroy, :delete_all, or :nullify (#{reflection.options[:dependent].inspect})&quot;
</span><span class="uncovered1"><a name="line1479"></a>1479             end
</span><span class="uncovered0"><a name="line1480"></a>1480           end
</span><span class="marked1"><a name="line1481"></a>1481         end
</span><span class="inferred0"><a name="line1482"></a>1482 
</span><span class="inferred1"><a name="line1483"></a>1483         # Creates before_destroy callback methods that nullify, delete or destroy
</span><span class="inferred0"><a name="line1484"></a>1484         # has_one associated objects, according to the defined :dependent rule.
</span><span class="marked1"><a name="line1485"></a>1485         def configure_dependency_for_has_one(reflection)
</span><span class="uncovered0"><a name="line1486"></a>1486           if reflection.options.include?(:dependent)
</span><span class="uncovered1"><a name="line1487"></a>1487             case reflection.options[:dependent]
</span><span class="uncovered0"><a name="line1488"></a>1488               when :destroy
</span><span class="uncovered1"><a name="line1489"></a>1489                 method_name = &quot;has_one_dependent_destroy_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line1490"></a>1490                 define_method(method_name) do
</span><span class="uncovered1"><a name="line1491"></a>1491                   association = send(reflection.name)
</span><span class="uncovered0"><a name="line1492"></a>1492                   association.destroy unless association.nil?
</span><span class="uncovered1"><a name="line1493"></a>1493                 end
</span><span class="uncovered0"><a name="line1494"></a>1494                 before_destroy method_name
</span><span class="uncovered1"><a name="line1495"></a>1495               when :delete
</span><span class="uncovered0"><a name="line1496"></a>1496                 method_name = &quot;has_one_dependent_delete_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line1497"></a>1497                 define_method(method_name) do
</span><span class="uncovered0"><a name="line1498"></a>1498                   # Retrieve the associated object and delete it. The retrieval
</span><span class="uncovered1"><a name="line1499"></a>1499                   # is necessary because there may be multiple associated objects
</span><span class="uncovered0"><a name="line1500"></a>1500                   # with foreign keys pointing to this object, and we only want
</span><span class="uncovered1"><a name="line1501"></a>1501                   # to delete the correct one, not all of them.
</span><span class="uncovered0"><a name="line1502"></a>1502                   association = send(reflection.name)
</span><span class="uncovered1"><a name="line1503"></a>1503                   association.delete unless association.nil?
</span><span class="uncovered0"><a name="line1504"></a>1504                 end
</span><span class="uncovered1"><a name="line1505"></a>1505                 before_destroy method_name
</span><span class="uncovered0"><a name="line1506"></a>1506               when :nullify
</span><span class="uncovered1"><a name="line1507"></a>1507                 method_name = &quot;has_one_dependent_nullify_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line1508"></a>1508                 define_method(method_name) do
</span><span class="uncovered1"><a name="line1509"></a>1509                   association = send(reflection.name)
</span><span class="uncovered0"><a name="line1510"></a>1510                   association.update_attribute(reflection.primary_key_name, nil) unless association.nil?
</span><span class="uncovered1"><a name="line1511"></a>1511                 end
</span><span class="uncovered0"><a name="line1512"></a>1512                 before_destroy method_name
</span><span class="uncovered1"><a name="line1513"></a>1513               else
</span><span class="uncovered0"><a name="line1514"></a>1514                 raise ArgumentError, &quot;The :dependent option expects either :destroy, :delete or :nullify (#{reflection.options[:dependent].inspect})&quot;
</span><span class="uncovered1"><a name="line1515"></a>1515             end
</span><span class="uncovered0"><a name="line1516"></a>1516           end
</span><span class="uncovered1"><a name="line1517"></a>1517         end
</span><span class="inferred0"><a name="line1518"></a>1518 
</span><span class="marked1"><a name="line1519"></a>1519         def configure_dependency_for_belongs_to(reflection)
</span><span class="marked0"><a name="line1520"></a>1520           if reflection.options.include?(:dependent)
</span><span class="uncovered1"><a name="line1521"></a>1521             case reflection.options[:dependent]
</span><span class="uncovered0"><a name="line1522"></a>1522               when :destroy
</span><span class="uncovered1"><a name="line1523"></a>1523                 method_name = &quot;belongs_to_dependent_destroy_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line1524"></a>1524                 define_method(method_name) do
</span><span class="uncovered1"><a name="line1525"></a>1525                   association = send(reflection.name)
</span><span class="uncovered0"><a name="line1526"></a>1526                   association.destroy unless association.nil?
</span><span class="uncovered1"><a name="line1527"></a>1527                 end
</span><span class="uncovered0"><a name="line1528"></a>1528                 before_destroy method_name
</span><span class="uncovered1"><a name="line1529"></a>1529               when :delete
</span><span class="uncovered0"><a name="line1530"></a>1530                 method_name = &quot;belongs_to_dependent_delete_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line1531"></a>1531                 define_method(method_name) do
</span><span class="uncovered0"><a name="line1532"></a>1532                   association = send(reflection.name)
</span><span class="uncovered1"><a name="line1533"></a>1533                   association.delete unless association.nil?
</span><span class="uncovered0"><a name="line1534"></a>1534                 end
</span><span class="uncovered1"><a name="line1535"></a>1535                 before_destroy method_name
</span><span class="uncovered0"><a name="line1536"></a>1536               else
</span><span class="uncovered1"><a name="line1537"></a>1537                 raise ArgumentError, &quot;The :dependent option expects either :destroy or :delete (#{reflection.options[:dependent].inspect})&quot;
</span><span class="uncovered0"><a name="line1538"></a>1538             end
</span><span class="uncovered1"><a name="line1539"></a>1539           end
</span><span class="marked0"><a name="line1540"></a>1540         end
</span><span class="inferred1"><a name="line1541"></a>1541 
</span><span class="marked0"><a name="line1542"></a>1542         def delete_all_has_many_dependencies(record, reflection_name, association_class, dependent_conditions)
</span><span class="uncovered1"><a name="line1543"></a>1543           association_class.delete_all(dependent_conditions)
</span><span class="uncovered0"><a name="line1544"></a>1544         end
</span><span class="inferred1"><a name="line1545"></a>1545 
</span><span class="marked0"><a name="line1546"></a>1546         def nullify_has_many_dependencies(record, reflection_name, association_class, primary_key_name, dependent_conditions)
</span><span class="uncovered1"><a name="line1547"></a>1547           association_class.update_all(&quot;#{primary_key_name} = NULL&quot;, dependent_conditions)
</span><span class="uncovered0"><a name="line1548"></a>1548         end
</span><span class="inferred1"><a name="line1549"></a>1549 
</span><span class="marked0"><a name="line1550"></a>1550         mattr_accessor :valid_keys_for_has_many_association
</span><span class="marked1"><a name="line1551"></a>1551         @@valid_keys_for_has_many_association = [
</span><span class="inferred0"><a name="line1552"></a>1552           :class_name, :table_name, :foreign_key, :primary_key,
</span><span class="inferred1"><a name="line1553"></a>1553           :dependent,
</span><span class="inferred0"><a name="line1554"></a>1554           :select, :conditions, :include, :order, :group, :limit, :offset,
</span><span class="inferred1"><a name="line1555"></a>1555           :as, :through, :source, :source_type,
</span><span class="inferred0"><a name="line1556"></a>1556           :uniq,
</span><span class="inferred1"><a name="line1557"></a>1557           :finder_sql, :counter_sql,
</span><span class="inferred0"><a name="line1558"></a>1558           :before_add, :after_add, :before_remove, :after_remove,
</span><span class="inferred1"><a name="line1559"></a>1559           :extend, :readonly,
</span><span class="inferred0"><a name="line1560"></a>1560           :validate
</span><span class="inferred1"><a name="line1561"></a>1561         ]
</span><span class="inferred0"><a name="line1562"></a>1562 
</span><span class="marked1"><a name="line1563"></a>1563         def create_has_many_reflection(association_id, options, &amp;extension)
</span><span class="marked0"><a name="line1564"></a>1564           options.assert_valid_keys(valid_keys_for_has_many_association)
</span><span class="marked1"><a name="line1565"></a>1565           options[:extend] = create_extension_modules(association_id, extension, options[:extend])
</span><span class="inferred0"><a name="line1566"></a>1566 
</span><span class="marked1"><a name="line1567"></a>1567           create_reflection(:has_many, association_id, options, self)
</span><span class="inferred0"><a name="line1568"></a>1568         end
</span><span class="inferred1"><a name="line1569"></a>1569 
</span><span class="marked0"><a name="line1570"></a>1570         mattr_accessor :valid_keys_for_has_one_association
</span><span class="marked1"><a name="line1571"></a>1571         @@valid_keys_for_has_one_association = [
</span><span class="inferred0"><a name="line1572"></a>1572           :class_name, :foreign_key, :remote, :select, :conditions, :order,
</span><span class="inferred1"><a name="line1573"></a>1573           :include, :dependent, :counter_cache, :extend, :as, :readonly,
</span><span class="inferred0"><a name="line1574"></a>1574           :validate, :primary_key
</span><span class="inferred1"><a name="line1575"></a>1575         ]
</span><span class="inferred0"><a name="line1576"></a>1576 
</span><span class="marked1"><a name="line1577"></a>1577         def create_has_one_reflection(association_id, options)
</span><span class="uncovered0"><a name="line1578"></a>1578           options.assert_valid_keys(valid_keys_for_has_one_association)
</span><span class="uncovered1"><a name="line1579"></a>1579           create_reflection(:has_one, association_id, options, self)
</span><span class="uncovered0"><a name="line1580"></a>1580         end
</span><span class="inferred1"><a name="line1581"></a>1581 
</span><span class="marked0"><a name="line1582"></a>1582         def create_has_one_through_reflection(association_id, options)
</span><span class="uncovered1"><a name="line1583"></a>1583           options.assert_valid_keys(
</span><span class="uncovered0"><a name="line1584"></a>1584             :class_name, :foreign_key, :remote, :select, :conditions, :order, :include, :dependent, :counter_cache, :extend, :as, :through, :source, :source_type, :validate
</span><span class="uncovered1"><a name="line1585"></a>1585           )
</span><span class="uncovered0"><a name="line1586"></a>1586           create_reflection(:has_one, association_id, options, self)
</span><span class="uncovered1"><a name="line1587"></a>1587         end
</span><span class="inferred0"><a name="line1588"></a>1588 
</span><span class="marked1"><a name="line1589"></a>1589         mattr_accessor :valid_keys_for_belongs_to_association
</span><span class="marked0"><a name="line1590"></a>1590         @@valid_keys_for_belongs_to_association = [
</span><span class="inferred1"><a name="line1591"></a>1591           :class_name, :foreign_key, :foreign_type, :remote, :select, :conditions,
</span><span class="inferred0"><a name="line1592"></a>1592           :include, :dependent, :counter_cache, :extend, :polymorphic, :readonly,
</span><span class="inferred1"><a name="line1593"></a>1593           :validate
</span><span class="inferred0"><a name="line1594"></a>1594         ]
</span><span class="inferred1"><a name="line1595"></a>1595 
</span><span class="marked0"><a name="line1596"></a>1596         def create_belongs_to_reflection(association_id, options)
</span><span class="marked1"><a name="line1597"></a>1597           options.assert_valid_keys(valid_keys_for_belongs_to_association)
</span><span class="marked0"><a name="line1598"></a>1598           reflection = create_reflection(:belongs_to, association_id, options, self)
</span><span class="inferred1"><a name="line1599"></a>1599 
</span><span class="marked0"><a name="line1600"></a>1600           if options[:polymorphic]
</span><span class="uncovered1"><a name="line1601"></a>1601             reflection.options[:foreign_type] ||= reflection.class_name.underscore + &quot;_type&quot;
</span><span class="uncovered0"><a name="line1602"></a>1602           end
</span><span class="inferred1"><a name="line1603"></a>1603 
</span><span class="marked0"><a name="line1604"></a>1604           reflection
</span><span class="inferred1"><a name="line1605"></a>1605         end
</span><span class="inferred0"><a name="line1606"></a>1606 
</span><span class="marked1"><a name="line1607"></a>1607         mattr_accessor :valid_keys_for_has_and_belongs_to_many_association
</span><span class="marked0"><a name="line1608"></a>1608         @@valid_keys_for_has_and_belongs_to_many_association = [
</span><span class="inferred1"><a name="line1609"></a>1609           :class_name, :table_name, :join_table, :foreign_key, :association_foreign_key,
</span><span class="inferred0"><a name="line1610"></a>1610           :select, :conditions, :include, :order, :group, :limit, :offset,
</span><span class="inferred1"><a name="line1611"></a>1611           :uniq,
</span><span class="inferred0"><a name="line1612"></a>1612           :finder_sql, :counter_sql, :delete_sql, :insert_sql,
</span><span class="inferred1"><a name="line1613"></a>1613           :before_add, :after_add, :before_remove, :after_remove,
</span><span class="inferred0"><a name="line1614"></a>1614           :extend, :readonly,
</span><span class="inferred1"><a name="line1615"></a>1615           :validate
</span><span class="inferred0"><a name="line1616"></a>1616         ]
</span><span class="inferred1"><a name="line1617"></a>1617 
</span><span class="marked0"><a name="line1618"></a>1618         def create_has_and_belongs_to_many_reflection(association_id, options, &amp;extension)
</span><span class="uncovered1"><a name="line1619"></a>1619           options.assert_valid_keys(valid_keys_for_has_and_belongs_to_many_association)
</span><span class="uncovered0"><a name="line1620"></a>1620 
</span><span class="uncovered1"><a name="line1621"></a>1621           options[:extend] = create_extension_modules(association_id, extension, options[:extend])
</span><span class="uncovered0"><a name="line1622"></a>1622 
</span><span class="uncovered1"><a name="line1623"></a>1623           reflection = create_reflection(:has_and_belongs_to_many, association_id, options, self)
</span><span class="uncovered0"><a name="line1624"></a>1624 
</span><span class="uncovered1"><a name="line1625"></a>1625           reflection.options[:join_table] ||= join_table_name(undecorated_table_name(self.to_s), undecorated_table_name(reflection.class_name))
</span><span class="uncovered0"><a name="line1626"></a>1626 
</span><span class="uncovered1"><a name="line1627"></a>1627           reflection
</span><span class="uncovered0"><a name="line1628"></a>1628         end
</span><span class="inferred1"><a name="line1629"></a>1629 
</span><span class="marked0"><a name="line1630"></a>1630         def reflect_on_included_associations(associations)
</span><span class="uncovered1"><a name="line1631"></a>1631           [ associations ].flatten.collect { |association| reflect_on_association(association.to_s.intern) }
</span><span class="uncovered0"><a name="line1632"></a>1632         end
</span><span class="inferred1"><a name="line1633"></a>1633 
</span><span class="marked0"><a name="line1634"></a>1634         def guard_against_unlimitable_reflections(reflections, options)
</span><span class="uncovered1"><a name="line1635"></a>1635           if (options[:offset] || options[:limit]) &amp;&amp; !using_limitable_reflections?(reflections)
</span><span class="uncovered0"><a name="line1636"></a>1636             raise(
</span><span class="uncovered1"><a name="line1637"></a>1637               ConfigurationError,
</span><span class="uncovered0"><a name="line1638"></a>1638               &quot;You can not use offset and limit together with has_many or has_and_belongs_to_many associations&quot;
</span><span class="uncovered1"><a name="line1639"></a>1639             )
</span><span class="uncovered0"><a name="line1640"></a>1640           end
</span><span class="uncovered1"><a name="line1641"></a>1641         end
</span><span class="inferred0"><a name="line1642"></a>1642 
</span><span class="marked1"><a name="line1643"></a>1643         def select_all_rows(options, join_dependency)
</span><span class="uncovered0"><a name="line1644"></a>1644           connection.select_all(
</span><span class="uncovered1"><a name="line1645"></a>1645             construct_finder_sql_with_included_associations(options, join_dependency),
</span><span class="uncovered0"><a name="line1646"></a>1646             &quot;#{name} Load Including Associations&quot;
</span><span class="uncovered1"><a name="line1647"></a>1647           )
</span><span class="uncovered0"><a name="line1648"></a>1648         end
</span><span class="inferred1"><a name="line1649"></a>1649 
</span><span class="marked0"><a name="line1650"></a>1650         def construct_finder_sql_with_included_associations(options, join_dependency)
</span><span class="uncovered1"><a name="line1651"></a>1651           scope = scope(:find)
</span><span class="uncovered0"><a name="line1652"></a>1652           sql = &quot;SELECT #{column_aliases(join_dependency)} FROM #{(scope &amp;&amp; scope[:from]) || options[:from] || quoted_table_name} &quot;
</span><span class="uncovered1"><a name="line1653"></a>1653           sql &lt;&lt; join_dependency.join_associations.collect{|join| join.association_join }.join
</span><span class="uncovered0"><a name="line1654"></a>1654 
</span><span class="uncovered1"><a name="line1655"></a>1655           add_joins!(sql, options[:joins], scope)
</span><span class="uncovered0"><a name="line1656"></a>1656           add_conditions!(sql, options[:conditions], scope)
</span><span class="uncovered1"><a name="line1657"></a>1657           add_limited_ids_condition!(sql, options, join_dependency) if !using_limitable_reflections?(join_dependency.reflections) &amp;&amp; ((scope &amp;&amp; scope[:limit]) || options[:limit])
</span><span class="uncovered0"><a name="line1658"></a>1658 
</span><span class="uncovered1"><a name="line1659"></a>1659           add_group!(sql, options[:group], scope)
</span><span class="uncovered0"><a name="line1660"></a>1660           add_order!(sql, options[:order], scope)
</span><span class="uncovered1"><a name="line1661"></a>1661           add_limit!(sql, options, scope) if using_limitable_reflections?(join_dependency.reflections)
</span><span class="uncovered0"><a name="line1662"></a>1662           add_lock!(sql, options, scope)
</span><span class="uncovered1"><a name="line1663"></a>1663 
</span><span class="uncovered0"><a name="line1664"></a>1664           return sanitize_sql(sql)
</span><span class="uncovered1"><a name="line1665"></a>1665         end
</span><span class="inferred0"><a name="line1666"></a>1666 
</span><span class="marked1"><a name="line1667"></a>1667         def add_limited_ids_condition!(sql, options, join_dependency)
</span><span class="uncovered0"><a name="line1668"></a>1668           unless (id_list = select_limited_ids_list(options, join_dependency)).empty?
</span><span class="uncovered1"><a name="line1669"></a>1669             sql &lt;&lt; &quot;#{condition_word(sql)} #{connection.quote_table_name table_name}.#{primary_key} IN (#{id_list}) &quot;
</span><span class="uncovered0"><a name="line1670"></a>1670           else
</span><span class="uncovered1"><a name="line1671"></a>1671             throw :invalid_query
</span><span class="uncovered0"><a name="line1672"></a>1672           end
</span><span class="uncovered1"><a name="line1673"></a>1673         end
</span><span class="inferred0"><a name="line1674"></a>1674 
</span><span class="marked1"><a name="line1675"></a>1675         def select_limited_ids_list(options, join_dependency)
</span><span class="uncovered0"><a name="line1676"></a>1676           pk = columns_hash[primary_key]
</span><span class="uncovered1"><a name="line1677"></a>1677 
</span><span class="uncovered0"><a name="line1678"></a>1678           connection.select_all(
</span><span class="uncovered1"><a name="line1679"></a>1679             construct_finder_sql_for_association_limiting(options, join_dependency),
</span><span class="uncovered0"><a name="line1680"></a>1680             &quot;#{name} Load IDs For Limited Eager Loading&quot;
</span><span class="uncovered1"><a name="line1681"></a>1681           ).collect { |row| connection.quote(row[primary_key], pk) }.join(&quot;, &quot;)
</span><span class="uncovered0"><a name="line1682"></a>1682         end
</span><span class="inferred1"><a name="line1683"></a>1683 
</span><span class="marked0"><a name="line1684"></a>1684         def construct_finder_sql_for_association_limiting(options, join_dependency)
</span><span class="uncovered1"><a name="line1685"></a>1685           scope       = scope(:find)
</span><span class="uncovered0"><a name="line1686"></a>1686 
</span><span class="uncovered1"><a name="line1687"></a>1687           # Only join tables referenced in order or conditions since this is particularly slow on the pre-query.
</span><span class="uncovered0"><a name="line1688"></a>1688           tables_from_conditions = conditions_tables(options)
</span><span class="uncovered1"><a name="line1689"></a>1689           tables_from_order      = order_tables(options)
</span><span class="uncovered0"><a name="line1690"></a>1690           all_tables             = tables_from_conditions + tables_from_order
</span><span class="uncovered1"><a name="line1691"></a>1691           distinct_join_associations = all_tables.uniq.map{|table|
</span><span class="uncovered0"><a name="line1692"></a>1692             join_dependency.joins_for_table_name(table)
</span><span class="uncovered1"><a name="line1693"></a>1693           }.flatten.compact.uniq
</span><span class="uncovered0"><a name="line1694"></a>1694 
</span><span class="uncovered1"><a name="line1695"></a>1695           order = options[:order]
</span><span class="uncovered0"><a name="line1696"></a>1696           if scoped_order = (scope &amp;&amp; scope[:order])
</span><span class="uncovered1"><a name="line1697"></a>1697             order = order ? &quot;#{order}, #{scoped_order}&quot; : scoped_order
</span><span class="uncovered0"><a name="line1698"></a>1698           end
</span><span class="uncovered1"><a name="line1699"></a>1699 
</span><span class="uncovered0"><a name="line1700"></a>1700           is_distinct = !options[:joins].blank? || include_eager_conditions?(options, tables_from_conditions) || include_eager_order?(options, tables_from_order)
</span><span class="uncovered1"><a name="line1701"></a>1701           sql = &quot;SELECT &quot;
</span><span class="uncovered0"><a name="line1702"></a>1702           if is_distinct
</span><span class="uncovered1"><a name="line1703"></a>1703             sql &lt;&lt; connection.distinct(&quot;#{connection.quote_table_name table_name}.#{primary_key}&quot;, order)
</span><span class="uncovered0"><a name="line1704"></a>1704           else
</span><span class="uncovered1"><a name="line1705"></a>1705             sql &lt;&lt; primary_key
</span><span class="uncovered0"><a name="line1706"></a>1706           end
</span><span class="uncovered1"><a name="line1707"></a>1707           sql &lt;&lt; &quot; FROM #{connection.quote_table_name table_name} &quot;
</span><span class="uncovered0"><a name="line1708"></a>1708 
</span><span class="uncovered1"><a name="line1709"></a>1709           if is_distinct
</span><span class="uncovered0"><a name="line1710"></a>1710             sql &lt;&lt; distinct_join_associations.collect { |assoc| assoc.association_join }.join
</span><span class="uncovered1"><a name="line1711"></a>1711             add_joins!(sql, options[:joins], scope)
</span><span class="uncovered0"><a name="line1712"></a>1712           end
</span><span class="uncovered1"><a name="line1713"></a>1713 
</span><span class="uncovered0"><a name="line1714"></a>1714           add_conditions!(sql, options[:conditions], scope)
</span><span class="uncovered1"><a name="line1715"></a>1715           add_group!(sql, options[:group], scope)
</span><span class="uncovered0"><a name="line1716"></a>1716 
</span><span class="uncovered1"><a name="line1717"></a>1717           if order &amp;&amp; is_distinct
</span><span class="uncovered0"><a name="line1718"></a>1718             connection.add_order_by_for_association_limiting!(sql, :order =&gt; order)
</span><span class="uncovered1"><a name="line1719"></a>1719           else
</span><span class="uncovered0"><a name="line1720"></a>1720             add_order!(sql, options[:order], scope)
</span><span class="uncovered1"><a name="line1721"></a>1721           end
</span><span class="uncovered0"><a name="line1722"></a>1722 
</span><span class="uncovered1"><a name="line1723"></a>1723           add_limit!(sql, options, scope)
</span><span class="uncovered0"><a name="line1724"></a>1724 
</span><span class="uncovered1"><a name="line1725"></a>1725           return sanitize_sql(sql)
</span><span class="uncovered0"><a name="line1726"></a>1726         end
</span><span class="inferred1"><a name="line1727"></a>1727 
</span><span class="marked0"><a name="line1728"></a>1728         def conditions_tables(options)
</span><span class="uncovered1"><a name="line1729"></a>1729           # look in both sets of conditions
</span><span class="uncovered0"><a name="line1730"></a>1730           conditions = [scope(:find, :conditions), options[:conditions]].inject([]) do |all, cond|
</span><span class="uncovered1"><a name="line1731"></a>1731             case cond
</span><span class="uncovered0"><a name="line1732"></a>1732               when nil   then all
</span><span class="uncovered1"><a name="line1733"></a>1733               when Array then all &lt;&lt; cond.first
</span><span class="uncovered0"><a name="line1734"></a>1734               else            all &lt;&lt; cond
</span><span class="uncovered1"><a name="line1735"></a>1735             end
</span><span class="uncovered0"><a name="line1736"></a>1736           end
</span><span class="uncovered1"><a name="line1737"></a>1737           conditions.join(' ').scan(/([\.a-zA-Z_]+).?\./).flatten
</span><span class="uncovered0"><a name="line1738"></a>1738         end
</span><span class="inferred1"><a name="line1739"></a>1739 
</span><span class="marked0"><a name="line1740"></a>1740         def order_tables(options)
</span><span class="uncovered1"><a name="line1741"></a>1741           order = [options[:order], scope(:find, :order) ].join(&quot;, &quot;)
</span><span class="uncovered0"><a name="line1742"></a>1742           return [] unless order &amp;&amp; order.is_a?(String)
</span><span class="uncovered1"><a name="line1743"></a>1743           order.scan(/([\.a-zA-Z_]+).?\./).flatten
</span><span class="uncovered0"><a name="line1744"></a>1744         end
</span><span class="inferred1"><a name="line1745"></a>1745 
</span><span class="marked0"><a name="line1746"></a>1746         def selects_tables(options)
</span><span class="uncovered1"><a name="line1747"></a>1747           select = options[:select]
</span><span class="uncovered0"><a name="line1748"></a>1748           return [] unless select &amp;&amp; select.is_a?(String)
</span><span class="uncovered1"><a name="line1749"></a>1749           select.scan(/&quot;?([\.a-zA-Z_]+)&quot;?.?\./).flatten
</span><span class="uncovered0"><a name="line1750"></a>1750         end
</span><span class="inferred1"><a name="line1751"></a>1751 
</span><span class="inferred0"><a name="line1752"></a>1752         # Checks if the conditions reference a table other than the current model table
</span><span class="marked1"><a name="line1753"></a>1753         def include_eager_conditions?(options, tables = nil)
</span><span class="uncovered0"><a name="line1754"></a>1754           ((tables || conditions_tables(options)) - [table_name]).any?
</span><span class="uncovered1"><a name="line1755"></a>1755         end
</span><span class="inferred0"><a name="line1756"></a>1756 
</span><span class="inferred1"><a name="line1757"></a>1757         # Checks if the query order references a table other than the current model's table.
</span><span class="marked0"><a name="line1758"></a>1758         def include_eager_order?(options, tables = nil)
</span><span class="uncovered1"><a name="line1759"></a>1759           ((tables || order_tables(options)) - [table_name]).any?
</span><span class="uncovered0"><a name="line1760"></a>1760         end
</span><span class="inferred1"><a name="line1761"></a>1761 
</span><span class="marked0"><a name="line1762"></a>1762         def include_eager_select?(options)
</span><span class="uncovered1"><a name="line1763"></a>1763           (selects_tables(options) - [table_name]).any?
</span><span class="uncovered0"><a name="line1764"></a>1764         end
</span><span class="inferred1"><a name="line1765"></a>1765 
</span><span class="marked0"><a name="line1766"></a>1766         def references_eager_loaded_tables?(options)
</span><span class="uncovered1"><a name="line1767"></a>1767           include_eager_order?(options) || include_eager_conditions?(options) || include_eager_select?(options)
</span><span class="uncovered0"><a name="line1768"></a>1768         end
</span><span class="inferred1"><a name="line1769"></a>1769 
</span><span class="marked0"><a name="line1770"></a>1770         def using_limitable_reflections?(reflections)
</span><span class="uncovered1"><a name="line1771"></a>1771           reflections.reject { |r| [ :belongs_to, :has_one ].include?(r.macro) }.length.zero?
</span><span class="uncovered0"><a name="line1772"></a>1772         end
</span><span class="inferred1"><a name="line1773"></a>1773 
</span><span class="marked0"><a name="line1774"></a>1774         def column_aliases(join_dependency)
</span><span class="uncovered1"><a name="line1775"></a>1775           join_dependency.joins.collect{|join| join.column_names_with_alias.collect{|column_name, aliased_name|
</span><span class="uncovered0"><a name="line1776"></a>1776               &quot;#{connection.quote_table_name join.aliased_table_name}.#{connection.quote_column_name column_name} AS #{aliased_name}&quot;}}.flatten.join(&quot;, &quot;)
</span><span class="uncovered1"><a name="line1777"></a>1777         end
</span><span class="inferred0"><a name="line1778"></a>1778 
</span><span class="marked1"><a name="line1779"></a>1779         def add_association_callbacks(association_name, options)
</span><span class="marked0"><a name="line1780"></a>1780           callbacks = %w(before_add after_add before_remove after_remove)
</span><span class="marked1"><a name="line1781"></a>1781           callbacks.each do |callback_name|
</span><span class="marked0"><a name="line1782"></a>1782             full_callback_name = &quot;#{callback_name}_for_#{association_name}&quot;
</span><span class="marked1"><a name="line1783"></a>1783             defined_callbacks = options[callback_name.to_sym]
</span><span class="marked0"><a name="line1784"></a>1784             if options.has_key?(callback_name.to_sym)
</span><span class="inferred1"><a name="line1785"></a>1785               class_inheritable_reader full_callback_name.to_sym
</span><span class="inferred0"><a name="line1786"></a>1786               write_inheritable_attribute(full_callback_name.to_sym, [defined_callbacks].flatten)
</span><span class="inferred1"><a name="line1787"></a>1787             else
</span><span class="marked0"><a name="line1788"></a>1788               write_inheritable_attribute(full_callback_name.to_sym, [])
</span><span class="inferred1"><a name="line1789"></a>1789             end
</span><span class="inferred0"><a name="line1790"></a>1790           end
</span><span class="inferred1"><a name="line1791"></a>1791         end
</span><span class="inferred0"><a name="line1792"></a>1792 
</span><span class="marked1"><a name="line1793"></a>1793         def condition_word(sql)
</span><span class="uncovered0"><a name="line1794"></a>1794           sql =~ /where/i ? &quot; AND &quot; : &quot;WHERE &quot;
</span><span class="uncovered1"><a name="line1795"></a>1795         end
</span><span class="inferred0"><a name="line1796"></a>1796 
</span><span class="marked1"><a name="line1797"></a>1797         def create_extension_modules(association_id, block_extension, extensions)
</span><span class="marked0"><a name="line1798"></a>1798           if block_extension
</span><span class="uncovered1"><a name="line1799"></a>1799             extension_module_name = &quot;#{self.to_s.demodulize}#{association_id.to_s.camelize}AssociationExtension&quot;
</span><span class="uncovered0"><a name="line1800"></a>1800 
</span><span class="uncovered1"><a name="line1801"></a>1801             silence_warnings do
</span><span class="uncovered0"><a name="line1802"></a>1802               self.parent.const_set(extension_module_name, Module.new(&amp;block_extension))
</span><span class="uncovered1"><a name="line1803"></a>1803             end
</span><span class="uncovered0"><a name="line1804"></a>1804             Array(extensions).push(&quot;#{self.parent}::#{extension_module_name}&quot;.constantize)
</span><span class="inferred1"><a name="line1805"></a>1805           else
</span><span class="marked0"><a name="line1806"></a>1806             Array(extensions)
</span><span class="inferred1"><a name="line1807"></a>1807           end
</span><span class="marked0"><a name="line1808"></a>1808         end
</span><span class="inferred1"><a name="line1809"></a>1809 
</span><span class="marked0"><a name="line1810"></a>1810         class JoinDependency # :nodoc:
</span><span class="marked1"><a name="line1811"></a>1811           attr_reader :joins, :reflections, :table_aliases
</span><span class="inferred0"><a name="line1812"></a>1812 
</span><span class="marked1"><a name="line1813"></a>1813           def initialize(base, associations, joins)
</span><span class="uncovered0"><a name="line1814"></a>1814             @joins                 = [JoinBase.new(base, joins)]
</span><span class="uncovered1"><a name="line1815"></a>1815             @associations          = associations
</span><span class="uncovered0"><a name="line1816"></a>1816             @reflections           = []
</span><span class="uncovered1"><a name="line1817"></a>1817             @base_records_hash     = {}
</span><span class="uncovered0"><a name="line1818"></a>1818             @base_records_in_order = []
</span><span class="uncovered1"><a name="line1819"></a>1819             @table_aliases         = Hash.new { |aliases, table| aliases[table] = 0 }
</span><span class="uncovered0"><a name="line1820"></a>1820             @table_aliases[base.table_name] = 1
</span><span class="uncovered1"><a name="line1821"></a>1821             build(associations)
</span><span class="uncovered0"><a name="line1822"></a>1822           end
</span><span class="inferred1"><a name="line1823"></a>1823 
</span><span class="marked0"><a name="line1824"></a>1824           def join_associations
</span><span class="uncovered1"><a name="line1825"></a>1825             @joins[1..-1].to_a
</span><span class="uncovered0"><a name="line1826"></a>1826           end
</span><span class="inferred1"><a name="line1827"></a>1827 
</span><span class="marked0"><a name="line1828"></a>1828           def join_base
</span><span class="uncovered1"><a name="line1829"></a>1829             @joins[0]
</span><span class="uncovered0"><a name="line1830"></a>1830           end
</span><span class="inferred1"><a name="line1831"></a>1831 
</span><span class="marked0"><a name="line1832"></a>1832           def instantiate(rows)
</span><span class="uncovered1"><a name="line1833"></a>1833             rows.each_with_index do |row, i|
</span><span class="uncovered0"><a name="line1834"></a>1834               primary_id = join_base.record_id(row)
</span><span class="uncovered1"><a name="line1835"></a>1835               unless @base_records_hash[primary_id]
</span><span class="uncovered0"><a name="line1836"></a>1836                 @base_records_in_order &lt;&lt; (@base_records_hash[primary_id] = join_base.instantiate(row))
</span><span class="uncovered1"><a name="line1837"></a>1837               end
</span><span class="uncovered0"><a name="line1838"></a>1838               construct(@base_records_hash[primary_id], @associations, join_associations.dup, row)
</span><span class="uncovered1"><a name="line1839"></a>1839             end
</span><span class="uncovered0"><a name="line1840"></a>1840             remove_duplicate_results!(join_base.active_record, @base_records_in_order, @associations)
</span><span class="uncovered1"><a name="line1841"></a>1841             return @base_records_in_order
</span><span class="uncovered0"><a name="line1842"></a>1842           end
</span><span class="inferred1"><a name="line1843"></a>1843 
</span><span class="marked0"><a name="line1844"></a>1844           def remove_duplicate_results!(base, records, associations)
</span><span class="uncovered1"><a name="line1845"></a>1845             case associations
</span><span class="uncovered0"><a name="line1846"></a>1846               when Symbol, String
</span><span class="uncovered1"><a name="line1847"></a>1847                 reflection = base.reflections[associations]
</span><span class="uncovered0"><a name="line1848"></a>1848                 if reflection &amp;&amp; [:has_many, :has_and_belongs_to_many].include?(reflection.macro)
</span><span class="uncovered1"><a name="line1849"></a>1849                   records.each { |record| record.send(reflection.name).target.uniq! }
</span><span class="uncovered0"><a name="line1850"></a>1850                 end
</span><span class="uncovered1"><a name="line1851"></a>1851               when Array
</span><span class="uncovered0"><a name="line1852"></a>1852                 associations.each do |association|
</span><span class="uncovered1"><a name="line1853"></a>1853                   remove_duplicate_results!(base, records, association)
</span><span class="uncovered0"><a name="line1854"></a>1854                 end
</span><span class="uncovered1"><a name="line1855"></a>1855               when Hash
</span><span class="uncovered0"><a name="line1856"></a>1856                 associations.keys.each do |name|
</span><span class="uncovered1"><a name="line1857"></a>1857                   reflection = base.reflections[name]
</span><span class="uncovered0"><a name="line1858"></a>1858                   is_collection = [:has_many, :has_and_belongs_to_many].include?(reflection.macro)
</span><span class="uncovered1"><a name="line1859"></a>1859 
</span><span class="uncovered0"><a name="line1860"></a>1860                   parent_records = records.map do |record|
</span><span class="uncovered1"><a name="line1861"></a>1861                     descendant = record.send(reflection.name)
</span><span class="uncovered0"><a name="line1862"></a>1862                     next unless descendant
</span><span class="uncovered1"><a name="line1863"></a>1863                     descendant.target.uniq! if is_collection
</span><span class="uncovered0"><a name="line1864"></a>1864                     descendant
</span><span class="uncovered1"><a name="line1865"></a>1865                   end.flatten.compact
</span><span class="uncovered0"><a name="line1866"></a>1866 
</span><span class="uncovered1"><a name="line1867"></a>1867                   remove_duplicate_results!(reflection.class_name.constantize, parent_records, associations[name]) unless parent_records.empty?
</span><span class="uncovered0"><a name="line1868"></a>1868                 end
</span><span class="uncovered1"><a name="line1869"></a>1869             end
</span><span class="uncovered0"><a name="line1870"></a>1870           end
</span><span class="inferred1"><a name="line1871"></a>1871 
</span><span class="marked0"><a name="line1872"></a>1872           def join_for_table_name(table_name)
</span><span class="uncovered1"><a name="line1873"></a>1873             join = (@joins.select{|j|j.aliased_table_name == table_name.gsub(/^\&quot;(.*)\&quot;$/){$1} }.first) rescue nil
</span><span class="uncovered0"><a name="line1874"></a>1874             return join unless join.nil?
</span><span class="uncovered1"><a name="line1875"></a>1875             @joins.select{|j|j.is_a?(JoinAssociation) &amp;&amp; j.aliased_join_table_name == table_name.gsub(/^\&quot;(.*)\&quot;$/){$1} }.first rescue nil
</span><span class="uncovered0"><a name="line1876"></a>1876           end
</span><span class="inferred1"><a name="line1877"></a>1877 
</span><span class="marked0"><a name="line1878"></a>1878           def joins_for_table_name(table_name)
</span><span class="uncovered1"><a name="line1879"></a>1879             join = join_for_table_name(table_name)
</span><span class="uncovered0"><a name="line1880"></a>1880             result = nil
</span><span class="uncovered1"><a name="line1881"></a>1881             if join &amp;&amp; join.is_a?(JoinAssociation)
</span><span class="uncovered0"><a name="line1882"></a>1882               result = [join]
</span><span class="uncovered1"><a name="line1883"></a>1883               if join.parent &amp;&amp; join.parent.is_a?(JoinAssociation)
</span><span class="uncovered0"><a name="line1884"></a>1884                 result = joins_for_table_name(join.parent.aliased_table_name) +
</span><span class="uncovered1"><a name="line1885"></a>1885                          result
</span><span class="uncovered0"><a name="line1886"></a>1886               end
</span><span class="uncovered1"><a name="line1887"></a>1887             end
</span><span class="uncovered0"><a name="line1888"></a>1888             result
</span><span class="uncovered1"><a name="line1889"></a>1889           end
</span><span class="inferred0"><a name="line1890"></a>1890 
</span><span class="marked1"><a name="line1891"></a>1891           protected
</span><span class="marked0"><a name="line1892"></a>1892             def build(associations, parent = nil)
</span><span class="uncovered1"><a name="line1893"></a>1893               parent ||= @joins.last
</span><span class="uncovered0"><a name="line1894"></a>1894               case associations
</span><span class="uncovered1"><a name="line1895"></a>1895                 when Symbol, String
</span><span class="uncovered0"><a name="line1896"></a>1896                   reflection = parent.reflections[associations.to_s.intern] or
</span><span class="uncovered1"><a name="line1897"></a>1897                   raise ConfigurationError, &quot;Association named '#{ associations }' was not found; perhaps you misspelled it?&quot;
</span><span class="uncovered0"><a name="line1898"></a>1898                   @reflections &lt;&lt; reflection
</span><span class="uncovered1"><a name="line1899"></a>1899                   @joins &lt;&lt; build_join_association(reflection, parent)
</span><span class="uncovered0"><a name="line1900"></a>1900                 when Array
</span><span class="uncovered1"><a name="line1901"></a>1901                   associations.each do |association|
</span><span class="uncovered0"><a name="line1902"></a>1902                     build(association, parent)
</span><span class="uncovered1"><a name="line1903"></a>1903                   end
</span><span class="uncovered0"><a name="line1904"></a>1904                 when Hash
</span><span class="uncovered1"><a name="line1905"></a>1905                   associations.keys.sort{|a,b|a.to_s&lt;=&gt;b.to_s}.each do |name|
</span><span class="uncovered0"><a name="line1906"></a>1906                     build(name, parent)
</span><span class="uncovered1"><a name="line1907"></a>1907                     build(associations[name])
</span><span class="uncovered0"><a name="line1908"></a>1908                   end
</span><span class="uncovered1"><a name="line1909"></a>1909                 else
</span><span class="uncovered0"><a name="line1910"></a>1910                   raise ConfigurationError, associations.inspect
</span><span class="uncovered1"><a name="line1911"></a>1911               end
</span><span class="uncovered0"><a name="line1912"></a>1912             end
</span><span class="inferred1"><a name="line1913"></a>1913 
</span><span class="inferred0"><a name="line1914"></a>1914             # overridden in InnerJoinDependency subclass
</span><span class="marked1"><a name="line1915"></a>1915             def build_join_association(reflection, parent)
</span><span class="uncovered0"><a name="line1916"></a>1916               JoinAssociation.new(reflection, self, parent)
</span><span class="uncovered1"><a name="line1917"></a>1917             end
</span><span class="inferred0"><a name="line1918"></a>1918 
</span><span class="marked1"><a name="line1919"></a>1919             def construct(parent, associations, joins, row)
</span><span class="uncovered0"><a name="line1920"></a>1920               case associations
</span><span class="uncovered1"><a name="line1921"></a>1921                 when Symbol, String
</span><span class="uncovered0"><a name="line1922"></a>1922                   while (join = joins.shift).reflection.name.to_s != associations.to_s
</span><span class="uncovered1"><a name="line1923"></a>1923                     raise ConfigurationError, &quot;Not Enough Associations&quot; if joins.empty?
</span><span class="uncovered0"><a name="line1924"></a>1924                   end
</span><span class="uncovered1"><a name="line1925"></a>1925                   construct_association(parent, join, row)
</span><span class="uncovered0"><a name="line1926"></a>1926                 when Array
</span><span class="uncovered1"><a name="line1927"></a>1927                   associations.each do |association|
</span><span class="uncovered0"><a name="line1928"></a>1928                     construct(parent, association, joins, row)
</span><span class="uncovered1"><a name="line1929"></a>1929                   end
</span><span class="uncovered0"><a name="line1930"></a>1930                 when Hash
</span><span class="uncovered1"><a name="line1931"></a>1931                   associations.keys.sort{|a,b|a.to_s&lt;=&gt;b.to_s}.each do |name|
</span><span class="uncovered0"><a name="line1932"></a>1932                     association = construct_association(parent, joins.shift, row)
</span><span class="uncovered1"><a name="line1933"></a>1933                     construct(association, associations[name], joins, row) if association
</span><span class="uncovered0"><a name="line1934"></a>1934                   end
</span><span class="uncovered1"><a name="line1935"></a>1935                 else
</span><span class="uncovered0"><a name="line1936"></a>1936                   raise ConfigurationError, associations.inspect
</span><span class="uncovered1"><a name="line1937"></a>1937               end
</span><span class="uncovered0"><a name="line1938"></a>1938             end
</span><span class="inferred1"><a name="line1939"></a>1939 
</span><span class="marked0"><a name="line1940"></a>1940             def construct_association(record, join, row)
</span><span class="uncovered1"><a name="line1941"></a>1941               case join.reflection.macro
</span><span class="uncovered0"><a name="line1942"></a>1942                 when :has_many, :has_and_belongs_to_many
</span><span class="uncovered1"><a name="line1943"></a>1943                   collection = record.send(join.reflection.name)
</span><span class="uncovered0"><a name="line1944"></a>1944                   collection.loaded
</span><span class="uncovered1"><a name="line1945"></a>1945 
</span><span class="uncovered0"><a name="line1946"></a>1946                   return nil if record.id.to_s != join.parent.record_id(row).to_s or row[join.aliased_primary_key].nil?
</span><span class="uncovered1"><a name="line1947"></a>1947                   association = join.instantiate(row)
</span><span class="uncovered0"><a name="line1948"></a>1948                   collection.target.push(association)
</span><span class="uncovered1"><a name="line1949"></a>1949                 when :has_one
</span><span class="uncovered0"><a name="line1950"></a>1950                   return if record.id.to_s != join.parent.record_id(row).to_s
</span><span class="uncovered1"><a name="line1951"></a>1951                   return if record.instance_variable_defined?(&quot;@#{join.reflection.name}&quot;)
</span><span class="uncovered0"><a name="line1952"></a>1952                   association = join.instantiate(row) unless row[join.aliased_primary_key].nil?
</span><span class="uncovered1"><a name="line1953"></a>1953                   record.send(&quot;set_#{join.reflection.name}_target&quot;, association)
</span><span class="uncovered0"><a name="line1954"></a>1954                 when :belongs_to
</span><span class="uncovered1"><a name="line1955"></a>1955                   return if record.id.to_s != join.parent.record_id(row).to_s or row[join.aliased_primary_key].nil?
</span><span class="uncovered0"><a name="line1956"></a>1956                   association = join.instantiate(row)
</span><span class="uncovered1"><a name="line1957"></a>1957                   record.send(&quot;set_#{join.reflection.name}_target&quot;, association)
</span><span class="uncovered0"><a name="line1958"></a>1958                 else
</span><span class="uncovered1"><a name="line1959"></a>1959                   raise ConfigurationError, &quot;unknown macro: #{join.reflection.macro}&quot;
</span><span class="uncovered0"><a name="line1960"></a>1960               end
</span><span class="uncovered1"><a name="line1961"></a>1961               return association
</span><span class="uncovered0"><a name="line1962"></a>1962             end
</span><span class="inferred1"><a name="line1963"></a>1963 
</span><span class="marked0"><a name="line1964"></a>1964           class JoinBase # :nodoc:
</span><span class="marked1"><a name="line1965"></a>1965             attr_reader :active_record, :table_joins
</span><span class="marked0"><a name="line1966"></a>1966             delegate    :table_name, :column_names, :primary_key, :reflections, :sanitize_sql, :to =&gt; :active_record
</span><span class="inferred1"><a name="line1967"></a>1967 
</span><span class="marked0"><a name="line1968"></a>1968             def initialize(active_record, joins = nil)
</span><span class="uncovered1"><a name="line1969"></a>1969               @active_record = active_record
</span><span class="uncovered0"><a name="line1970"></a>1970               @cached_record = {}
</span><span class="uncovered1"><a name="line1971"></a>1971               @table_joins   = joins
</span><span class="uncovered0"><a name="line1972"></a>1972             end
</span><span class="inferred1"><a name="line1973"></a>1973 
</span><span class="marked0"><a name="line1974"></a>1974             def aliased_prefix
</span><span class="uncovered1"><a name="line1975"></a>1975               &quot;t0&quot;
</span><span class="uncovered0"><a name="line1976"></a>1976             end
</span><span class="inferred1"><a name="line1977"></a>1977 
</span><span class="marked0"><a name="line1978"></a>1978             def aliased_primary_key
</span><span class="uncovered1"><a name="line1979"></a>1979               &quot;#{aliased_prefix}_r0&quot;
</span><span class="uncovered0"><a name="line1980"></a>1980             end
</span><span class="inferred1"><a name="line1981"></a>1981 
</span><span class="marked0"><a name="line1982"></a>1982             def aliased_table_name
</span><span class="uncovered1"><a name="line1983"></a>1983               active_record.table_name
</span><span class="uncovered0"><a name="line1984"></a>1984             end
</span><span class="inferred1"><a name="line1985"></a>1985 
</span><span class="marked0"><a name="line1986"></a>1986             def column_names_with_alias
</span><span class="uncovered1"><a name="line1987"></a>1987               unless defined?(@column_names_with_alias)
</span><span class="uncovered0"><a name="line1988"></a>1988                 @column_names_with_alias = []
</span><span class="uncovered1"><a name="line1989"></a>1989 
</span><span class="uncovered0"><a name="line1990"></a>1990                 ([primary_key] + (column_names - [primary_key])).each_with_index do |column_name, i|
</span><span class="uncovered1"><a name="line1991"></a>1991                   @column_names_with_alias &lt;&lt; [column_name, &quot;#{aliased_prefix}_r#{i}&quot;]
</span><span class="uncovered0"><a name="line1992"></a>1992                 end
</span><span class="uncovered1"><a name="line1993"></a>1993               end
</span><span class="uncovered0"><a name="line1994"></a>1994 
</span><span class="uncovered1"><a name="line1995"></a>1995               @column_names_with_alias
</span><span class="uncovered0"><a name="line1996"></a>1996             end
</span><span class="inferred1"><a name="line1997"></a>1997 
</span><span class="marked0"><a name="line1998"></a>1998             def extract_record(row)
</span><span class="uncovered1"><a name="line1999"></a>1999               column_names_with_alias.inject({}){|record, (cn, an)| record[cn] = row[an]; record}
</span><span class="uncovered0"><a name="line2000"></a>2000             end
</span><span class="inferred1"><a name="line2001"></a>2001 
</span><span class="marked0"><a name="line2002"></a>2002             def record_id(row)
</span><span class="uncovered1"><a name="line2003"></a>2003               row[aliased_primary_key]
</span><span class="uncovered0"><a name="line2004"></a>2004             end
</span><span class="inferred1"><a name="line2005"></a>2005 
</span><span class="marked0"><a name="line2006"></a>2006             def instantiate(row)
</span><span class="uncovered1"><a name="line2007"></a>2007               @cached_record[record_id(row)] ||= active_record.send(:instantiate, extract_record(row))
</span><span class="uncovered0"><a name="line2008"></a>2008             end
</span><span class="uncovered1"><a name="line2009"></a>2009           end
</span><span class="inferred0"><a name="line2010"></a>2010 
</span><span class="marked1"><a name="line2011"></a>2011           class JoinAssociation &lt; JoinBase # :nodoc:
</span><span class="marked0"><a name="line2012"></a>2012             attr_reader :reflection, :parent, :aliased_table_name, :aliased_prefix, :aliased_join_table_name, :parent_table_name
</span><span class="marked1"><a name="line2013"></a>2013             delegate    :options, :klass, :through_reflection, :source_reflection, :to =&gt; :reflection
</span><span class="inferred0"><a name="line2014"></a>2014 
</span><span class="marked1"><a name="line2015"></a>2015             def initialize(reflection, join_dependency, parent = nil)
</span><span class="uncovered0"><a name="line2016"></a>2016               reflection.check_validity!
</span><span class="uncovered1"><a name="line2017"></a>2017               if reflection.options[:polymorphic]
</span><span class="uncovered0"><a name="line2018"></a>2018                 raise EagerLoadPolymorphicError.new(reflection)
</span><span class="uncovered1"><a name="line2019"></a>2019               end
</span><span class="uncovered0"><a name="line2020"></a>2020 
</span><span class="uncovered1"><a name="line2021"></a>2021               super(reflection.klass)
</span><span class="uncovered0"><a name="line2022"></a>2022               @join_dependency    = join_dependency
</span><span class="uncovered1"><a name="line2023"></a>2023               @parent             = parent
</span><span class="uncovered0"><a name="line2024"></a>2024               @reflection         = reflection
</span><span class="uncovered1"><a name="line2025"></a>2025               @aliased_prefix     = &quot;t#{ join_dependency.joins.size }&quot;
</span><span class="uncovered0"><a name="line2026"></a>2026               @parent_table_name  = parent.active_record.table_name
</span><span class="uncovered1"><a name="line2027"></a>2027               @aliased_table_name = aliased_table_name_for(table_name)
</span><span class="uncovered0"><a name="line2028"></a>2028 
</span><span class="uncovered1"><a name="line2029"></a>2029               if reflection.macro == :has_and_belongs_to_many
</span><span class="uncovered0"><a name="line2030"></a>2030                 @aliased_join_table_name = aliased_table_name_for(reflection.options[:join_table], &quot;_join&quot;)
</span><span class="uncovered1"><a name="line2031"></a>2031               end
</span><span class="uncovered0"><a name="line2032"></a>2032 
</span><span class="uncovered1"><a name="line2033"></a>2033               if [:has_many, :has_one].include?(reflection.macro) &amp;&amp; reflection.options[:through]
</span><span class="uncovered0"><a name="line2034"></a>2034                 @aliased_join_table_name = aliased_table_name_for(reflection.through_reflection.klass.table_name, &quot;_join&quot;)
</span><span class="uncovered1"><a name="line2035"></a>2035               end
</span><span class="uncovered0"><a name="line2036"></a>2036             end
</span><span class="inferred1"><a name="line2037"></a>2037 
</span><span class="marked0"><a name="line2038"></a>2038             def association_join
</span><span class="uncovered1"><a name="line2039"></a>2039               connection = reflection.active_record.connection
</span><span class="uncovered0"><a name="line2040"></a>2040               join = case reflection.macro
</span><span class="uncovered1"><a name="line2041"></a>2041                 when :has_and_belongs_to_many
</span><span class="uncovered0"><a name="line2042"></a>2042                   &quot; #{join_type} %s ON %s.%s = %s.%s &quot; % [
</span><span class="uncovered1"><a name="line2043"></a>2043                      table_alias_for(options[:join_table], aliased_join_table_name),
</span><span class="uncovered0"><a name="line2044"></a>2044                      connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered1"><a name="line2045"></a>2045                      options[:foreign_key] || reflection.active_record.to_s.foreign_key,
</span><span class="uncovered0"><a name="line2046"></a>2046                      connection.quote_table_name(parent.aliased_table_name),
</span><span class="uncovered1"><a name="line2047"></a>2047                      reflection.active_record.primary_key] +
</span><span class="uncovered0"><a name="line2048"></a>2048                   &quot; #{join_type} %s ON %s.%s = %s.%s &quot; % [
</span><span class="uncovered1"><a name="line2049"></a>2049                      table_name_and_alias,
</span><span class="uncovered0"><a name="line2050"></a>2050                      connection.quote_table_name(aliased_table_name),
</span><span class="uncovered1"><a name="line2051"></a>2051                      klass.primary_key,
</span><span class="uncovered0"><a name="line2052"></a>2052                      connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered1"><a name="line2053"></a>2053                      options[:association_foreign_key] || klass.to_s.foreign_key
</span><span class="uncovered0"><a name="line2054"></a>2054                      ]
</span><span class="uncovered1"><a name="line2055"></a>2055                 when :has_many, :has_one
</span><span class="uncovered0"><a name="line2056"></a>2056                   case
</span><span class="uncovered1"><a name="line2057"></a>2057                     when reflection.options[:through]
</span><span class="uncovered0"><a name="line2058"></a>2058                       through_conditions = through_reflection.options[:conditions] ? &quot;AND #{interpolate_sql(sanitize_sql(through_reflection.options[:conditions]))}&quot; : ''
</span><span class="uncovered1"><a name="line2059"></a>2059 
</span><span class="uncovered0"><a name="line2060"></a>2060                       jt_foreign_key = jt_as_extra = jt_source_extra = jt_sti_extra = nil
</span><span class="uncovered1"><a name="line2061"></a>2061                       first_key = second_key = as_extra = nil
</span><span class="uncovered0"><a name="line2062"></a>2062 
</span><span class="uncovered1"><a name="line2063"></a>2063                       if through_reflection.options[:as] # has_many :through against a polymorphic join
</span><span class="uncovered0"><a name="line2064"></a>2064                         jt_foreign_key = through_reflection.options[:as].to_s + '_id'
</span><span class="uncovered1"><a name="line2065"></a>2065                         jt_as_extra = &quot; AND %s.%s = %s&quot; % [
</span><span class="uncovered0"><a name="line2066"></a>2066                           connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered1"><a name="line2067"></a>2067                           connection.quote_column_name(through_reflection.options[:as].to_s + '_type'),
</span><span class="uncovered0"><a name="line2068"></a>2068                           klass.quote_value(parent.active_record.base_class.name)
</span><span class="uncovered1"><a name="line2069"></a>2069                         ]
</span><span class="uncovered0"><a name="line2070"></a>2070                       else
</span><span class="uncovered1"><a name="line2071"></a>2071                         jt_foreign_key = through_reflection.primary_key_name
</span><span class="uncovered0"><a name="line2072"></a>2072                       end
</span><span class="uncovered1"><a name="line2073"></a>2073 
</span><span class="uncovered0"><a name="line2074"></a>2074                       case source_reflection.macro
</span><span class="uncovered1"><a name="line2075"></a>2075                       when :has_many
</span><span class="uncovered0"><a name="line2076"></a>2076                         if source_reflection.options[:as]
</span><span class="uncovered1"><a name="line2077"></a>2077                           first_key   = &quot;#{source_reflection.options[:as]}_id&quot;
</span><span class="uncovered0"><a name="line2078"></a>2078                           second_key  = options[:foreign_key] || primary_key
</span><span class="uncovered1"><a name="line2079"></a>2079                           as_extra    = &quot; AND %s.%s = %s&quot; % [
</span><span class="uncovered0"><a name="line2080"></a>2080                             connection.quote_table_name(aliased_table_name),
</span><span class="uncovered1"><a name="line2081"></a>2081                             connection.quote_column_name(&quot;#{source_reflection.options[:as]}_type&quot;),
</span><span class="uncovered0"><a name="line2082"></a>2082                             klass.quote_value(source_reflection.active_record.base_class.name)
</span><span class="uncovered1"><a name="line2083"></a>2083                           ]
</span><span class="uncovered0"><a name="line2084"></a>2084                         else
</span><span class="uncovered1"><a name="line2085"></a>2085                           first_key   = through_reflection.klass.base_class.to_s.foreign_key
</span><span class="uncovered0"><a name="line2086"></a>2086                           second_key  = options[:foreign_key] || primary_key
</span><span class="uncovered1"><a name="line2087"></a>2087                         end
</span><span class="uncovered0"><a name="line2088"></a>2088 
</span><span class="uncovered1"><a name="line2089"></a>2089                         unless through_reflection.klass.descends_from_active_record?
</span><span class="uncovered0"><a name="line2090"></a>2090                           jt_sti_extra = &quot; AND %s.%s = %s&quot; % [
</span><span class="uncovered1"><a name="line2091"></a>2091                             connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered0"><a name="line2092"></a>2092                             connection.quote_column_name(through_reflection.active_record.inheritance_column),
</span><span class="uncovered1"><a name="line2093"></a>2093                             through_reflection.klass.quote_value(through_reflection.klass.sti_name)]
</span><span class="uncovered0"><a name="line2094"></a>2094                         end
</span><span class="uncovered1"><a name="line2095"></a>2095                       when :belongs_to
</span><span class="uncovered0"><a name="line2096"></a>2096                         first_key = primary_key
</span><span class="uncovered1"><a name="line2097"></a>2097                         if reflection.options[:source_type]
</span><span class="uncovered0"><a name="line2098"></a>2098                           second_key = source_reflection.association_foreign_key
</span><span class="uncovered1"><a name="line2099"></a>2099                           jt_source_extra = &quot; AND %s.%s = %s&quot; % [
</span><span class="uncovered0"><a name="line2100"></a>2100                             connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered1"><a name="line2101"></a>2101                             connection.quote_column_name(reflection.source_reflection.options[:foreign_type]),
</span><span class="uncovered0"><a name="line2102"></a>2102                             klass.quote_value(reflection.options[:source_type])
</span><span class="uncovered1"><a name="line2103"></a>2103                           ]
</span><span class="uncovered0"><a name="line2104"></a>2104                         else
</span><span class="uncovered1"><a name="line2105"></a>2105                           second_key = source_reflection.primary_key_name
</span><span class="uncovered0"><a name="line2106"></a>2106                         end
</span><span class="uncovered1"><a name="line2107"></a>2107                       end
</span><span class="uncovered0"><a name="line2108"></a>2108 
</span><span class="uncovered1"><a name="line2109"></a>2109                       &quot; #{join_type} %s ON (%s.%s = %s.%s%s%s%s) &quot; % [
</span><span class="uncovered0"><a name="line2110"></a>2110                         table_alias_for(through_reflection.klass.table_name, aliased_join_table_name),
</span><span class="uncovered1"><a name="line2111"></a>2111                         connection.quote_table_name(parent.aliased_table_name),
</span><span class="uncovered0"><a name="line2112"></a>2112                         connection.quote_column_name(parent.primary_key),
</span><span class="uncovered1"><a name="line2113"></a>2113                         connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered0"><a name="line2114"></a>2114                         connection.quote_column_name(jt_foreign_key),
</span><span class="uncovered1"><a name="line2115"></a>2115                         jt_as_extra, jt_source_extra, jt_sti_extra
</span><span class="uncovered0"><a name="line2116"></a>2116                       ] +
</span><span class="uncovered1"><a name="line2117"></a>2117                       &quot; #{join_type} %s ON (%s.%s = %s.%s%s) &quot; % [
</span><span class="uncovered0"><a name="line2118"></a>2118                         table_name_and_alias,
</span><span class="uncovered1"><a name="line2119"></a>2119                         connection.quote_table_name(aliased_table_name),
</span><span class="uncovered0"><a name="line2120"></a>2120                         connection.quote_column_name(first_key),
</span><span class="uncovered1"><a name="line2121"></a>2121                         connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered0"><a name="line2122"></a>2122                         connection.quote_column_name(second_key),
</span><span class="uncovered1"><a name="line2123"></a>2123                         as_extra
</span><span class="uncovered0"><a name="line2124"></a>2124                       ]
</span><span class="uncovered1"><a name="line2125"></a>2125 
</span><span class="uncovered0"><a name="line2126"></a>2126                     when reflection.options[:as] &amp;&amp; [:has_many, :has_one].include?(reflection.macro)
</span><span class="uncovered1"><a name="line2127"></a>2127                       &quot; #{join_type} %s ON %s.%s = %s.%s AND %s.%s = %s&quot; % [
</span><span class="uncovered0"><a name="line2128"></a>2128                         table_name_and_alias,
</span><span class="uncovered1"><a name="line2129"></a>2129                         connection.quote_table_name(aliased_table_name),
</span><span class="uncovered0"><a name="line2130"></a>2130                         &quot;#{reflection.options[:as]}_id&quot;,
</span><span class="uncovered1"><a name="line2131"></a>2131                         connection.quote_table_name(parent.aliased_table_name),
</span><span class="uncovered0"><a name="line2132"></a>2132                         parent.primary_key,
</span><span class="uncovered1"><a name="line2133"></a>2133                         connection.quote_table_name(aliased_table_name),
</span><span class="uncovered0"><a name="line2134"></a>2134                         &quot;#{reflection.options[:as]}_type&quot;,
</span><span class="uncovered1"><a name="line2135"></a>2135                         klass.quote_value(parent.active_record.base_class.name)
</span><span class="uncovered0"><a name="line2136"></a>2136                       ]
</span><span class="uncovered1"><a name="line2137"></a>2137                     else
</span><span class="uncovered0"><a name="line2138"></a>2138                       foreign_key = options[:foreign_key] || reflection.active_record.name.foreign_key
</span><span class="uncovered1"><a name="line2139"></a>2139                       &quot; #{join_type} %s ON %s.%s = %s.%s &quot; % [
</span><span class="uncovered0"><a name="line2140"></a>2140                         table_name_and_alias,
</span><span class="uncovered1"><a name="line2141"></a>2141                         aliased_table_name,
</span><span class="uncovered0"><a name="line2142"></a>2142                         foreign_key,
</span><span class="uncovered1"><a name="line2143"></a>2143                         parent.aliased_table_name,
</span><span class="uncovered0"><a name="line2144"></a>2144                         parent.primary_key
</span><span class="uncovered1"><a name="line2145"></a>2145                       ]
</span><span class="uncovered0"><a name="line2146"></a>2146                   end
</span><span class="uncovered1"><a name="line2147"></a>2147                 when :belongs_to
</span><span class="uncovered0"><a name="line2148"></a>2148                   &quot; #{join_type} %s ON %s.%s = %s.%s &quot; % [
</span><span class="uncovered1"><a name="line2149"></a>2149                      table_name_and_alias,
</span><span class="uncovered0"><a name="line2150"></a>2150                      connection.quote_table_name(aliased_table_name),
</span><span class="uncovered1"><a name="line2151"></a>2151                      reflection.klass.primary_key,
</span><span class="uncovered0"><a name="line2152"></a>2152                      connection.quote_table_name(parent.aliased_table_name),
</span><span class="uncovered1"><a name="line2153"></a>2153                      options[:foreign_key] || reflection.primary_key_name
</span><span class="uncovered0"><a name="line2154"></a>2154                     ]
</span><span class="uncovered1"><a name="line2155"></a>2155                 else
</span><span class="uncovered0"><a name="line2156"></a>2156                   &quot;&quot;
</span><span class="uncovered1"><a name="line2157"></a>2157               end || ''
</span><span class="uncovered0"><a name="line2158"></a>2158               join &lt;&lt; %(AND %s) % [
</span><span class="uncovered1"><a name="line2159"></a>2159                 klass.send(:type_condition, aliased_table_name)] unless klass.descends_from_active_record?
</span><span class="uncovered0"><a name="line2160"></a>2160 
</span><span class="uncovered1"><a name="line2161"></a>2161               [through_reflection, reflection].each do |ref|
</span><span class="uncovered0"><a name="line2162"></a>2162                 join &lt;&lt; &quot;AND #{interpolate_sql(sanitize_sql(ref.options[:conditions]))} &quot; if ref &amp;&amp; ref.options[:conditions]
</span><span class="uncovered1"><a name="line2163"></a>2163               end
</span><span class="uncovered0"><a name="line2164"></a>2164 
</span><span class="uncovered1"><a name="line2165"></a>2165               join
</span><span class="uncovered0"><a name="line2166"></a>2166             end
</span><span class="inferred1"><a name="line2167"></a>2167 
</span><span class="marked0"><a name="line2168"></a>2168             protected
</span><span class="inferred1"><a name="line2169"></a>2169 
</span><span class="marked0"><a name="line2170"></a>2170               def aliased_table_name_for(name, suffix = nil)
</span><span class="uncovered1"><a name="line2171"></a>2171                 if !parent.table_joins.blank? &amp;&amp; parent.table_joins.to_s.downcase =~ %r{join(\s+\w+)?\s+#{name.downcase}\son}
</span><span class="uncovered0"><a name="line2172"></a>2172                   @join_dependency.table_aliases[name] += 1
</span><span class="uncovered1"><a name="line2173"></a>2173                 end
</span><span class="uncovered0"><a name="line2174"></a>2174 
</span><span class="uncovered1"><a name="line2175"></a>2175                 unless @join_dependency.table_aliases[name].zero?
</span><span class="uncovered0"><a name="line2176"></a>2176                   # if the table name has been used, then use an alias
</span><span class="uncovered1"><a name="line2177"></a>2177                   name = active_record.connection.table_alias_for &quot;#{pluralize(reflection.name)}_#{parent_table_name}#{suffix}&quot;
</span><span class="uncovered0"><a name="line2178"></a>2178                   table_index = @join_dependency.table_aliases[name]
</span><span class="uncovered1"><a name="line2179"></a>2179                   @join_dependency.table_aliases[name] += 1
</span><span class="uncovered0"><a name="line2180"></a>2180                   name = name[0..active_record.connection.table_alias_length-3] + &quot;_#{table_index+1}&quot; if table_index &gt; 0
</span><span class="uncovered1"><a name="line2181"></a>2181                 else
</span><span class="uncovered0"><a name="line2182"></a>2182                   @join_dependency.table_aliases[name] += 1
</span><span class="uncovered1"><a name="line2183"></a>2183                 end
</span><span class="uncovered0"><a name="line2184"></a>2184 
</span><span class="uncovered1"><a name="line2185"></a>2185                 name
</span><span class="uncovered0"><a name="line2186"></a>2186               end
</span><span class="inferred1"><a name="line2187"></a>2187 
</span><span class="marked0"><a name="line2188"></a>2188               def pluralize(table_name)
</span><span class="uncovered1"><a name="line2189"></a>2189                 ActiveRecord::Base.pluralize_table_names ? table_name.to_s.pluralize : table_name
</span><span class="uncovered0"><a name="line2190"></a>2190               end
</span><span class="inferred1"><a name="line2191"></a>2191 
</span><span class="marked0"><a name="line2192"></a>2192               def table_alias_for(table_name, table_alias)
</span><span class="uncovered1"><a name="line2193"></a>2193                  &quot;#{reflection.active_record.connection.quote_table_name(table_name)} #{table_alias if table_name != table_alias}&quot;.strip
</span><span class="uncovered0"><a name="line2194"></a>2194               end
</span><span class="inferred1"><a name="line2195"></a>2195 
</span><span class="marked0"><a name="line2196"></a>2196               def table_name_and_alias
</span><span class="uncovered1"><a name="line2197"></a>2197                 table_alias_for table_name, @aliased_table_name
</span><span class="uncovered0"><a name="line2198"></a>2198               end
</span><span class="inferred1"><a name="line2199"></a>2199 
</span><span class="marked0"><a name="line2200"></a>2200               def interpolate_sql(sql)
</span><span class="uncovered1"><a name="line2201"></a>2201                 instance_eval(&quot;%@#{sql.gsub('@', '\@')}@&quot;)
</span><span class="uncovered0"><a name="line2202"></a>2202               end
</span><span class="inferred1"><a name="line2203"></a>2203 
</span><span class="marked0"><a name="line2204"></a>2204             private
</span><span class="marked1"><a name="line2205"></a>2205               def join_type
</span><span class="uncovered0"><a name="line2206"></a>2206                 &quot;LEFT OUTER JOIN&quot;
</span><span class="uncovered1"><a name="line2207"></a>2207               end
</span><span class="uncovered0"><a name="line2208"></a>2208           end
</span><span class="uncovered1"><a name="line2209"></a>2209         end
</span><span class="inferred0"><a name="line2210"></a>2210 
</span><span class="marked1"><a name="line2211"></a>2211         class InnerJoinDependency &lt; JoinDependency # :nodoc:
</span><span class="marked0"><a name="line2212"></a>2212           protected
</span><span class="marked1"><a name="line2213"></a>2213             def build_join_association(reflection, parent)
</span><span class="uncovered0"><a name="line2214"></a>2214               InnerJoinAssociation.new(reflection, self, parent)
</span><span class="uncovered1"><a name="line2215"></a>2215             end
</span><span class="inferred0"><a name="line2216"></a>2216 
</span><span class="marked1"><a name="line2217"></a>2217           class InnerJoinAssociation &lt; JoinAssociation
</span><span class="marked0"><a name="line2218"></a>2218             private
</span><span class="marked1"><a name="line2219"></a>2219               def join_type
</span><span class="uncovered0"><a name="line2220"></a>2220                 &quot;INNER JOIN&quot;
</span><span class="uncovered1"><a name="line2221"></a>2221               end
</span><span class="uncovered0"><a name="line2222"></a>2222           end
</span><span class="uncovered1"><a name="line2223"></a>2223         end
</span><span class="uncovered0"><a name="line2224"></a>2224 
</span><span class="uncovered1"><a name="line2225"></a>2225     end
</span><span class="uncovered0"><a name="line2226"></a>2226   end
</span><span class="uncovered1"><a name="line2227"></a>2227 end
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
